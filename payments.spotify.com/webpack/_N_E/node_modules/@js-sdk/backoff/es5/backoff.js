"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backoff = void 0;
var counter_1 = require("./counter");
var defer_1 = require("./_internal/defer");
/**
 * A backoff module that handles retries and backoff with different timings
 *     depending on configuration.
 *     Expects a "thenable" function to retry.
 *
 * Usage:
 *     function getData(url) {
 *       return getRequest(url); // pretend function that returns ajax promise
 *     }
 *
 *     function successHandler(data) {
 *       console.log('great success!', data);
 *     }
 *
 *     Backoff.init(getData.bind(null, 'https://httpbin.org/get'))
 *       .then(successHandler)
 *       .catch(function() {
 *         console.log('you're out of luck!');
 *       });
 */
function backoffDestroyed() {
    return Promise.reject(new Error('Backoff already consumed'));
}
/**
 * The default options used when initializing a Backoff instance. Values in
 *     this object are overridden if supplied to the constructor.
 */
var backoffDefaults = {
    backoffInitial: false,
    baseTime: 200,
    ceiling: 0,
    curve: 'linear',
    maxDuration: Infinity,
    maxRetries: Infinity,
    maxTime: Infinity,
    retryPredicate: function () { return true; },
};
var Backoff = /** @class */ (function () {
    /**
     * Backoff, handles backoff retries for async functions.
     *
     * @constructor
     * @export module:spotify-backoff
     * @param fn - Thenable function to use the backoff with.
     * @param opts - Initialization
     * options, extends/overrides defaults.
     */
    function Backoff(fn, opts) {
        /**
         * Promise to resolve/reject when successful/failed.
         */
        this._resolver = defer_1.defer();
        /**
         * Epoch timestamp, will be set when the backoff starts.
         */
        this._ts = 0;
        /**
         * Number of executed retries.
         */
        this._callCount = 0;
        /**
         * Timeout that holds the sleep until next retry.
         */
        this._tickInterval = 0;
        /**
         * True when the backoff is running.
         */
        this._isRunning = false;
        var options = opts || {};
        this._fn = fn;
        this._maxDuration = options.maxDuration || backoffDefaults.maxDuration;
        this._maxRetries =
            'maxRetries' in options
                ? options.maxRetries
                : backoffDefaults.maxRetries;
        this._maxTime = options.maxTime || backoffDefaults.maxTime;
        this._retryPredicate =
            options.retryPredicate || backoffDefaults.retryPredicate;
        this._backoffInitial = !!options.backoffInitial;
        this._counter = new counter_1.Counter({
            curve: options.curve,
            baseTime: options.baseTime,
            ceiling: options.ceiling,
        });
        if (this._backoffInitial) {
            // To get the correct timings from the counter instance, max retries needs
            // to be incremented by one if backoffInitial is set.
            this._maxRetries += 1;
        }
    }
    /**
     * Initializes and starts a new backoff.
     *
     * @param fn - Thenable function to use the backoff with.
     * @param opts - Initialization options.
     * @return A new backoff instance.
     */
    Backoff.init = function (fn, opts) {
        if (opts === void 0) { opts = {}; }
        return new Backoff(fn, opts).start();
    };
    /**
     * Destroys a backoff instance.
     */
    Backoff.prototype._destroy = function () {
        this._fn = backoffDestroyed;
        this._resolver = defer_1.defer();
    };
    /**
     * Failure handler, will reset the timeout to the next point in the future.
     *
     * @param err - The error from the failure that might cause a retry.
     */
    Backoff.prototype._failure = function (err) {
        var _this = this;
        if (err && 'retryAfter' in err) {
            this._retryAfter(err);
        }
        else {
            var time = this._counter.getTime(this._callCount);
            var shouldRetry = this._shouldRetry(time, err);
            if (shouldRetry) {
                this._callCount++;
                this._tickInterval = setTimeout(function () { return _this._tick(); }, time);
            }
            else {
                this._resolver.reject(err);
                this._destroy();
            }
        }
    };
    /**
   * Failure handler for errors with the `retryAfter` property set, will retry
  once that amount of milliseconds have passed.
   *
   * @param err - The error from the failure that caused the retry.
   */
    Backoff.prototype._retryAfter = function (err) {
        var _this = this;
        this._callCount++;
        this._tickInterval = setTimeout(function () { return _this._tick(); }, err.retryAfter);
    };
    /**
     * Success handler, resolves the resolver promise and makes the backoff
     * self-destruct.
     *
     * @param args - The arguments to the resolver.
     */
    Backoff.prototype._success = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this._resolver).resolve.apply(_a, args);
        this._destroy();
    };
    /**
     * Test if backoff should retry.
     *
     * @param time - The time for the next tick timeout.
     * @param err - The error from the failure that possibly might cause a retry.
     * @return True if the backoff should be retried, false otherwise.
     */
    Backoff.prototype._shouldRetry = function (time, err) {
        var duration = Date.now() - this._ts + time;
        return (this._callCount < this._maxRetries &&
            time < this._maxTime &&
            duration < this._maxDuration &&
            this._retryPredicate(err));
    };
    /**
     * Tick, timed-out function that initializes the next retry.
     */
    Backoff.prototype._tick = function () {
        var _this = this;
        this._fn()
            .then(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this._success.apply(_this, args);
        })
            .catch(function (e) { return _this._failure(e); });
    };
    /**
     * Returns the resolver promise for a backoff instance.
     *
     * @return The resolver promise.
     */
    Backoff.prototype.getResolver = function () {
        return this._resolver.promise;
    };
    /**
     * Starts the backoff, returns it's resolver promise.
     *
     * @param fn - The function to start retrying.
     * @return The result of the resolver promise.
     */
    Backoff.prototype.start = function (fn) {
        var _this = this;
        if (!this._fn && fn) {
            this._fn = fn;
        }
        if (!this._isRunning) {
            this._ts = Date.now();
            this._isRunning = true;
            if (this._backoffInitial) {
                this._callCount = 1;
                this._tickInterval = setTimeout(function () { return _this._tick(); }, this._counter.getTime(0));
            }
            else {
                this._tick();
            }
        }
        return this._resolver.promise;
    };
    /**
     * Stops a backoff instance, and destroys it.
     *
     */
    Backoff.prototype.stop = function () {
        clearTimeout(this._tickInterval);
        this._isRunning = false;
        this._destroy();
    };
    /**
     * Get the number of retries.
     *
     * @return The number of retries.
     */
    Backoff.prototype.getRetryCount = function () {
        return this._callCount;
    };
    return Backoff;
}());
exports.Backoff = Backoff;
//# sourceMappingURL=backoff.js.map