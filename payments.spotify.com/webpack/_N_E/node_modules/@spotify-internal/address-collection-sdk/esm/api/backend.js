var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { baseApiPath, baseUrlMapping } from './environment';
import { getCsrfToken, setCsrfToken } from '../lib/csrfStore';
const failedRequest = {
    body: null,
    ok: false,
    status: 500,
};
export const responseToJson = (response) => __awaiter(void 0, void 0, void 0, function* () {
    const { ok, status } = response;
    try {
        return {
            body: yield response.json(),
            ok,
            status,
        };
    }
    catch (e) {
        return {
            body: null,
            ok,
            status,
        };
    }
});
const requestWithCsrf = (environment, path, data, method = 'POST') => __awaiter(void 0, void 0, void 0, function* () {
    const url = `${baseUrlMapping[environment]}${baseApiPath}${path}`;
    const headers = { 'X-CSRF-Token': getCsrfToken() };
    const fetchOptions = {
        method: method,
        body: JSON.stringify(Object.assign({}, data)),
        credentials: 'include',
        headers: headers,
    };
    try {
        let response = yield fetch(url, fetchOptions);
        if (response.headers.get('x-csrf-token')) {
            setCsrfToken(response.headers.get('x-csrf-token'));
        }
        if (response.headers.get('x-csrf-valid') === 'false') {
            const newFetchOptions = Object.assign(Object.assign({}, fetchOptions), { headers: { 'X-CSRF-Token': getCsrfToken() } });
            response = yield fetch(url, newFetchOptions);
        }
        return responseToJson(response);
    }
    catch (e) {
        return failedRequest;
    }
});
const getRequest = (environment, path) => {
    const url = `${baseUrlMapping[environment]}${baseApiPath}${path}`;
    return fetch(url, {
        method: 'GET',
        credentials: 'include',
    })
        .then(response => {
        if (response.headers.get('x-csrf-token')) {
            setCsrfToken(response.headers.get('x-csrf-token'));
        }
        return responseToJson(response);
    })
        .catch(() => failedRequest);
};
export const getAddressConfiguration = (environment, country, addressProfile = 'tax') => __awaiter(void 0, void 0, void 0, function* () {
    const path = `/v1/configuration?country=${country}&type=${addressProfile}`;
    return getRequest(environment, path);
});
export const updateAddress = (environment, data, retryRequest) => __awaiter(void 0, void 0, void 0, function* () {
    const path = '/v1/upsert';
    let result = yield requestWithCsrf(environment, path, data, 'PUT');
    if (retryRequest && result.status >= 500) {
        yield new Promise(resolve => setTimeout(resolve, 1000));
        result = yield requestWithCsrf(environment, path, data, 'PUT');
    }
    if (retryRequest && result.status >= 500) {
        yield new Promise(resolve => setTimeout(resolve, 2000));
        result = yield requestWithCsrf(environment, path, data, 'PUT');
    }
    return result;
});
//# sourceMappingURL=backend.js.map