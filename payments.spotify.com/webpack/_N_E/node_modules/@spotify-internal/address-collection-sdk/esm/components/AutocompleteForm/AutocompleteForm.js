var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debounce from '../../lib/debounce';
import { components } from 'react-select';
import React, { useCallback, useContext, useMemo, useState, } from 'react';
import FormattedAddress from '../FormattedAddress';
import { CtaWrapper } from '../AddressCollection/components';
import { ButtonPrimary, FormGroup, FormHelpText, TextLink, Type, } from '@spotify-internal/encore-web';
import { useIsMounted } from '../../lib/useIsMounted';
import { findAddress, retrieveAddress } from '../../lib/loqate/loqate';
import { TranslationsContext } from '../TranslationsContext/TranslationsContext';
import { ActionType } from '../AddressCollection/reducer';
import trackers from '../../lib/tracking/trackers';
import { sendAddressApiMetric } from '../../lib/tracking/metrics';
import StyledAsyncSelect from '../StyledAsyncSelect/StyledAsyncSelect';
const requireFieldErrorKey = 'required_field';
const fetchFullAddress = (option, setSelectedAddress) => __awaiter(void 0, void 0, void 0, function* () {
    const address = yield retrieveAddress(option.id);
    if (address) {
        setSelectedAddress(address);
    }
    else {
        setSelectedAddress({});
    }
});
const Submitter = (props) => {
    props.submitRef.current = props.triggerSubmit;
    return null;
};
const DropdownIndicator = (props) => {
    return (React.createElement(components.DropdownIndicator, Object.assign({}, props),
        React.createElement("span", null)));
};
export default function AutocompleteForm({ addressCollectionProps, configuration, handleSubmit, dispatch, }) {
    const isMounted = useIsMounted();
    const { translations } = useContext(TranslationsContext);
    const [inputValue, setInputValue] = useState('');
    const [value, setValue] = useState(null);
    const [defaultOptions, setDefaultOptions] = useState([]);
    const [selectedAddress, setSelectedAddress] = useState(configuration.address);
    const [error, setError] = useState(false);
    const [noAddressesError, setAddressesError] = useState(false);
    const [menuIsOpen, setMenuIsOpen] = useState(false);
    const { submitRef, isStandalone } = addressCollectionProps;
    const handleInputChange = (newValue, action) => {
        if (action.action === 'input-change') {
            setInputValue(newValue);
            setError(false);
            setAddressesError(false);
            if (newValue === '') {
                setSelectedAddress({});
                setValue(null);
            }
        }
        else if (action.action !== 'input-blur' &&
            action.action !== 'menu-close') {
            setInputValue(newValue);
        }
        else if (action.action === 'menu-close') {
            if (value) {
                setInputValue(value.label);
            }
            setMenuIsOpen(false);
        }
    };
    const updateAutocomplete = useCallback(() => {
        let latestRequestText = '';
        return (text) => __awaiter(this, void 0, void 0, function* () {
            latestRequestText = text;
            if (text.length < 3) {
                setMenuIsOpen(false);
                setDefaultOptions([]);
                return undefined;
            }
            const options = yield findAddress(text);
            if (options.length === 0) {
                setMenuIsOpen(false);
                setAddressesError(true);
                return undefined;
            }
            if (latestRequestText !== text) {
                return undefined;
            }
            setMenuIsOpen(true);
            setDefaultOptions(options);
            return options;
        });
    }, []);
    const loadOptions = useMemo(() => debounce(updateAutocomplete(), 500), [updateAutocomplete]);
    const triggerSubmit = () => __awaiter(this, void 0, void 0, function* () {
        if (selectedAddress === null) {
            setError(true);
            dispatch({
                type: ActionType.SET_IS_LOADING,
                payload: false,
            });
            trackers.trackAddressCollectionError(requireFieldErrorKey, 'autocomplete_field');
            sendAddressApiMetric('autocomplete_field_required', true);
            throw Error(translations.required_field);
        }
        setError(false);
        yield handleSubmit({
            address: selectedAddress,
            isMounted,
            isUsingAutocomplete: true,
        });
    });
    return (React.createElement(React.Fragment, null,
        submitRef && (React.createElement(Submitter, { submitRef: submitRef, triggerSubmit: triggerSubmit })),
        React.createElement(FormGroup, { label: "Enter your address", labelFor: "autocomplete_field" },
            React.createElement(StyledAsyncSelect, { id: "autocomplete_field", error: error || noAddressesError, placeholder: "Address", value: value, components: { DropdownIndicator }, inputValue: inputValue, onInputChange: handleInputChange, onChange: newValue => {
                    if (!newValue) {
                        return;
                    }
                    if (newValue.type !== 'Address') {
                        findAddress(inputValue, newValue.id).then(setDefaultOptions);
                        setError(false);
                        setMenuIsOpen(true);
                    }
                    else {
                        setValue(newValue);
                        fetchFullAddress(newValue, setSelectedAddress);
                        setMenuIsOpen(false);
                    }
                }, getOptionLabel: e => {
                    return e.label;
                }, getOptionValue: e => e.label, cacheOptions: true, defaultOptions: defaultOptions, loadOptions: loadOptions, menuIsOpen: menuIsOpen, closeMenuOnSelect: false, blurInputOnSelect: false }),
            error && (React.createElement(FormHelpText, { error: true }, translations.required_autocomplete)),
            noAddressesError && (React.createElement(FormHelpText, { error: true }, translations.no_addresses_found))),
        selectedAddress && (React.createElement(React.Fragment, null,
            React.createElement(Type, { as: "h3", weight: "bold", condensed: true }, "Selected address"),
            React.createElement(FormattedAddress, { address: selectedAddress, country: "US" }))),
        React.createElement("p", null,
            React.createElement(TextLink, { as: "a", href: "#", onClick: () => {
                    dispatch({
                        type: ActionType.SET_FORM_TYPE,
                        payload: 0,
                    });
                    trackers.trackAddressCollectionSwitchForm();
                    sendAddressApiMetric('switch-to-full-address-form');
                } }, "Switch to form")),
        isStandalone && (React.createElement(CtaWrapper, null,
            React.createElement(ButtonPrimary, { disabled: !selectedAddress, onClick: triggerSubmit }, "Save Address")))));
}
//# sourceMappingURL=AutocompleteForm.js.map