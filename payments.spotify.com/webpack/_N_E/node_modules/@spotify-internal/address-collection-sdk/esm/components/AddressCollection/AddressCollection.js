var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import React, { useCallback, useEffect, useReducer, } from 'react';
import { useDebounce } from 'use-debounce';
import { COUNTRY_US } from '../../lib/usStates';
import LoadingOverlay from '../LoadingIndicator';
import ErrorContainer from '../ErrorContainer/ErrorContainer';
import { useConfiguration } from '../../lib/useConfiguration';
import { Wrapper } from './components';
import { TranslationsContext, TranslationsProvider, } from '../TranslationsContext/TranslationsContext';
import trackers, { initializeAddressCollectionViewId, } from '../../lib/tracking/trackers';
import reducer, { ActionType, initialState } from './reducer';
import Header from '../Header/Header';
import ConfirmedAddressSection from '../ConfirmedAddressSection/ConfirmedAddressSection';
import AddressForm from '../AddressForm/AddressForm';
import ExplanationModal from '../ExplanationModal/ExplanationModal';
import LegalTerms from '../LegalTerms';
import { RemoteConfigProvider } from '@spotify-internal/remote-config-resolver-react';
import { useRemoteConfigResolver } from '../../lib/remoteConfiguration/remoteConfiguration';
import RemoteConfigWrapper from './RemoteConfigWrapper';
import { initializeSemanticMetrics } from '../../lib/tracking/metrics';
export default function AddressCollection(props) {
    const { environment, country, checkoutViewId, context, locale, onSuccess, onSetIsLoading, onSetAddress, isStandalone, submitRef, onTrackingIdChange, fallbackEnabled, onSetPostalCode, legalTerms, experimentalAutocomplete, addressProfile, formOnly, } = props;
    initializeAddressCollectionViewId(environment, context, onTrackingIdChange);
    initializeSemanticMetrics(environment, context);
    const [state, dispatch] = useReducer(reducer, initialState);
    useEffect(() => {
        const formType = experimentalAutocomplete
            ? 1
            : 0;
        dispatch({
            type: ActionType.SET_FORM_TYPE,
            payload: formType,
        });
    }, [experimentalAutocomplete]);
    const setIsLoading = useCallback((newValue) => {
        dispatch({ type: ActionType.SET_IS_LOADING, payload: newValue });
        onSetIsLoading === null || onSetIsLoading === void 0 ? void 0 : onSetIsLoading(newValue);
    }, [onSetIsLoading]);
    const openExplanationModal = () => dispatch({
        type: ActionType.SET_EXPLANATION_MODAL_VISIBLE,
        payload: true,
    });
    const closeExplanationModal = () => dispatch({
        type: ActionType.SET_EXPLANATION_MODAL_VISIBLE,
        payload: false,
    });
    const configuration = useConfiguration(environment, country, dispatch, setIsLoading, fallbackEnabled, addressProfile || 'tax');
    useEffect(() => {
        if (!isStandalone && (configuration === null || configuration === void 0 ? void 0 : configuration.address)) {
            dispatch({
                type: ActionType.ADDRESS_SUCCESSFULLY_SAVED,
                payload: configuration.address,
            });
        }
    }, [configuration, isStandalone]);
    if (country.toLowerCase() !== COUNTRY_US) {
        throw new Error('Only US is supported');
    }
    useEffect(() => {
        trackers.trackAddressCollectionView(country, checkoutViewId);
    }, [country, checkoutViewId]);
    const [inlineErrors] = useDebounce(state.trackedErrors, 500);
    useEffect(() => {
        for (const key in inlineErrors) {
            if (inlineErrors.hasOwnProperty(key)) {
                trackers.trackAddressCollectionError(inlineErrors[key], key);
            }
        }
    }, [inlineErrors]);
    useEffect(() => {
        if (submitRef && !state.isEditing) {
            submitRef.current = () => __awaiter(this, void 0, void 0, function* () {
                if (state.confirmedAddress && onSetPostalCode) {
                    onSetPostalCode(state.confirmedAddress.postal_code_short);
                }
                if (state.confirmedAddress && onSetAddress) {
                    onSetAddress(state.confirmedAddress);
                }
                if (onSuccess) {
                    onSuccess();
                }
                return;
            });
        }
    }, [
        submitRef,
        onSuccess,
        state.isEditing,
        state.confirmedAddress,
        onSetPostalCode,
        onSetAddress,
    ]);
    const { resolver } = useRemoteConfigResolver(props.environment);
    return (React.createElement(RemoteConfigProvider, { resolver: resolver },
        React.createElement(TranslationsProvider, { locale: locale },
            React.createElement(TranslationsContext.Consumer, null, ({ translations, translationsLoaded }) => (React.createElement(Wrapper, null,
                (state.isLoading || !translationsLoaded) && isStandalone && (React.createElement(LoadingOverlay, null)),
                translationsLoaded && (React.createElement(React.Fragment, null,
                    !formOnly && (React.createElement(Header, { isStandalone: isStandalone, translations: translations, onLearnMore: openExplanationModal })),
                    state.explanationModalVisible && (React.createElement(ExplanationModal, { onClose: closeExplanationModal })),
                    React.createElement(ErrorContainer, { errors: state.globalErrors }),
                    React.createElement(RemoteConfigWrapper, { resolver: resolver, dispatch: dispatch, state: state }, state.isEditing && configuration && (React.createElement(AddressForm, { resolver: resolver, configuration: configuration, state: state, dispatch: dispatch, addressCollectionProps: props }))),
                    isStandalone && legalTerms && (React.createElement(LegalTerms, { legalTerms: legalTerms })),
                    !state.isEditing && state.confirmedAddress && (React.createElement(ConfirmedAddressSection, { isStandalone: isStandalone, dispatch: dispatch, state: state, country: country }))))))))));
}
//# sourceMappingURL=AddressCollection.js.map