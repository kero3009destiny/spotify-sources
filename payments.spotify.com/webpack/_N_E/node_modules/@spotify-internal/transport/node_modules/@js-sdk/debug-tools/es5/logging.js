"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.remove = exports.forTag = exports.disableAll = exports.enableAll = exports.setLevel = exports.disable = exports.enable = exports.list = exports.unintercept = exports.intercept = void 0;
var debug_logger_1 = require("./debug_logger");
var GLOBAL_LOGGER_REGISTRY_KEY = '__dbgLoggerRegistry';
var globalRegistry = global[GLOBAL_LOGGER_REGISTRY_KEY];
if (!globalRegistry) {
    globalRegistry = {
        map: {},
        list: [],
        loggingPredicate: function () { },
    };
    if (Object.defineProperty) {
        Object.defineProperty(global, GLOBAL_LOGGER_REGISTRY_KEY, {
            value: globalRegistry,
        });
    }
    else {
        global[GLOBAL_LOGGER_REGISTRY_KEY] = globalRegistry;
    }
}
var loggerMap = globalRegistry.map;
var loggers = globalRegistry.list;
function _checkLog(logObj) {
    if (globalRegistry.loggingPredicate &&
        globalRegistry.loggingPredicate(logObj)) {
        return true;
    }
    return false;
}
var _level = 'log';
function intercept(predicate) {
    if (typeof predicate !== 'function') {
        throw new TypeError('Logging.intercept requires a function predicate.');
    }
    globalRegistry.loggingPredicate = predicate;
}
exports.intercept = intercept;
function unintercept() {
    globalRegistry.loggingPredicate = function () { };
}
exports.unintercept = unintercept;
function list(asArray) {
    var keys = Object.keys(loggerMap)
        .filter(function (key) { return loggerMap[key]; })
        .sort();
    if (asArray) {
        return keys.map(function (key) {
            return {
                tag: key,
                description: loggerMap[key].description || 'No description.',
            };
        });
    }
    return keys.reduce(function (obj, key) {
        obj[key] = loggerMap[key].description || 'No description';
        return obj;
    }, {});
}
exports.list = list;
function enable(tag) {
    var _a;
    var tags = Array.isArray(tag) ? tag : [tag];
    var tagLen = tags.length;
    while (tagLen--) {
        var tagName = (_a = tags[tagLen]) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        var loggerLen = loggers.length;
        while (loggerLen--) {
            var logger = loggers[loggerLen];
            if (logger.matchesTag(tagName)) {
                logger.enable();
            }
        }
    }
}
exports.enable = enable;
function disable(tag) {
    var _a;
    var tags = Array.isArray(tag) ? tag : [tag];
    var tagLen = tags.length;
    while (tagLen--) {
        var tagName = (_a = tags[tagLen]) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        var loggerLen = loggers.length;
        while (loggerLen--) {
            var logger = loggers[loggerLen];
            if (logger.matchesTag(tagName)) {
                logger.disable();
            }
        }
    }
}
exports.disable = disable;
function setLevel(levelName) {
    _level = levelName;
    var loggerLen = loggers.length;
    while (loggerLen--) {
        var logger = loggers[loggerLen];
        if (logger) {
            logger.setLevel(levelName);
        }
    }
}
exports.setLevel = setLevel;
function enableAll() {
    var l = loggers.length;
    while (l--) {
        if (!loggers[l]) {
            continue;
        }
        loggers[l].enable();
    }
}
exports.enableAll = enableAll;
function disableAll() {
    var l = loggers.length;
    while (l--) {
        if (!loggers[l]) {
            continue;
        }
        loggers[l].disable();
    }
}
exports.disableAll = disableAll;
function forTag(tag, descriptor) {
    var tagName;
    var description;
    if (typeof tag === 'string') {
        tagName = tag.toLowerCase();
        description = descriptor;
    }
    else {
        tagName = tag.tag;
        description = tag.description;
    }
    if (loggerMap.hasOwnProperty(tagName) && loggerMap[tagName]) {
        return loggerMap[tagName];
    }
    var logger = new debug_logger_1.DebugLogger(tagName, description, _checkLog);
    logger.setLevel(_level);
    loggerMap[tagName] = logger;
    loggers.push(logger);
    return logger;
}
exports.forTag = forTag;
function remove(tag) {
    var tagName = tag.toLowerCase();
    if (!loggerMap.hasOwnProperty(tagName) || !loggerMap[tagName]) {
        return;
    }
    var logger = loggerMap[tagName];
    loggerMap[tagName] = null;
    var index = loggers.indexOf(logger);
    if (index !== -1) {
        loggers.splice(index, 1);
    }
    return;
}
exports.remove = remove;
//# sourceMappingURL=logging.js.map