"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.request = exports.isSupported = void 0;
var debug_tools_1 = require("@js-sdk/debug-tools/es5");
var allows_payload_1 = require("../../enums/allows_payload");
var status_code_1 = require("../../enums/status_code");
var headers_1 = require("./headers");
var response_1 = require("../response");
var debugLogger = debug_tools_1.logging.forTag('transport.http.fetch');
/**
 * An map of all responseType values that can be polyfilled in case the browser
 * does not support XHR2.
 */
var AllowedResponseTypes = {
    json: true,
    text: true,
    arraybuffer: true,
    blob: true,
};
function isSupported() {
    return typeof fetch === 'function';
}
exports.isSupported = isSupported;
function request(httpRequest) {
    if (!isSupported()) {
        return Promise.reject(new TypeError('Fetch is not supported'));
    }
    if (!httpRequest.url) {
        return Promise.reject(new TypeError('Request URL cannot be blank.'));
    }
    var method = httpRequest.method || 'GET';
    var _url = httpRequest.url;
    // Set body
    var sendParams = null;
    if (method in allows_payload_1.AllowsPayload && httpRequest.payload) {
        // The method can accept bodies, so we will send the payload using the
        // send() method.
        sendParams = httpRequest.payload;
    }
    else if (httpRequest.payload) {
        // The method does not allow a body, so we'll set the payload as a
        // query-string parameter.
        _url += "?" + httpRequest.payload;
    }
    if (httpRequest.options.responseType &&
        !(httpRequest.options.responseType in AllowedResponseTypes)) {
        return Promise.reject(new TypeError('Cannot set responseType: not supported in browser.'));
    }
    var fetchOptions = {
        mode: httpRequest.options.mode || 'cors',
        credentials: httpRequest.options.credentials || 'same-origin',
        redirect: httpRequest.options.redirect || 'follow',
        method: method,
    };
    // We add these options separately to the object because MS browsers seem to
    // error out if we give them "empty values".
    if (httpRequest.headers.count()) {
        fetchOptions.headers = httpRequest.headers.toJSON();
    }
    if (sendParams) {
        fetchOptions.body = sendParams;
    }
    var startTime = Date.now();
    return fetch(_url, fetchOptions)
        .then(function (resp) {
        var bodyPromise;
        if (httpRequest.options.ignoreResponseBody ||
            resp.status === status_code_1.StatusCode.NO_CONTENT) {
            bodyPromise = null;
        }
        else if (httpRequest.options.responseType === 'json') {
            bodyPromise = resp.json().catch(function (err) {
                debugLogger.warn('Could not parse response as JSON:', err);
                // The fetch API will throw an error if the body is not proper JSON.
                // However, to maintain compatibility with the original API, we want
                // to return null on the body if it's not proper JSON.
                return null;
            });
        }
        else if (httpRequest.options.responseType === 'arraybuffer') {
            bodyPromise = resp.arrayBuffer();
        }
        else if (httpRequest.options.responseType === 'blob') {
            bodyPromise = resp.blob();
        }
        else {
            bodyPromise = resp.text();
        }
        var responseHeaders = httpRequest.options.parseResponseHeaders || resp.status > 299
            ? new headers_1.FetchHeaders(resp.headers)
            : null;
        return Promise.all([resp.url, resp.status, responseHeaders, bodyPromise]);
    })
        .then(function (_a) {
        var respUrl = _a[0], status = _a[1], fetchHeaders = _a[2], body = _a[3];
        var response = new response_1.HTTPResponse(respUrl, status);
        response.body = body;
        response.headers = fetchHeaders;
        if (httpRequest.options.timing) {
            var duration = Date.now() - startTime;
            response.timing = { completed: duration };
        }
        return response;
    })
        .catch(function () {
        // Fetch does not provide really good errors..
        var response = new response_1.HTTPResponse(_url);
        if (httpRequest.options.timing) {
            var duration = Date.now() - startTime;
            response.timing = { completed: duration };
        }
        return response;
    })
        .then(function (response) {
        // Set the offline flag if available.
        if (httpRequest.options.connectionObserver) {
            response.offline = !httpRequest.options.connectionObserver.isOnline();
        }
        return response;
    });
}
exports.request = request;
//# sourceMappingURL=index.js.map