"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicTransport = void 0;
var tslib_1 = require("tslib");
var emitter_1 = require("@spotify-internal/emitter/es5");
var event_1 = require("../enums/event");
var status_code_1 = require("../enums/status_code");
var status_family_1 = require("../enums/status_family");
var PublicTransportEvent;
(function (PublicTransportEvent) {
    PublicTransportEvent["EVENT_ACCESS_TOKEN"] = "access_token";
    PublicTransportEvent["EVENT_CONNECTION_ID"] = "connection_id";
    PublicTransportEvent["EVENT_CONNECTION_OFFLINE"] = "connection_offline";
    PublicTransportEvent["EVENT_CONNECTION_ONLINE"] = "connection_online";
    PublicTransportEvent["EVENT_ENDPOINTS_RESOLVED"] = "endpoints_resolved";
})(PublicTransportEvent || (PublicTransportEvent = {}));
/**
 * A lightweight, fully encapsulated Transport-like object that exposes some of
 * the functionality of Transport without exporting the lifecycle methods.
 *
 * An important difference with a Transport instance is that the event types for
 * a PublicTransport instance are attached as properties of the instance itself.
 * Thus, Transport's `TransportEvent.CONNECTION_ID` corresponds to
 * PublicTransport's `publicTransport.EVENT_CONNECTION_ID` property.
 */
var PublicTransport = /** @class */ (function (_super) {
    tslib_1.__extends(PublicTransport, _super);
    /**
     * @param transport - The transport instance that will be wrapped.
     * @param publicTransportOptions - The options for this PublicTransport instance.
     */
    function PublicTransport(transport, publicTransportOptions) {
        var _this = _super.call(this) || this;
        /**
         * A constant for the access token event.
         */
        _this.EVENT_ACCESS_TOKEN = PublicTransportEvent.EVENT_ACCESS_TOKEN;
        /**
         * A constant for the connection id event.
         */
        _this.EVENT_CONNECTION_ID = PublicTransportEvent.EVENT_CONNECTION_ID;
        /**
         * A constant for the offline event.
         */
        _this.EVENT_CONNECTION_OFFLINE = PublicTransportEvent.EVENT_CONNECTION_OFFLINE;
        /**
         * A constant for the online event.
         */
        _this.EVENT_CONNECTION_ONLINE = PublicTransportEvent.EVENT_CONNECTION_ONLINE;
        /**
         * A constant for the endpoints resolved event.
         */
        _this.EVENT_ENDPOINTS_RESOLVED = PublicTransportEvent.EVENT_ENDPOINTS_RESOLVED;
        /**
         * A reference to the StatusCode enum.
         */
        _this.StatusCode = status_code_1.StatusCode;
        /**
         * A reference to the StatusFamily enum.
         */
        _this.StatusFamily = status_family_1.StatusFamily;
        _this.getConnectionId = transport.getConnectionId.bind(transport);
        _this.getEndpoints = transport.getEndpoints.bind(transport);
        _this.getInitTime = transport.getInitTime.bind(transport);
        _this.getLastToken = transport.getLastToken.bind(transport);
        _this.matchMessages = transport.matchMessages.bind(transport);
        _this.unmatchMessages = transport.unmatchMessages.bind(transport);
        _this.handlePushRequests = transport.handlePushRequests.bind(transport);
        _this.unhandlePushRequests = transport.unhandlePushRequests.bind(transport);
        _this.hasPlugin = transport.hasPlugin.bind(transport);
        _this.getPluginAPI = transport.getPluginAPI.bind(transport);
        var transportRequest = transport.request.bind(transport);
        if (publicTransportOptions === null || publicTransportOptions === void 0 ? void 0 : publicTransportOptions.requestOptions) {
            // This instance defines some default options, so we have to wrap request
            // to add some merging behaviour when necesssary.
            _this.request = function (uri, options) {
                if (!options) {
                    // There are no overrides, so just use the default options.
                    return transportRequest(uri, publicTransportOptions.requestOptions);
                }
                // Merge overrides with the default options.
                return transportRequest(uri, tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, publicTransportOptions === null || publicTransportOptions === void 0 ? void 0 : publicTransportOptions.requestOptions), options), { 
                    // then merge any options that are objects
                    metadata: tslib_1.__assign(tslib_1.__assign({}, publicTransportOptions.requestOptions.metadata), options === null || options === void 0 ? void 0 : options.metadata), retry: tslib_1.__assign(tslib_1.__assign({}, publicTransportOptions.requestOptions.retry), options === null || options === void 0 ? void 0 : options.retry) }));
            };
        }
        else {
            // There are no defaults, so we don't need to do any merging. We can use
            // the Transport instance's request method directly.
            _this.request = transportRequest;
        }
        _this.proxyEmit(transport, event_1.Event.ACCESS_TOKEN, PublicTransportEvent.EVENT_ACCESS_TOKEN);
        _this.proxyEmit(transport, event_1.Event.CONNECTION_OFFLINE, PublicTransportEvent.EVENT_CONNECTION_OFFLINE);
        _this.proxyEmit(transport, event_1.Event.CONNECTION_ONLINE, PublicTransportEvent.EVENT_CONNECTION_ONLINE);
        _this.proxyEmit(transport, event_1.Event.ENDPOINTS_RESOLVED, PublicTransportEvent.EVENT_ENDPOINTS_RESOLVED);
        // Handle the connection id event separately.
        _this.onAddListener(PublicTransportEvent.EVENT_CONNECTION_ID, _this._onAddConnectionIdListener.bind(_this, transport.on.bind(transport)));
        _this.onRemoveListener(PublicTransportEvent.EVENT_CONNECTION_ID, _this._onRemoveConnectionIdListener.bind(_this, transport.removeListener.bind(transport)));
        return _this;
    }
    /**
     * Called when we add a listener for `EVENT_CONNECTION_ID`.
     *
     * Because `TRANSPORT_CONNECTION_ID` is state-aware, we cannot proxy the
     * event, because proxies are only added once, whereas state-aware events
     * expect individual listeners.
     *
     * Note that this will explicitly cancel adding a listener to this
     * eventemitter instance.
     *
     * @param addListener - An `addListener` function that's bound to the origin
     *   transport instance.
     * @param ev - The add listener meta-event.
     */
    PublicTransport.prototype._onAddConnectionIdListener = function (addListener, ev) {
        var _this = this;
        // We do not want to add this as an actual listener, since we will never
        // actually fire this event from within public transport.
        ev.preventDefault();
        // We need to wrap the event so we can get a proper event name.
        var listener = ev.data.listener;
        var renamingWrapper = function (e) {
            var newEvent = _this.createEvent(PublicTransportEvent.EVENT_CONNECTION_ID, e.data);
            listener.call(_this, newEvent);
        };
        listener.$proxy_wrapper = renamingWrapper;
        addListener(event_1.Event.CONNECTION_ID, renamingWrapper, ev.data.options);
    };
    /**
     * Called when we remove a listener for `EVENT_CONNECTION_ID`.
     *
     * @param removeListener - A `removeListener` function that's bound to the
     *   origin transport instance.
     * @param ev - The remove listener meta-event.
     */
    PublicTransport.prototype._onRemoveConnectionIdListener = function (removeListener, ev) {
        ev.preventDefault();
        var listener = ev.data.listener;
        if (!listener.$proxy_wrapper) {
            return;
        }
        removeListener(event_1.Event.CONNECTION_ID, listener.$proxy_wrapper, ev.data.options);
    };
    /**
     * Remove all event listeners from the instance.
     *
     * NOTE: This is a NO-OP function. As a `PublicTransport` instance can be used
     * and pass across multiple libraries and packages, exposing this method can
     * lead to hard to detect bugs. We therefore override this method explicitly
     * and disable the behaviour.
     *
     * @returns The `PublicTransport` instance.
     */
    PublicTransport.prototype.removeAllListeners = function () {
        return this;
    };
    return PublicTransport;
}(emitter_1.EventEmitter));
exports.PublicTransport = PublicTransport;
//# sourceMappingURL=public_transport.js.map