"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dealer = void 0;
var tslib_1 = require("tslib");
var emitter_1 = require("@spotify-internal/emitter/es5");
var promise_resolver_1 = require("@js-sdk/common/es5/promise_resolver");
var typedefs_1 = require("./typedefs");
var internal_socket_code_1 = require("../../enums/internal_socket_code");
var error_1 = require("./error");
var event_1 = require("./event");
var NOOP = function () { };
/**
 * Used to match the connection id from the Pusher URL returned by dealer.
 */
var CONNECTION_ID_EXP = /hm:\/\/pusher\/(?:[^]+)?\/connections\/([^]+)/;
/**
 * The amount of time in between heartbeats.
 */
var HEARTBEAT_INTERVAL = 30000;
/**
 * The amount of time to wait before triggering a heartbeat timeout.
 */
var HEARTBEAT_TIMEOUT = 10000;
var hasWindow = typeof window !== 'undefined';
/**
 * Interfaces with the Dealer messaging service.
 *
 * @param options - The options for this dealer instance.
 * @see https://ghe.spotify.net/messaging/dealer
 */
var Dealer = /** @class */ (function (_super) {
    tslib_1.__extends(Dealer, _super);
    function Dealer(options) {
        var _this_1 = _super.call(this) || this;
        /**
         * A reference to the internal WebSocket connection to Dealer.
         */
        _this_1._socket = null;
        /**
         * A deferred that is created in response to a request to ping the service.
         */
        _this_1._lastPingDeferred = null;
        /**
         * A boolean flag that indicates whether we're waiting for a Connection Id.
         *
         * When set to true, the next "connection id" message will result in a similar event.
         */
        _this_1._waitingForConnectionId = true;
        /**
         * The string connection id for the Dealer connection.
         */
        _this_1._connectionId = null;
        /**
         * The string connection id uri for the Dealer connection.
         */
        _this_1._connectionURI = null;
        /**
         * The setTimeout token used for the heartbeat.
         */
        _this_1._heartbeatToken = 0;
        /**
         * The setTimeout token used for timing-out the heartbeat.
         */
        _this_1._heartbeatTimeoutToken = 0;
        _this_1._connected = false;
        _this_1._endpoint = null;
        _this_1._WebSocket = options.WebSocket || WebSocket;
        _this_1._heartbeatTimeout = options.heartbeatTimeout || HEARTBEAT_TIMEOUT;
        return _this_1;
    }
    /**
     * Creates a new Dealer instance.
     *
     * @param options - The options for this dealer instance.
     * @returns The new Dealer instance.
     */
    Dealer.create = function (options) {
        return new Dealer(options);
    };
    Dealer.prototype._startHeartbeat = function (initial) {
        var _this_1 = this;
        var heartbeat = function () {
            _this_1.ping().then(function () { return _this_1._onHeartbeatSuccess(); }, function () { return _this_1._onHeartbeatError(); });
            _this_1._heartbeatTimeoutToken = setTimeout(function () { return _this_1._onHeartbeatError(); }, _this_1._heartbeatTimeout);
        };
        if (initial) {
            heartbeat();
        }
        else {
            this._heartbeatToken = setTimeout(function () { return heartbeat(); }, HEARTBEAT_INTERVAL);
        }
    };
    Dealer.prototype._onHeartbeatError = function () {
        this._stopHeartbeat();
        if (!this._socket) {
            return;
        }
        this._socket.close(internal_socket_code_1.InternalSocketCode.TIMEOUT, 'internal-timeout');
    };
    Dealer.prototype._onHeartbeatSuccess = function () {
        this._stopHeartbeat();
        this._startHeartbeat();
    };
    Dealer.prototype._stopHeartbeat = function () {
        // Note, we cast both properties as NodeJS.Timeout values, event though this
        // is not really NodeJS specific. This is to simply get around the fact
        // that we're using the NodeJS types within this file.
        if (this._heartbeatToken !== null) {
            clearTimeout(this._heartbeatToken);
        }
        if (this._heartbeatTimeoutToken !== null) {
            clearTimeout(this._heartbeatTimeoutToken);
        }
    };
    /**
     * Parses a "connection id message" from Dealer.
     *
     * @param message - The message to parse.
     * @returns True if the message was successfully parsed, false otherwise.
     */
    Dealer.prototype._prepareConnectionId = function (message) {
        var _a;
        if (!message.uri) {
            return false;
        }
        var _b = (_a = message.uri.match(CONNECTION_ID_EXP)) !== null && _a !== void 0 ? _a : [], connectionId = _b[1];
        if (!connectionId) {
            return false;
        }
        var id;
        if (message.headers && message.headers['Spotify-Connection-Id']) {
            // Header in ID is not URI encoded.
            id = message.headers['Spotify-Connection-Id'];
        }
        else {
            id = decodeURIComponent(connectionId);
        }
        this._connectionId = id;
        this._connectionURI = message.uri;
        this.emit(event_1.DealerEvent.CONNECTION_ID, { id: id, uri: message.uri });
        return true;
    };
    Dealer.prototype._reply = function (key, payload) {
        if (!key) {
            throw new TypeError('Invalid key.');
        }
        var socket = this._socket;
        if (!socket || socket.readyState !== 1) {
            return;
        }
        var msg = {
            type: 'reply',
            key: key,
            payload: payload,
        };
        socket.send(JSON.stringify(msg));
    };
    /**
     * Parses the actual message body from the internal WebSocket.
     *
     * @param data - A JSON-encoded string that contains the actual message data.
     */
    Dealer.prototype._parseMessage = function (data) {
        var msg;
        try {
            msg = JSON.parse(data);
        }
        catch (_a) {
            return;
        }
        if (msg.type === 'message') {
            if (this._waitingForConnectionId && this._prepareConnectionId(msg)) {
                this._waitingForConnectionId = false;
                this._startHeartbeat(true);
            }
            else {
                this.emit(event_1.DealerEvent.MESSAGE, { message: msg });
            }
        }
        else if (msg.type === 'pong' && this._lastPingDeferred) {
            this._lastPingDeferred.resolve(true);
            this._lastPingDeferred = null;
        }
        else if (msg.type === 'request') {
            var key = msg.key;
            if (key) {
                this.emit(event_1.DealerEvent.REQUEST, {
                    request: msg,
                    reply: this._reply.bind(this, key),
                });
            }
        }
    };
    /**
     * Handles the "open" event from the internal WebSocket.
     *
     * @param deferred - The deferred object that was created as part of the part
     *   of the authentication process.
     */
    Dealer.prototype._handleOpen = function (deferred) {
        deferred.resolve(true);
        this._connected = true;
        this.emit(event_1.DealerEvent.AUTHENTICATED, null);
    };
    /**
     * Handles a "message" from the internal WebSocket.
     *
     * @param ev - The "message" event.
     */
    Dealer.prototype._handleMessage = function (ev) {
        var _this = this;
        var data = ev.data;
        if (hasWindow && window.Blob && data instanceof window.Blob) {
            var fileReader = new FileReader();
            fileReader.onloadend = function () {
                if (!this.result) {
                    return;
                }
                var result;
                if (this.result instanceof ArrayBuffer) {
                    result = '';
                    var temp = new Uint8Array(this.result);
                    for (var i = 0; i < temp.length; i++) {
                        result += String.fromCharCode(temp[i]);
                    }
                }
                else {
                    result = this.result;
                }
                _this._parseMessage(result);
            };
            fileReader.readAsText(data);
        }
        else if (typeof Buffer !== 'undefined' &&
            typeof ArrayBuffer !== 'undefined' &&
            data instanceof ArrayBuffer) {
            this._parseMessage(new Buffer(data).toString('ascii'));
        }
        else {
            this._parseMessage(data);
        }
    };
    /**
     * Handles a "close" event from the internal WebSocket.
     *
     * @param ev - The "close" event.
     */
    Dealer.prototype._handleClose = function (ev) {
        var wasConnected = this._connected;
        this._connected = false;
        if (!wasConnected) {
            // We had an error with authentication
            var error = new error_1.DealerError(typedefs_1.DealerErrors.DEALER_AUTHENTICATION_FAILED, 'Dealer connection error', ev);
            this.emit(event_1.DealerEvent.AUTHENTICATION_FAILED, { error: error });
            return;
        }
        this.emitSync(event_1.DealerEvent.DISCONNECTED, {
            wsCode: ev.code,
            reason: ev.reason,
        });
    };
    /**
     * Handles the "error" event from the internal WebSocket.
     *
     * @param deferred - The deferred object that was created as part of the
     *   authentication process.
     */
    Dealer.prototype._handleError = function (deferred) {
        var error = new error_1.DealerError(typedefs_1.DealerErrors.DEALER_CONNECTION_ERROR, 'Cannot connect to dealer');
        deferred.reject(error);
        this._connected = false;
        this.emit(event_1.DealerEvent.ERROR, { error: error });
    };
    /**
     * Connects the instance to the Dealer service.
     *
     * @param endpoint - The endpoint to connect to.
     * @returns A promise that will be resolved to true if the connection was successful.
     */
    Dealer.prototype.connect = function (endpoint) {
        // Dealer expects the token to be either part of the UPGRADE request header or
        // as a query-string parameter. Since we cannot set headers in the browser, we
        // use the query-string option. Since the token is unknown at this point, we
        // simply save the endpoint and wait until `authenticate()` is called.
        this._endpoint = endpoint;
        this._waitingForConnectionId = true;
        this.emit(event_1.DealerEvent.CONNECTED, null);
        return Promise.resolve(true);
    };
    /**
     * Authenticates the instance to the Dealer service.
     *
     * @param token - The OAuth token that identifies the current user.
     * @returns A promise that will be resolved when the instance has been
     *   properly authenticated.
     */
    Dealer.prototype.authenticate = function (token) {
        var deferred = promise_resolver_1.createPromiseResolver();
        var endpoint = this._endpoint + "?access_token=" + token;
        var socket = (this._socket = new this._WebSocket(endpoint));
        socket.onopen = this._handleOpen.bind(this, deferred);
        socket.onclose = this._handleClose.bind(this);
        socket.onerror = this._handleError.bind(this, deferred);
        socket.onmessage = this._handleMessage.bind(this);
        return deferred.promise;
    };
    /**
     * Disconnects the instance from the Dealer service.
     */
    Dealer.prototype.disconnect = function () {
        if (!this._socket) {
            return;
        }
        this._stopHeartbeat();
        this._waitingForConnectionId = true;
        this._connected = false;
        this._socket.close(internal_socket_code_1.InternalSocketCode.CLOSE, 'internal-close');
        this._socket.onopen = NOOP;
        this._socket.onerror = NOOP;
        this._socket.onmessage = NOOP;
        this._socket.onclose = NOOP;
        this._socket = null;
        this.emitSync(event_1.DealerEvent.DISCONNECTED, {
            wsCode: internal_socket_code_1.InternalSocketCode.CLOSE,
            reason: 'internal-close',
        });
    };
    /**
     * Sends a ping message to the Dealer instance.
     *
     * @returns A promise that will be resolved when the Dealer service returns a
     *   "pong" response.
     */
    Dealer.prototype.ping = function () {
        if (!this._socket || this._socket.readyState !== 1) {
            return Promise.reject(new error_1.DealerError(typedefs_1.DealerErrors.DEALER_CONNECTION_ERROR, 'Dealer connection error'));
        }
        this._lastPingDeferred = promise_resolver_1.createPromiseResolver();
        this._socket.send('{"type":"ping"}');
        return this._lastPingDeferred.promise;
    };
    /**
     * Returns the Connection ID of the instance.
     *
     * @returns A promise that will be resolved with the instance's connection id.
     */
    Dealer.prototype.getConnectionId = function () {
        var _this_1 = this;
        if (this._waitingForConnectionId) {
            return new Promise(function (resolve) {
                _this_1.once(event_1.DealerEvent.CONNECTION_ID, function (e) {
                    resolve(e.data.id);
                });
            });
        }
        return Promise.resolve(this._connectionId);
    };
    /**
     * Returns an object with the connection id and the connection uri.
     *
     * @returns A promise that will be resolved with the instance's connection id
     *   and connection uri.
     */
    Dealer.prototype.getConnectionInfo = function () {
        var _this_1 = this;
        if (this._waitingForConnectionId) {
            return new Promise(function (resolve) {
                _this_1.once(event_1.DealerEvent.CONNECTION_ID, function (e) {
                    resolve({
                        id: e.data.id,
                        uri: e.data.uri,
                    });
                });
            });
        }
        return Promise.resolve({
            id: this._connectionId,
            uri: this._connectionURI,
        });
    };
    /**
     * Returns whether there's a connectionId.
     *
     * @returns True if the dealer instance has a connection id.
     */
    Dealer.prototype.hasConnectionId = function () {
        return !this._waitingForConnectionId && !!this._connectionId;
    };
    return Dealer;
}(emitter_1.EventEmitter));
exports.Dealer = Dealer;
//# sourceMappingURL=dealer.js.map