"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
var tslib_1 = require("tslib");
var backoff_1 = require("@js-sdk/backoff/es5");
var counter_1 = require("@js-sdk/backoff/es5/counter");
var debug_tools_1 = require("@js-sdk/debug-tools/es5");
var emitter_1 = require("@spotify-internal/emitter/es5");
var errors_1 = require("./enums/errors");
var event_1 = require("./enums/event");
var plugin_event_1 = require("./enums/plugin_event");
var internal_socket_code_1 = require("./enums/internal_socket_code");
var status_code_1 = require("./enums/status_code");
var status_family_1 = require("./enums/status_family");
var disconnection_reason_1 = require("./enums/disconnection_reason");
var transport_1 = require("./error/transport");
var connection_observer_1 = require("./_internal/connection_observer");
var response_1 = require("./http/response");
var request_1 = require("./http/request");
var public_transport_1 = require("./_internal/public_transport");
var operation_metrics_tracker_1 = require("./_internal/operation_metrics_tracker");
var debugLogger = debug_tools_1.logging.forTag('transport.transport');
/**
 * An expression for matching special URLs.
 *
 * @private
 * @constant
 */
var HTTP_SPECIAL_URL_EXP = /^(?:https?:\/\/)?@([^\/]+)\//;
/**
 * An expression to check whether a WebSocket or HTTP URI requires an ending slash.
 */
var ENDPOINT_REQUIRES_SLASH_EXP = /^(ws|http)s?:\/\/.*[^\/]$/;
/**
 * An expression to check whether if a string is a valid HTTP-date. accepted
 * format: Fri, 31 Dec 1999 23:59:59 GMT
 */
var HTTP_DATE_EXP = /^([a-zA-Z]{3},\ \d{1,2}\ [a-zA-Z]{3}\ (\d{1,2}.){3})/;
/**
 * Threshold that needs to be reached before a dealer reconnection attempt will be made.
 */
var RECONNECT_THRESHOLD = 5000;
/**
 * The default maximum retry value for a request
 */
var DEFAULT_RETRY_COUNT = 2;
/**
 * The matcher expression for the client logout message.
 */
var LOGOUT_MESSAGE_URI = 'client:logout';
/**
 * The default lifetime of an access token, in seconds.
 *
 * Note that the actual default lifetime of the token from Accounts is actually
 * 1 hour (3600 seconds), but we set the default token timeout to 59 minutes to
 * compensate for any transport costs from when the token was retrieved.
 */
var DEFAULT_TOKEN_TIMEOUT = 3540;
/**
 * A map of the request modes that are supported for Transport.
 */
var SupportedRequestModes = {
    xhr: true,
    fetch: true,
};
/**
 * A constant map of the flags that are used with the `_stateMask` bitmask in
 * order to determine the current state of the Transport instance.
 */
var StateFlag = {
    CONNECTED: 1 << 0,
    AUTHENTICATED: 1 << 2,
};
/**
 * A typeguard for PluginSocketAPI instances
 *
 * @param plugin - The plugin to check.
 * @returns True if the plugin is has a PluginSocketAPI instance.
 */
function hasPluginSocketAPI(plugin) {
    return 'getConnectionInfo' in plugin.api;
}
function appendAccessTokenQuery(url, token) {
    var tokenPart = "access_token=" + encodeURIComponent(token);
    var _a = url.split('?'), base = _a[0], query = _a[1];
    if (!query) {
        // If there's no query part, we can just append the token into the query
        // string.
        return base + "?" + tokenPart;
    }
    // An existing query string might already have the access_token parameter,
    // so we need to update that existing parameter. We're using a basic find and
    // replace here, so we don't have to decode and encode the query string in
    // two loops.
    var updatedQuery = query.replace(/access_token=[^&]*(&|$)/, tokenPart + "$1");
    if (updatedQuery !== query) {
        return base + "?" + updatedQuery;
    }
    // If nothing was updated, we should just append the token to the existing
    // query string.
    return base + "?" + tokenPart + "&" + query;
}
/**
 * Transport implements functionality for messaging and connectivity for Spotify
 * applications and libraries.
 */
var Transport = /** @class */ (function (_super) {
    tslib_1.__extends(Transport, _super);
    function Transport(options) {
        var _this = _super.call(this) || this;
        /**
         * A list of plugins
         */
        _this._plugins = {};
        /**
         * The mediator for plugins.
         */
        _this._pluginMediator = new emitter_1.EventEmitter();
        // Internal Flags and Objects
        /**
         * A flag that indicates whether connect() was called on this instance. Used
         * for determining whether we should reconnect.
         */
        _this._connectCalled = false;
        /**
         * A flag that indicates whether authenticate() was called on this instance.
         * Used for determining whether we should reauthenticate on reconnects.
         */
        _this._authenticateCalled = false;
        /**
         * The cached `Endpoints` from the `EndpointsProvider`.
         */
        _this._endpoints = null;
        /**
         * The cached OAuth token from the `TokenProvider`.
         */
        _this._lastToken = null;
        /**
         * The timestamp of the expiry of the cached OAuth token.
         */
        _this._lastTokenExpiry = 0;
        /**
         * A promise generated from the last call to `_refreshToken`.
         */
        _this._refreshTokenPromise = null;
        /**
         * A promise generated from the last call to `authenticate`.
         */
        _this._authenticationPromise = null;
        /**
         * A timeout token for the last reconnection.
         */
        _this._reconnectTimeout = 0;
        /**
         * A flag that indicates whether this instance is in the process of reconnecting.
         */
        _this._isReconnecting = false;
        /**
         * A timestamp of the last successful authentication for this instance.
         */
        _this._initTime = 0;
        /**
         * A timestamp of the last disconnection for this instance.
         */
        _this._lastDisconnect = 0;
        /**
         * A bitmask of the current states of this instance.
         */
        _this._stateMask = 0;
        /**
         * A counter for the number of "quick disconnections" for this instance.
         */
        _this._quickDisconnectCount = 0;
        /**
         * A BackoffCounter that is used to calculate the exponential backoff delay
         * for reconnections.
         */
        _this._counter = new counter_1.Counter({
            curve: 'exponential',
            baseTime: 5000,
            ceiling: 15000,
        });
        /**
         * A map of listeners for StateAware events.
         */
        _this._stateAwareListeners = {
            connected: [],
            authenticated: [],
            connection_id: [],
            transport_connect: [],
            transport_authenticate: [],
        };
        /**
         * A map of last OperationMetrics for StateAware events.
         */
        _this._stateAwareOperationMetrics = {
            authenticated: null,
        };
        /**
         * A map of runners for StateAware events.
         */
        _this._stateAwareRunners = {
            connected: null,
            authenticated: null,
            connection_id: null,
            transport_connect: null,
            transport_authenticate: null,
        };
        if (!options) {
            throw new TypeError('Argument `options` for Transport cannot be null.');
        }
        if (!options.providers) {
            throw new TypeError('Argument `options.providers` for Transport cannot be null.');
        }
        _this._ownerRef = 'ownerRef' in options ? Object(options.ownerRef) : {};
        _this._tokenProvider = options.providers.token;
        _this._endpointsProvider = options.providers.endpoints;
        _this._XHR = options.XHR;
        _this._Fetch = options.Fetch;
        _this._reconnectionRetries =
            options.reconnectionRetries >= 0
                ? options.reconnectionRetries
                : 3;
        _this._requestMode =
            options.requestMode in SupportedRequestModes
                ? options.requestMode
                : 'xhr';
        _this._forcePolyfillTypes = options.forcePolyfillTypes || {};
        _this._disableAutoLogout =
            'disableAutoLogout' in options ? !!options.disableAutoLogout : false;
        _this._disconnectBeforeUnload = options.disconnectBeforeUnload || false;
        // Preinit Items
        _this._connectionObserver = new connection_observer_1.ConnectionObserver({
            notifyBeforeUnload: _this._disconnectBeforeUnload,
        });
        // Bound methods
        _this.authenticate = _this.authenticate.bind(_this);
        _this._authenticateWithToken = _this._authenticateWithToken.bind(_this);
        _this._connectToEndpoints = _this._connectToEndpoints.bind(_this);
        _this._parseProvidedToken = _this._parseProvidedToken.bind(_this);
        // Bound Event Listeners
        _this._onConnected = _this._onConnected.bind(_this);
        _this._onAuthenticated = _this._onAuthenticated.bind(_this);
        _this._onAuthenticationFailed = _this._onAuthenticationFailed.bind(_this);
        _this._init();
        return _this;
    }
    /**
     * Creates a new Transport instance.
     *
     * @param options - The options for this Transport instance.
     * @returns A new Transport instance.
     */
    Transport.create = function (options) {
        return new Transport(options);
    };
    /**
     * Initializes listeners for this transport instance.
     */
    Transport.prototype._init = function () {
        var _a;
        var _this = this;
        // State Aware Events
        this.onAddListener(event_1.Event.CONNECTED, this._onAddListener.bind(this, 'connected'));
        this.onAddListener(event_1.Event.AUTHENTICATED, this._onAddListener.bind(this, 'authenticated'));
        this.onAddListener(event_1.Event.CONNECTION_ID, this._onAddListener.bind(this, 'connection_id'));
        this.onRemoveListener(event_1.Event.CONNECTED, this._onRemoveListener.bind(this, 'connected'));
        this.onRemoveListener(event_1.Event.AUTHENTICATED, this._onRemoveListener.bind(this, 'authenticated'));
        this.onRemoveListener(event_1.Event.CONNECTION_ID, this._onRemoveListener.bind(this, 'connection_id'));
        // State Aware Plugin Events
        this._pluginMediator.onAddListener(plugin_event_1.PluginEvent.TRANSPORT_CONNECT, this._onAddListener.bind(this, 'transport_connect'));
        this._pluginMediator.onAddListener(plugin_event_1.PluginEvent.TRANSPORT_AUTHENTICATE, this._onAddListener.bind(this, 'transport_authenticate'));
        this._pluginMediator.onRemoveListener(plugin_event_1.PluginEvent.TRANSPORT_CONNECT, this._onRemoveListener.bind(this, 'transport_connect'));
        this._pluginMediator.onRemoveListener(plugin_event_1.PluginEvent.TRANSPORT_AUTHENTICATE, this._onRemoveListener.bind(this, 'transport_authenticate'));
        if (this._requestMode === 'fetch' &&
            (!this._Fetch || !this._Fetch.isSupported())) {
            debugLogger.warn('Default "fetch" request mode unavailable; Fallback to "xhr"');
            this._requestMode = 'xhr';
        }
        var pluginMediator = this._pluginMediator;
        pluginMediator.addListeners((_a = {},
            _a[plugin_event_1.PluginEvent.PLUGIN_DISCONNECTED] = this._onPluginDisconnected.bind(this),
            _a));
        this.proxyEmit(pluginMediator, plugin_event_1.PluginEvent.PLUGIN_CONNECTION_INFO, event_1.Event.CONNECTION_ID);
        if (!this._disableAutoLogout) {
            this.matchMessages(LOGOUT_MESSAGE_URI, function () { return _this._onLogout(); });
        }
        this._connectionObserver.on(event_1.Event.CONNECTION_ONLINE, function () {
            return _this._onOnline();
        });
        this._connectionObserver.on(event_1.Event.CONNECTION_OFFLINE, function () {
            return _this._onOffline();
        });
        this._connectionObserver.on(event_1.Event.WINDOW_BEFORE_UNLOAD, function () {
            return _this._disconnect(disconnection_reason_1.DisconnectionReason.WINDOW_BEFORE_UNLOAD);
        });
    };
    /**
     * Runs queued state aware listeners.
     *
     * @param type - The type of queued listeners to run.
     * @param event - The event to pass to the queued listeners.
     */
    Transport.prototype._runStateAwareQueues = function (type, event) {
        var listeners = this._stateAwareListeners[type].splice(0);
        for (var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++) {
            var listener = listeners_1[_i];
            listener.call(this, event);
        }
        this._stateAwareRunners[type] = null;
    };
    /**
     * Connects the Transport instance to the various messaging endpoints.
     *
     * @returns A promise that will be resolved to true if the connection was
     *   performed, or false otherwise (such as when it's already connected).
     */
    Transport.prototype._connect = function () {
        var _this = this;
        if (!!(this._stateMask & StateFlag.CONNECTED)) {
            // Already connected.
            return Promise.resolve(false);
        }
        if (this._connectionObserver.isOnline()) {
            return this._performConnect();
        }
        return new Promise(function (resolve, reject) {
            _this._connectionObserver.once(event_1.Event.CONNECTION_ONLINE, function () {
                _this._performConnect().then(resolve, reject);
            });
        });
    };
    /**
     * Starts the connection process for the transport instance.
     *
     * @returns A promise that will be resolved to true if the connection was
     *   performed, or false otherwise (such as when it's already connected).
     */
    Transport.prototype._performConnect = function () {
        var _this = this;
        return new Promise(function (resolve) {
            resolve(_this._endpointsProvider(_this.toPublic()));
        })
            .catch(function (maybeError) {
            if (!maybeError || maybeError.code) {
                return Promise.reject(maybeError);
            }
            return Promise.reject(new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_ENDPOINTS_PROVIDER_ERROR, maybeError.message || 'Endpoints provider error', maybeError));
        })
            .then(this._connectToEndpoints)
            .then(this._onConnected)
            .catch(function (e) {
            var realError = e && e.error ? e.error : e;
            _this.emit(event_1.Event.CONNECTION_FAILED, { error: realError });
            return Promise.reject(realError);
        });
    };
    /**
     * Connects to a given set of `Endpoints`.
     *
     * @param endpoints - The endpoints to connect to.
     * @returns A promise that will be resolved to true if the connection was
     *   performed, or false otherwise (such as when it's already connected).
     */
    Transport.prototype._connectToEndpoints = function (endpoints) {
        var _this = this;
        var processedEndpoints = { webgate: '', webapi: '' };
        // Ensure that the endpoints end in a slash, in case they do not.
        for (var name_1 in endpoints) {
            if (!endpoints.hasOwnProperty(name_1)) {
                continue;
            }
            var endpoint = endpoints[name_1];
            if (!endpoint) {
                continue;
            }
            if (ENDPOINT_REQUIRES_SLASH_EXP.test(endpoint)) {
                endpoint += '/';
            }
            processedEndpoints[name_1] = endpoint;
        }
        this._endpoints = processedEndpoints;
        this.emit(event_1.Event.ENDPOINTS_RESOLVED, {
            // Clone the endpoint so that listeners don't accidentally change it.
            endpoints: tslib_1.__assign({}, processedEndpoints),
        });
        var awaiting = [];
        var awaitPromise = function (connectionPromise) {
            awaiting.push(connectionPromise);
        };
        return new Promise(function (resolve, reject) {
            _this._pluginMediator.emitAndWait(plugin_event_1.PluginEvent.TRANSPORT_CONNECT, { endpoints: tslib_1.__assign({}, processedEndpoints), awaitPromise: awaitPromise }, function () {
                Promise.all(awaiting).then(function () { return resolve(true); }, reject);
            });
        });
    };
    /**
     * Retrieves an access token.
     *
     * This method calls the provided token provider to retrieve an access token.
     * This token will then be cached and returned for subsequent calls until it expires.
     *
     * Note that you can use the optional `ignoreCached` argument to force the
     * function to retrieve a new token.
     *
     * @param ignoreCached - Forces the method to retrieve a new token from the
     *   token provider if set to true.
     * @returns The new token.
     */
    Transport.prototype._refreshToken = function (ignoreCached) {
        var _this = this;
        if (ignoreCached === void 0) { ignoreCached = false; }
        if (this._refreshTokenPromise) {
            // There's already a pending token refreshing operation, so we just
            // return the promise from the previous one.
            return this._refreshTokenPromise;
        }
        if (!ignoreCached &&
            this._lastToken &&
            this._lastTokenExpiry > Date.now()) {
            // The last access token is still valid, so just return that.
            return Promise.resolve(this._lastToken);
        }
        this._refreshTokenPromise = new Promise(function (resolve) {
            resolve(_this._tokenProvider());
        }).then(this._parseProvidedToken);
        // We need to clear the `_refreshTokenPromise` variable after fetching a
        // token, regardless of whether the token provider succeeded or not.
        var clearPromise = function () {
            _this._refreshTokenPromise = null;
        };
        this._refreshTokenPromise.then(clearPromise, clearPromise);
        return this._refreshTokenPromise.catch(function (maybeError) {
            var error = (maybeError === null || maybeError === void 0 ? void 0 : maybeError.code)
                ? maybeError
                : new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_TOKEN_PROVIDER_ERROR, (maybeError === null || maybeError === void 0 ? void 0 : maybeError.message) || 'Token provider error', maybeError);
            _this.emit(event_1.Event.TOKEN_PROVIDER_ERROR, { error: error });
            return Promise.reject(error);
        });
    };
    /**
     * Parses the token returned by the `provider.token` function that was passed
     * to the Transport instance when it was initialized.
     *
     * @param maybeToken - Either a string OAuth token, or an array containing a
     *   string OAuth token and a number signifying the token's lifetime in seconds.
     * @returns The OAuth token from the provider.
     * @throws {TypeError} Will throw if it received an empty token (i.e, a falsy value).
     */
    Transport.prototype._parseProvidedToken = function (maybeToken) {
        var token;
        var tokenTTL;
        if (Array.isArray(maybeToken)) {
            token = maybeToken[0];
            tokenTTL = parseInt(maybeToken[1], 10);
            if (isNaN(tokenTTL)) {
                tokenTTL = DEFAULT_TOKEN_TIMEOUT;
            }
        }
        else {
            token = maybeToken;
            tokenTTL = DEFAULT_TOKEN_TIMEOUT;
        }
        if (!token) {
            this._lastToken = null;
            this._lastTokenExpiry = 0;
            debugLogger.error('No token was provided');
            throw new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_INVALID_TOKEN, "Token provider returned an invalid token, \"" + token + "\"");
        }
        if (this._lastToken === token) {
            debugLogger.error('TokenProvider returned same token twice.');
            var error = new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_STALE_TOKEN, 'Token provider returned the same token twice.');
            this._lastToken = null;
            this._lastTokenExpiry = 0;
            throw error;
        }
        this._lastToken = token;
        this._lastTokenExpiry = Date.now() + tokenTTL * 1000;
        this.emit(event_1.Event.ACCESS_TOKEN, { token: token });
        return token;
    };
    /**
     * Authenticates the current Transport instance with the provided token.
     *
     * @param token - The OAuth token that will be used for authentication.
     * @returns A promise that will be resolved once the authentication flow has
     *   been completed.
     */
    Transport.prototype._authenticateWithToken = function (token) {
        var _this = this;
        if (!this._endpoints) {
            // FIXME: This should be an error.
            return Promise.resolve(true);
        }
        var awaiting = [];
        var awaitPromise = function (connectionPromise) {
            awaiting.push(connectionPromise);
        };
        return new Promise(function (resolve, reject) {
            _this._pluginMediator.emitAndWait(plugin_event_1.PluginEvent.TRANSPORT_AUTHENTICATE, { token: token, awaitPromise: awaitPromise }, function () {
                Promise.all(awaiting).then(function () { return resolve(true); }, reject);
            });
        });
    };
    /**
     * Authenticates a Transport instance to the messaging endpoints.
     *
     * Internally, this will trigger Transport to call the `TokenProvider` to to
     * get an OAuth token that will be used for authentication.
     *
     * @param ignoreCachedToken - When set to true, force a refresh of the OAuth
     *   token by calling the `TokenProvider`.
     * @returns A promise that will be resolved once the instance has benn
     *   authenticated, or rejected with any errors related to authentication.
     */
    Transport.prototype._authenticate = function (ignoreCachedToken) {
        var _this = this;
        if (!(this._stateMask & StateFlag.CONNECTED)) {
            return Promise.reject(new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_INVALID_STATE, 'Cannot authenticate disconnected transport.'));
        }
        if (this._authenticationPromise) {
            return this._authenticationPromise;
        }
        var operationMetrics = operation_metrics_tracker_1.OperationMetricsTracker.create();
        operationMetrics.start();
        this._authenticationPromise = backoff_1.Backoff.init(function () {
            return _this._refreshToken(ignoreCachedToken).then(_this._authenticateWithToken);
        }, { curve: 'exponential', maxRetries: 2, baseTime: 500 })
            .then(function () { return _this._onAuthenticated(operationMetrics); })
            .catch(function (err) { return _this._onAuthenticationFailed(err, operationMetrics); });
        return this._authenticationPromise;
    };
    /**
     * Disconnects the Transport instance.
     *
     * @param reason - The disconnection reason. Without this value, the
     *   `Event.TRANSPORT_DISCONNECTED` event will not be emitted as part of this
     *   function. This is necessary for operations where we internally disconnect
     *   the Transport instance without having to inform the user of the
     *   disconnection (such as when reconnecting).
     * @returns True if the disconnection was successful.
     */
    Transport.prototype._performDisconnect = function (reason) {
        this._stateMask = 0;
        var suppressEvent = !reason;
        if (reason) {
            this.emit(event_1.Event.DISCONNECTED, { reason: reason });
        }
        this._pluginMediator.emitSync(plugin_event_1.PluginEvent.TRANSPORT_DISCONNECT, {
            supressed: suppressEvent,
        });
        return true;
    };
    /**
     * Creates a function that will be used to reconnect the current instance
     * after an apparent disconnection.
     *
     * @returns A function that can be used to trigger reconnection.
     */
    Transport.prototype._createReconnector = function () {
        var _this = this;
        // We start with trying to reconnect with the cached token if it's still
        // valid. If the authentication results in an error, we will force refresh
        // the token in subsequent retries.
        var ignoreCachedToken = false;
        return function () {
            _this._isReconnecting = true;
            _this.emit(event_1.Event.RECONNECTING, null);
            _this._performDisconnect();
            return _this._connect()
                .then(function () {
                if (!_this._authenticateCalled) {
                    // The instance was never authenticated, so we skip authentication
                    // during reconnect.
                    return false;
                }
                return _this._authenticate(ignoreCachedToken).then(function (result) {
                    // Authorization was successful, make sure to use the cached
                    // token in the next reconnection.
                    ignoreCachedToken = false;
                    return result;
                }, function (error) {
                    // Authorization was not successful, force token refresh on next
                    // reconnect
                    ignoreCachedToken = true;
                    return Promise.reject(error);
                });
            })
                .then(function () {
                _this._isReconnecting = false;
                _this.emit(event_1.Event.RECONNECTED, null);
                return true;
            });
        };
    };
    /**
     * Called when Transport detects that it has been disconnected due to a bad
     * network connection.
     */
    Transport.prototype._tryToReconnect = function () {
        var _this = this;
        if (this._isReconnecting) {
            // Already reconnecting, ignore call.
            return;
        }
        this._stateMask = 0;
        backoff_1.Backoff.init(this._createReconnector(), {
            baseTime: 1000,
            maxTime: 15000,
            maxRetries: this._reconnectionRetries,
        }).catch(function () {
            _this._stateMask = 0;
            _this._isReconnecting = false;
            _this.emit(event_1.Event.DISCONNECTED, {
                reason: disconnection_reason_1.DisconnectionReason.RECONNECTION_FAILED,
            });
        });
    };
    /**
     * Sends a request.
     *
     * @param uri - The URI to request.
     * @param args - The arguments for the request.
     * @param context - The request context.
     * @returns The response for the request.
     */
    Transport.prototype._sendRequest = function (uri, args, context) {
        var _this = this;
        if (args === void 0) { args = {}; }
        if (context === void 0) { context = {}; }
        return this._processRequestArgs(uri, args).then(function (parsed) {
            if (parsed.options.forget) {
                return _this._sendFireAndForgetRequest(parsed);
            }
            return _this._sendRetriedRequest(parsed, context);
        });
    };
    /**
     * Takes the arguments to `Transport#request` and processes them, modifying
     * certain options to ensure that they are correct.
     *
     * @param uri - The URI of the request.
     * @param args - The arguments to the request.
     * @returns The parsed request arguments.
     */
    Transport.prototype._processRequestArgs = function (uri, args) {
        var _a;
        if (args === void 0) { args = {}; }
        var url = uri;
        var urlExpanded = false;
        var requestArgs = tslib_1.__assign(tslib_1.__assign({}, args), { forcePolyfill: !!(args.responseType && args.responseType in this._forcePolyfillTypes), requestMode: (_a = args === null || args === void 0 ? void 0 : args.requestMode) !== null && _a !== void 0 ? _a : this._requestMode, connectionObserver: this._connectionObserver, metadata: (args === null || args === void 0 ? void 0 : args.metadata) || null });
        if (HTTP_SPECIAL_URL_EXP.test(url)) {
            urlExpanded = true;
            try {
                // This will throw if the special URL key is invalid.
                url = this._tryExpandSpecialURL(url);
            }
            catch (e) {
                return Promise.reject(e);
            }
            // By default we want to authorize any special URLs, but if the caller has
            // explicitly set the `authorize` option, we should respect that.
            if (!('authorize' in requestArgs)) {
                requestArgs.authorize = true;
                requestArgs.autoAuthorized = true;
            }
        }
        var retryOptions = tslib_1.__assign({ maxRetries: DEFAULT_RETRY_COUNT, curve: 'exponential' }, args.retry);
        return Promise.resolve(request_1.HTTPRequest.create(url, {
            method: args.method,
            headers: args.headers,
            payload: args.payload,
            options: requestArgs,
            urlExpanded: urlExpanded,
            retryOptions: retryOptions,
        }));
    };
    /**
     * Expands a "special URL" in the form `@<endpoint>` to its full path, based
     * on the values defined in the Endpoints from the EndpointsProvider.
     *
     * @param url - The URL to expand.
     * @returns The expanded URL string.
     * @throws {TypeError} If the endpoint name is not provided by the endpoints provider.
     */
    Transport.prototype._tryExpandSpecialURL = function (url) {
        var endpoints = this._endpoints;
        return url.replace(HTTP_SPECIAL_URL_EXP, function (_, key) {
            if (!endpoints.hasOwnProperty(key)) {
                throw new TypeError("Cannot replace endpoint @" + key + ": endpoint not defined.");
            }
            return endpoints[key];
        });
    };
    /**
     * Sends a GET or POST request to a URL, ignoring the response.
     *
     * @privateRemarks
     * This function will use the following strategies for a GET request, in order:
     *
     * - `fetch` if available.
     * - `Image` element, via `src`.
     * - Normal `transport.request`
     *
     * The `fetch` and `Image` strategies are done directly inside the function.
     *
     * For POST requests, the function will use the following strategies:
     *
     * - `navigator.sendBeacon` if available.
     * - `fetch` if available
     * - Normal `transport.request`
     *
     * @param request - The HTTP Request.
     * @returns The `HTTPResponse` object containing the URL and a status of 0.
     */
    Transport.prototype._sendFireAndForgetRequest = function (request) {
        var url = request.url, method = request.method, options = request.options;
        if (method !== 'GET' && method !== 'POST') {
            return Promise.reject(new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_UNSUPPORTED_OPTION, "Option 'forget' cannot be used for " + method + " request."));
        }
        // autoAuthorized will only be set to `true` if `transport` itself set the
        // authorization field. We therefore only want to throw an error if the
        // user itself asked for authorization for the request.
        if (!options.autoAuthorized && options.authorize) {
            return Promise.reject(new transport_1.TransportError(errors_1.TransportErrors.TRANSPORT_UNSUPPORTED_OPTION, "Option 'forget' cannot be used for authorized request."));
        }
        // We change the parsed options here in case we need to send them via
        // _sendRetried request. These changes shouldn't affect the non-transport
        // related strategies.
        options.requestMode = 'xhr';
        options.authorize = false;
        options.ignoreResponseBody = true;
        if (method === 'GET') {
            if (typeof fetch === 'function') {
                fetch(url, { mode: 'no-cors' }).catch(function () {
                    // Ignore any errors related to the request.
                });
            }
            else if (typeof Image === 'function') {
                new Image().src = url;
            }
            else {
                this._sendRetriedRequest(request, {}).catch(function () { });
            }
        }
        else if (method === 'POST') {
            if (typeof navigator !== 'undefined' && (navigator === null || navigator === void 0 ? void 0 : navigator.sendBeacon)) {
                navigator.sendBeacon(request.url, request.payload);
            }
            else if (typeof fetch === 'function') {
                fetch(url, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: request.payload,
                }).catch(function () { });
            }
            else {
                this._sendRetriedRequest(request, {}).catch(function () { });
            }
        }
        return Promise.resolve(new response_1.HTTPResponse(url, 0));
    };
    /**
     * Sends the request and retries it until it succeeds or until it runs out of retries.
     *
     * Internally, this method also sets the authorization header when necessary.
     *
     * @param httpRequest - The parsed arguments for this request.
     * @param context - The request context.
     * @returns A promise that will be resolved with the HTTPResponse object.
     */
    Transport.prototype._sendRetriedRequest = function (httpRequest, context) {
        var _this = this;
        var backoffStrategy = httpRequest.retryOptions;
        // This is a static flag that we will use to check whether we need to update
        // the token. We keep it here so that the `requestFn` closure will have
        // access to it in between invocations.
        var ignoreCachedToken = false;
        // This function will be called in the lifetime of the request to set the
        // request's Authorization header every time that we detect that the token
        // has expired.
        var updateToken = function () {
            return _this._setAuthHeader(httpRequest, ignoreCachedToken);
        };
        var connectionObserver = this._connectionObserver;
        // This is the function that we will use together with the Backoff module to
        // retry the request if it fails.
        var requestFn = function () {
            var updateTokenPromise;
            if (connectionObserver.isOnline()) {
                updateTokenPromise = updateToken();
            }
            else {
                // The browser is not online, so we might have to wait until until the
                // browser is online to send this.
                updateTokenPromise = new Promise(function (resolve, reject) {
                    if (httpRequest.options.allowOffline) {
                        // The caller has explicitly set that this request should go through
                        // even if the browser is offline, so we just set it with the old
                        // token.
                        updateToken().then(resolve, reject);
                        return;
                    }
                    connectionObserver.once(event_1.Event.CONNECTION_ONLINE, function () {
                        updateToken().then(resolve, reject);
                    });
                });
            }
            return updateTokenPromise
                .then(function () {
                // Choose a request strategy based on the `requestMode` and based on
                // the availability of `Fetch`.
                var requestPromise;
                _this._pluginMediator.emitSync(plugin_event_1.PluginEvent.TRANSPORT_BEFORE_SEND_REQUEST, {
                    request: httpRequest,
                    context: context,
                });
                if (httpRequest.options.requestMode === 'fetch' &&
                    _this._Fetch &&
                    _this._Fetch.isSupported()) {
                    requestPromise = _this._Fetch.request(httpRequest);
                }
                else if (_this._XHR) {
                    requestPromise = _this._XHR.request(httpRequest);
                }
                else {
                    throw new Error('No available request mechanisms.');
                }
                return requestPromise;
            })
                .then(function (resp) {
                var retryAfterHeader = null;
                if (resp.headers) {
                    retryAfterHeader = resp.headers.get('Retry-After');
                }
                // Check the retry conditions and see whether we need to retry.
                // Rejecting the promise there will trigger `Backoff` to rerun the
                // `requestFn`.
                if (resp.status === status_code_1.StatusCode.UNAUTHORIZED &&
                    !httpRequest.options.ignoreUnauthorized) {
                    // We need to retry because we got a 401, which means that the token
                    // is probably expired. We need to set `ignoreCachedToken` to true
                    // so that the next invocation of `requestFn` (and `updateToken`)
                    // will trigger a refresh of the token.
                    ignoreCachedToken = true;
                    return Promise.reject(resp);
                }
                else if (typeof (backoffStrategy === null || backoffStrategy === void 0 ? void 0 : backoffStrategy.condition) === 'function' &&
                    (backoffStrategy.condition(resp, status_family_1.StatusFamily) || retryAfterHeader)) {
                    // This delay can either be an integer representing the number of
                    // seconds, or as a datestring.
                    // Two examples of its use are:
                    //
                    //      Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
                    //      Retry-After: 120
                    //
                    //          In the latter example, the delay is 2 minutes.
                    if (retryAfterHeader !== null) {
                        var delay = parseInt(retryAfterHeader, 10);
                        if (HTTP_DATE_EXP.test(retryAfterHeader)) {
                            // treat this as a date string.
                            resp.retryAfter =
                                new Date(retryAfterHeader).getTime() - Date.now();
                        }
                        else if (delay > 0) {
                            // treat this as a delay (in seconds).
                            resp.retryAfter = delay * 1000;
                        }
                    }
                    // The caller provided retry condition returned true, so we fail and
                    // retry the request.
                    return Promise.reject(resp);
                }
                // Everything seems to be order, so just return the response.
                return Promise.resolve(resp);
            });
        };
        var backoff = new backoff_1.Backoff(requestFn, backoffStrategy);
        return backoff
            .start()
            .catch(this._handleRetriedRequestError)
            .then(function (response) {
            response.metadata = httpRequest.options.metadata;
            response.retries = response.retries || {};
            response.retries.count = backoff.getRetryCount();
            _this._pluginMediator.emitSync(plugin_event_1.PluginEvent.TRANSPORT_BEFORE_RETURN_RESPONSE, {
                context: context,
                response: response,
            });
            if (httpRequest.options.rejectNotOk && !response.ok) {
                return Promise.reject(response);
            }
            return response;
        });
    };
    /**
     * Sets the `Authorization` header for a request via its RequestOptions.
     *
     * @param request - The internal request args.
     * @param ignoreCachedToken - If set to true, a new token will be requested
     *   before setting the header.
     * @returns The `RequestOptions` with the `header.Authorization` value set to
     *   a `Bearer` token.
     */
    Transport.prototype._setAuthHeader = function (request, ignoreCachedToken) {
        var _this = this;
        if (!request.options.authorize) {
            return Promise.resolve(request);
        }
        var setterFn = function () {
            return _this._refreshToken(ignoreCachedToken).then(function (token) {
                request.headers.set('Authorization', "Bearer " + token);
                return request;
            });
        };
        if (this._stateMask & StateFlag.AUTHENTICATED) {
            return setterFn();
        }
        // We are not yet authenticated, so wait until we are authenticated before
        // we set the header.
        //
        // Note! This may actually hang forever, if authentication never succeeds.
        return new Promise(function (resolve, reject) {
            debugLogger.info('Auth header setting awaiting authentication.');
            _this.once(event_1.Event.AUTHENTICATED, function () {
                debugLogger.info('Auth header set after authentication.');
                setterFn().then(resolve, reject);
            });
        });
    };
    /**
     * Handles a "failing" request from `Transport#_sendRetriedRequest`.
     *
     * @privateRemarks
     * By default, the `Transport.request` method should never reject because of
     * the request not being "successful" (i.e, not being in the 2xx range). This
     * mirrors the behaviour of XMLHttpRequest.
     *
     * Therefore, we need to make sure that we do not throw any `HTTPResponse`s
     * event though the `Backoff` function might have failed.
     * @param maybeError - An object that would either be an `HTTPResponse` or
     *   something else that was thrown.
     * @returns A promise that will be resolved to an `HTTPResponse` or rejected
     *   with anything else.
     */
    Transport.prototype._handleRetriedRequestError = function (maybeError) {
        if (maybeError instanceof response_1.HTTPResponse) {
            // The request was successful, but the retry parameters probably didn't
            // clear the response as successful. In which case we should just return
            // the response directly and let the requester handle it.
            return Promise.resolve(maybeError);
        }
        return Promise.reject(maybeError);
    };
    // Event Handlers
    /**
     * Called every time a listener is added for one of the state-aware events
     * (i.e., `Events.TRANSPORT_CONNECTED`, `Events.TRANSPORT_AUTHENTICATED` and
     * `Events.TRANSPORT_CONNECTION_ID`).
     *
     * @param type - The type of event, either 'connected', 'authorized' or 'connection_id'
     * @param ev - The `MetaListenerEvent` containing details about the listener added.
     */
    Transport.prototype._onAddListener = function (type, ev) {
        var _this = this;
        var options = ev.data.options;
        if (options.ignoreCurrentState) {
            // Do not process state-aware event--it has been explicitly disabled.
            return;
        }
        var eventPromise;
        switch (type) {
            // Internal Events
            case 'connected':
                if (!this.isConnected()) {
                    return;
                }
                eventPromise = Promise.resolve(this.createEvent(event_1.Event.CONNECTED, null));
                break;
            case 'authenticated': {
                if (!this.isAuthenticated()) {
                    return;
                }
                // When transport is authenticated the last measure cannot be null.
                var timing = this._stateAwareOperationMetrics.authenticated;
                eventPromise = Promise.resolve(this.createEvent(event_1.Event.AUTHENTICATED, { timing: timing }));
                break;
            }
            case 'connection_id': {
                // The state-aware event for connection id is special-cased for dealer.
                var dealerAPI = this.getPluginAPI('dealer');
                if (!dealerAPI || !dealerAPI.hasConnectionInfo()) {
                    return;
                }
                eventPromise = dealerAPI.getConnectionInfo().then(function (connectionInfo) {
                    return _this.createEvent(event_1.Event.CONNECTION_ID, connectionInfo);
                });
                break;
            }
            // Plugin Events
            case 'transport_connect':
                if (!this.isConnected() || !this._endpoints) {
                    return;
                }
                eventPromise = Promise.resolve(this._pluginMediator.createEvent(plugin_event_1.PluginEvent.TRANSPORT_CONNECT, {
                    endpoints: tslib_1.__assign({}, this._endpoints),
                    awaitPromise: function (_awaiter) { },
                }));
                break;
            case 'transport_authenticate':
                if (!this.isAuthenticated()) {
                    return;
                }
                eventPromise = this._refreshToken().then(function (token) {
                    return _this._pluginMediator.createEvent(plugin_event_1.PluginEvent.TRANSPORT_AUTHENTICATE, {
                        token: token,
                        awaitPromise: function (_awaiter) { },
                    });
                });
                break;
            default:
                return;
        }
        var listener = ev.data.listener;
        this._stateAwareListeners[type].push(listener);
        var runners = this._stateAwareRunners;
        if (runners[type]) {
            // There is already a runner scheduled, so we return immediately as this
            // listener will be called in the scheduled runner.
            return;
        }
        runners[type] = eventPromise.then(this._runStateAwareQueues.bind(this, type));
        if (options.once) {
            // This is a once event listener, so we don't want it to get added as an
            // actual listener since it's already going to be run once by our
            // scheduled runner.
            ev.preventDefault();
        }
    };
    /**
     * Called every time a listener is removed for one of the state-aware events
     * (i.e., `Events.TRANSPORT_CONNECTED`, `Events.TRANSPORT_AUTHENTICATED` and
     * `Events.TRANSPORT_CONNECTION_ID`).
     *
     * @param type - The type of event, either 'connected', 'authorized' or 'connection_id'
     * @param event - The `MetaListenerEvent` containing details about the listener added.
     */
    Transport.prototype._onRemoveListener = function (type, event) {
        var options = event.data.options;
        if (options.ignoreCurrentState || options.once) {
            // The user has indicated that this listener is not state aware, or this
            // was a once event, so we ignore it.
            return;
        }
        var listener = event.data.listener;
        var index = this._stateAwareListeners[type].indexOf(listener);
        if (index === -1) {
            return;
        }
        this._stateAwareListeners[type].splice(index, 1);
    };
    Transport.prototype._getQuickDisconnectTimeout = function () {
        return this._counter.getTime(this._quickDisconnectCount);
    };
    Transport.prototype._onPluginDisconnected = function (ev) {
        var now = Date.now();
        var sessionLength = now - this._lastDisconnect;
        this._performDisconnect();
        if (ev.data.code === internal_socket_code_1.InternalSocketCode.CLOSE) {
            // Explicit disconnect, do not try to reconnect.
            this._quickDisconnectCount = 0;
            return;
        }
        if (!this._connectionObserver.isOnline()) {
            // Browser is offline, do not reconnect right now. Will be handled by
            // `_onOnline`.
            return;
        }
        if (sessionLength < RECONNECT_THRESHOLD) {
            if (this._reconnectTimeout) {
                clearTimeout(this._reconnectTimeout);
            }
            this._quickDisconnectCount++;
            this.emit(event_1.Event.SHORT_SESSION_DISCONNECTED, {
                disconnectCount: this._quickDisconnectCount,
                sessionLength: sessionLength,
            });
            this._reconnectTimeout = setTimeout(this._tryToReconnect.bind(this), this._getQuickDisconnectTimeout());
        }
        else {
            this._quickDisconnectCount = 0;
            this._lastDisconnect = now;
            this._tryToReconnect();
        }
    };
    /**
     * Called when the ConnectionObserver detects that the browser has gone online.
     */
    Transport.prototype._onOnline = function () {
        this.emit(event_1.Event.CONNECTION_ONLINE, null);
        if (this._connectCalled) {
            this._tryToReconnect();
        }
    };
    /**
     * Called when the ConnectionObserver detects that the browser has gone offline.
     */
    Transport.prototype._onOffline = function () {
        this.emit(event_1.Event.CONNECTION_OFFLINE, null);
        this._performDisconnect();
    };
    /**
     * Called after the connection process is completed.
     *
     * @returns A promise that will be resolved with a boolean if the
     *   authentication was successful.
     */
    Transport.prototype._onConnected = function () {
        this._stateMask |= StateFlag.CONNECTED;
        this.emit(event_1.Event.CONNECTED, null);
        return Promise.resolve(true);
    };
    /**
     * Called after the authentication process is completed.
     *
     * @param operationMetrics - Context with time measurement details
     * @returns A promise that will be resolved with a boolean if the
     *   authentication was successful.
     */
    Transport.prototype._onAuthenticated = function (operationMetrics) {
        operationMetrics.end();
        clearTimeout(this._reconnectTimeout);
        this._authenticationPromise = null;
        this._stateMask |= StateFlag.AUTHENTICATED;
        this._initTime = Date.now();
        var timing = operationMetrics.getMetrics();
        this.emit(event_1.Event.AUTHENTICATED, { timing: timing });
        this._stateAwareOperationMetrics.authenticated = timing;
        return Promise.resolve(true);
    };
    /**
     * Called when the authentication process fails due to errors.
     *
     * @param e - Commonly an error, but might also be an event.
     * @param operationMetrics - Context with time measurement details
     * @returns A promise that will be rejected with the error.
     */
    Transport.prototype._onAuthenticationFailed = function (e, operationMetrics) {
        operationMetrics.end();
        var error = e && e.error ? e.error : e;
        this._authenticationPromise = null;
        this._stateMask &= ~StateFlag.AUTHENTICATED;
        var errorEventData = {
            error: error,
            timing: operationMetrics.getMetrics(),
        };
        this.emit(event_1.Event.AUTHENTICATION_FAILED, errorEventData);
        this._pluginMediator.emit(plugin_event_1.PluginEvent.TRANSPORT_AUTHENTICATE_FAILED, errorEventData);
        return Promise.reject(error);
    };
    /**
     * Called when the backend triggers a logout of clients.
     */
    Transport.prototype._onLogout = function () {
        var _this = this;
        var handler = function () {
            _this._lastToken = null;
            _this._lastTokenExpiry = 0;
            _this.emit(event_1.Event.LOGGED_OUT, null);
        };
        this._disconnect(disconnection_reason_1.DisconnectionReason.LOG_OUT).then(handler, handler);
    };
    /**
     * Disconnects the Transport connection gracefully.
     *
     * @param reason - The disconnection reason.
     * @returns A promise that will be resolved once the instance has been disconnected.
     */
    Transport.prototype._disconnect = function (reason) {
        var _this = this;
        if (!this._connectCalled) {
            return Promise.resolve(false);
        }
        this._connectCalled = false;
        this._authenticateCalled = false;
        var eventName = this.isConnected()
            ? event_1.Event.BEFORE_ONLINE_DISCONNECT
            : event_1.Event.BEFORE_OFFLINE_DISCONNECT;
        var awaiting = [];
        var awaitPromise = function (promise) {
            awaiting.push(promise.catch(function () {
                // Ignore any errors that might arise from the promise.
            }));
        };
        this.emitSync(eventName, { awaitPromise: awaitPromise });
        return Promise.all(awaiting).then(function () { return _this._performDisconnect(reason); });
    };
    // Public API
    /**
     * Returns whether the Transport instance is connected to the messaging endpoints.
     *
     * @returns True if the Transport instance is connected, false otherwise.
     */
    Transport.prototype.isConnected = function () {
        return !!(this._stateMask & StateFlag.CONNECTED);
    };
    /**
     * Returns whether the Transport instance is authenticated to the messaging endpoints.
     *
     * @returns True if the Transport instance is authenticated, false otherwise.
     */
    Transport.prototype.isAuthenticated = function () {
        return !!(this._stateMask & StateFlag.AUTHENTICATED);
    };
    /**
     * Returns whether the Transport instance is currently reconnecting.
     *
     * @returns True if the Transport instance is reconnecting, false otherwise.
     */
    Transport.prototype.isReconnecting = function () {
        return this._isReconnecting;
    };
    /**
     * Returns whether the browser is online.
     *
     * Note that for browsers that do not support the online/offline events, this
     * method will always return `true`.
     *
     * @returns True if the browser is online, false otherwise.
     */
    Transport.prototype.isOnline = function () {
        return this._connectionObserver.isOnline();
    };
    /**
     * Connects a Transport instance to the messaging endpoints.
     *
     * Internally, this will trigger Transport to call the `EndpointsProvider` to
     * fetch the map of messaging endpoints to connect to.
     *
     * @returns A promise that will be resolved once the instance has connected,
     *   or rejected with errors related to connection.
     */
    Transport.prototype.connect = function () {
        this._connectCalled = true;
        return this._connect();
    };
    /**
     * Authenticates a Transport instance to the messaging endpoints.
     *
     * Internally, this will trigger Transport to call the `TokenProvider` to to
     * get an OAuth token that will be used for authentication.
     *
     * @returns A promise that will be resolved once the instance has benn
     *   authenticated, or rejected with any errors related to authentication.
     */
    Transport.prototype.authenticate = function () {
        this._authenticateCalled = true;
        return this._authenticate(true);
    };
    /**
     * Disconnects the Transport from the messaging endpoints.
     *
     * Before fully disconnecting, the Transport instance will emit an event that
     * other modules can use to register "awaited promises". The disconnection
     * will only happen after all those registered promises have been either
     * resolved or rejected.
     *
     * @returns A promise that will be resolved once the instance has been disconnected.
     */
    Transport.prototype.disconnect = function () {
        return this._disconnect(disconnection_reason_1.DisconnectionReason.EXPLICIT);
    };
    /**
     * Disconnects a Transport instance from the messaging endpoints, bypassing
     * any "awaited" promises.
     *
     * Unlike the `disconnect()` method, this method does not emit any event that
     * will other modules can use to register awaited promises.
     *
     * @returns A promise that will be resolved once the instance has been disconnected.
     */
    Transport.prototype.forceDisconnect = function () {
        if (!this._connectCalled) {
            return Promise.resolve(false);
        }
        this._connectCalled = false;
        this._authenticateCalled = false;
        this._performDisconnect(disconnection_reason_1.DisconnectionReason.EXPLICIT);
        return Promise.resolve(true);
    };
    /**
     * Forces the instance to refresh its OAuth token.
     *
     * @returns A promise that will be resolved once the token has been refreshed.
     */
    Transport.prototype.forceTokenRefresh = function () {
        return this._refreshToken(true).then(function () { return true; });
    };
    /**
     * Returns the time when the Transport instance was authenticated.
     *
     * @returns A timestamp of when the instance was authenticated.
     */
    Transport.prototype.getInitTime = function () {
        return this._initTime;
    };
    /**
     * Returns the endpoints defined by the `EndpointsProvider`.
     *
     * This will return `null` if the Transport instance is not yet connected.
     *
     * @returns The endpoints defined by the `EndpointsProvider`, or null if the
     *   Transport instance is not yet connected.
     */
    Transport.prototype.getEndpoints = function () {
        return this._endpoints ? tslib_1.__assign({}, this._endpoints) : null;
    };
    /**
     * Returns the last access token from the `TokenProvider`.
     *
     * This will return `null` if the Transport instance is not yet authenticated.
     *
     * @returns The last access token returned by the `TokenProvider`, or null if
     *   the Transport instance has not been authenticated.
     */
    Transport.prototype.getLastToken = function () {
        return this._lastToken;
    };
    /**
     * Returns a `PublicTransport` instance associated with this Transport instance.
     *
     * @param options - The options for this PublicTransport instance.
     * @returns A `PublicTransport` instance.
     */
    Transport.prototype.toPublic = function (options) {
        return new public_transport_1.PublicTransport(this, options);
    };
    /**
     * Checks whether this Transport instance has the same `refOwner` as the provided value.
     *
     * @param ownerRef - An object reference.
     * @returns True if the `refOwner` value is the same as the instance's
     *   refOwner value, or false otherwise.
     */
    Transport.prototype.hasOwnerRef = function (ownerRef) {
        return this._ownerRef === ownerRef;
    };
    /**
     * Takes a string URL and appends an `access_token` query parameter and
     * returns the new string URL as a promise.
     *
     * This method will refresh the access token.
     *
     * @param url - The URL to append the query parameter to.
     * @returns A promise with the access token appended as a query parameter.
     */
    Transport.prototype.appendTokenQuery = function (url) {
        return this._refreshToken().then(function (token) {
            return appendAccessTokenQuery(url, token);
        });
    };
    /**
     * Takes a string URL and appends an `access_token` query parameter containing
     * the last known access token if available.
     *
     * Note that this method does not refresh the token; if there is no token
     * available, the string will be returned as is. The function can also return
     * a stale access token.
     *
     * @param url - The URL to append the query parameter to.
     * @returns The URL string with the access token appended as a query
     *   parameter, if the token is available.
     */
    Transport.prototype.appendLastTokenQuery = function (url) {
        if (!this._lastToken) {
            return url;
        }
        return appendAccessTokenQuery(url, this._lastToken);
    };
    /**
     * Adds a handler function that will be called every time a message comes from
     * `Dealer` with a `uri` value matching the provided `matcher` argument.
     *
     * @param matcher - A string or regular expression that will be used to test
     *   each incoming `Dealer` message. If the message's `uri` value matches, the
     *   provided `handler` function will be called.
     * @param handler - A function that will be called every time a matching
     *   message is received from `Dealer`. The message will be passed as an
     *   argument to this function.
     * @param plugin - An optional plugin name. If not provided, it will match
     *   messages from all plugins.
     */
    Transport.prototype.matchMessages = function (matcher, handler, plugin) {
        if (!matcher) {
            throw new TypeError('Message "matcher" cannot be null.');
        }
        if (typeof handler !== 'function') {
            throw new TypeError('Message callback cannot be null.');
        }
        var wrapper = function (ev) {
            var msg = ev.data.message;
            if (!msg.uri ||
                !msg.uri.match(matcher) ||
                (plugin && plugin !== ev.data.plugin)) {
                return;
            }
            handler(msg);
        };
        wrapper.__matchMessagesExp = matcher;
        wrapper.__matchMessagesPlugin = plugin;
        // Store the wrapper in the function so we can remove it.
        handler.__matchMessagesWrapper = wrapper;
        this._pluginMediator.on(plugin_event_1.PluginEvent.PLUGIN_MESSAGE, wrapper);
    };
    /**
     * Removes a handler for a particular `Dealer` message.
     *
     * Note that you must pass the exact `matcher` and `handler` values as you did
     * when calling `matchMessages`.
     *
     * @param matcher - The string or RegExp matcher.
     * @param handler - The handler function.
     * @param plugin - An optional plugin name. If not provided, it will match
     *   messages from all plugins.
     * @returns True if the handler was removed successfully, false otherwise.
     */
    Transport.prototype.unmatchMessages = function (matcher, handler, plugin) {
        if (typeof handler !== 'function') {
            throw new TypeError('Message callback cannot be null.');
        }
        var wrapper = handler.__matchMessagesWrapper;
        if (!wrapper ||
            wrapper.__matchMessagesExp !== matcher ||
            wrapper.__matchMessagesPlugin !== plugin) {
            return false;
        }
        this._pluginMediator.removeListener(plugin_event_1.PluginEvent.PLUGIN_MESSAGE, wrapper);
        return true;
    };
    /**
     * Adds a handler function that will be called every time a request comes from
     * `Dealer` with a `message_ident` value matching the provided `matcher` argument.
     *
     * @param matcher - A string or regular expression that will be used to test
     *   each incoming `Dealer` request. If the request's `message_ident` value
     *   matches, the provided `handler` function will be called.
     * @param handler - A function that will be called every time a matching
     *   request is received from `Dealer`. The request will be passed as an
     *   argument to this function.
     * @param plugin - An optional plugin name. If not provided, it will match
     *   messages from all plugins.
     */
    Transport.prototype.handlePushRequests = function (matcher, handler, plugin) {
        if (!matcher) {
            throw new TypeError('Push request "matcher" cannot be null.');
        }
        if (typeof handler !== 'function') {
            throw new TypeError('Push request callback cannot be null.');
        }
        var wrapper = function (ev) {
            var msg = ev.data.request;
            if (!msg.message_ident ||
                !msg.message_ident.match(matcher) ||
                (plugin && plugin !== ev.data.plugin)) {
                return;
            }
            Promise.resolve(handler(msg)).then(ev.data.reply);
        };
        wrapper.__matchRequestExp = matcher;
        wrapper.__matchRequestPlugin = plugin;
        // Store the wrapper in the function so we can remove it.
        handler.__matchRequestWrapper = wrapper;
        this._pluginMediator.on(plugin_event_1.PluginEvent.PLUGIN_REQUEST, wrapper);
    };
    /**
     * Removes a handler for a particular `Dealer` request.
     *
     * Note that you must pass the exact `matcher` and `handler` values as you did
     * when calling `handlePushRequest`.
     *
     * @param matcher - The string or RegExp matcher.
     * @param handler - The handler function.
     * @param plugin - An optional plugin name. If not provided, it will match
     *   messages from all plugins.
     * @returns True if the handler was removed successfully, false otherwise.
     */
    Transport.prototype.unhandlePushRequests = function (matcher, handler, plugin) {
        if (typeof handler !== 'function') {
            throw new TypeError('Push request callback cannot be null.');
        }
        var wrapper = handler.__matchRequestWrapper;
        if (!wrapper ||
            wrapper.__matchRequestExp !== matcher ||
            wrapper.__matchRequestPlugin !== plugin) {
            return false;
        }
        this._pluginMediator.removeListener(plugin_event_1.PluginEvent.PLUGIN_REQUEST, wrapper);
        return true;
    };
    /**
     * Sends a request to a given URL and returns a `Promise` that will be
     * resolved to a response.
     *
     * Note that the `HTTPResponse` object from this request is implemented as a
     * generic, and the type of the `HTTPResponse.body` field will depend on the
     * value of `options.responseType` field:
     *
     * - `'arraybuffer'` - `ArrayBuffer | null`
     * - `'text'` or `''` - `string | null``
     * - `'json'` - `any | null`
     *
     * @param uri - The URI to request. This can be a normal HTTP/HTTPs URL, a
     *   partial relative path (e.g., '/home') or a "special" URL that will be
     *   expanded using the `Endpoints` from the `EndpointsProvider` (e.g.,
     *   '@webgate/melody/v1/time').
     * @param options - The request options.
     * @returns A promise that will resolved to an `HTTPResponse` object.
     */
    Transport.prototype.request = function (uri, options) {
        var _this = this;
        var _a;
        // We create a different sent of request params, which we will pass as an
        // argument to the plugin mediator. This is needed to enable changing of
        // the request URL, which is a primitive type.
        var requestParams = { uri: uri, options: options, context: {} };
        this._pluginMediator.emitSync(plugin_event_1.PluginEvent.TRANSPORT_BEFORE_PROCESS_REQUEST, requestParams);
        var sendRequest = this._sendRequest.bind(this, requestParams.uri, requestParams.options, requestParams.context);
        var shouldWaitForConnection = (!((_a = requestParams.options) === null || _a === void 0 ? void 0 : _a.allowOffline) &&
            !this._connectionObserver.isOnline()) ||
            (HTTP_SPECIAL_URL_EXP.test(requestParams.uri) &&
                !(this._stateMask & StateFlag.CONNECTED));
        if (shouldWaitForConnection) {
            return new Promise(function (resolve, reject) {
                _this.once(event_1.Event.CONNECTED, function () {
                    sendRequest().then(resolve, reject);
                });
            });
        }
        return sendRequest();
    };
    /**
     * Adds a plugin into the current instance.
     *
     * @param creator - The plugin creator function.
     * @param options - A set of options for the plugin, if any. Note that the
     *   options are different for each plugin. Check the plugin documentation for
     *   more details.
     * @returns The name of the plugin that was added. Can be used as an argument
     *   to other methods like `removePlugin` and `hasPlugin`.
     */
    Transport.prototype.addPlugin = function (creator, options) {
        var plugin = creator(this, options);
        var name = plugin.name;
        if (this._plugins[name]) {
            throw new TypeError('Plugin is already added.');
        }
        plugin.attach(this, this._pluginMediator);
        this._plugins[name] = plugin;
        return name;
    };
    /**
     * Removes a plugin from the current instance.
     *
     * @param name - The name of the plugin to remove.
     * @returns The value `true` if the plugin was successfully removed, or
     *   `false` if the plugin does not exist in the current instance.
     */
    Transport.prototype.removePlugin = function (name) {
        var plugin = this._plugins[name];
        if (!plugin) {
            return false;
        }
        plugin.detach(this, this._pluginMediator);
        this._plugins[name] = undefined;
        return true;
    };
    /**
     * Checks whether a plugin was added to the instance.
     *
     * @param name - The name of the plugin to check.
     * @returns The value `true` if the plugin was added to this instance, `false`
     *   otherwise.
     */
    Transport.prototype.hasPlugin = function (name) {
        return !!this._plugins[name];
    };
    /**
     * Returns the API object of a plugin.
     *
     * Each plugin has a different set of APIs, so this method is generic and can
     * take an optional hint type parameter for the specific plugin's API type.
     *
     * @example Import { DealerAPI DealerPlugin, } from
     * '@spotify-internal/transport/lib/plugins/dealer';
     *
     *     const pluginName = transport.addPlugin(DealerPlugin);
     *
     * Const dealerAPI = transport.getPluginAPI<DealerAPI>(pluginName);
     *
     * @typeParam T A hinting type param for type of the API. Defaults to `unknown`
     * @param name - The name of the plugin to retrieve the API for.
     * @returns The API Object of the plugin, or null if the plugin does not
     *   specify an API or if the plugin was not added to the instance. If the
     *   type param `T` was specified, the API object will be cast to the value specified.
     */
    Transport.prototype.getPluginAPI = function (name) {
        var plugin = this._plugins[name];
        return plugin && plugin.api ? plugin.api : null;
    };
    /**
     * Returns the connection ID of the instance.
     *
     * @param pluginName - The name of the plugin whose connection id will be
     *   retrieve. Defaults to 'dealer'.
     * @returns A promise that will be resolved with the connection id of the
     *   Dealer instance, or rejected with an error if the Transport instance does
     *   not have a `Dealer` instance.
     */
    Transport.prototype.getConnectionId = function (pluginName) {
        if (pluginName === void 0) { pluginName = 'dealer'; }
        var plugin = this._plugins[pluginName];
        if (!plugin) {
            return Promise.reject(new TypeError("Cannot retrieve connection id for plugin " + plugin + "."));
        }
        if (!plugin.api || !hasPluginSocketAPI(plugin)) {
            return Promise.reject(new TypeError("Plugin " + plugin + " is not a socket plugin."));
        }
        return plugin.api.getConnectionInfo().then(function (info) { return info.id; });
    };
    /**
     * Remove all event listeners from the instance.
     *
     * NOTE: This is a NO-OP function. As a Transport instance can be used and
     * pass across multiple libraries and packages, exposing this method can lead
     * to hard to detect bugs. We therefore override this method explicitly and
     * disable the behaviour.
     *
     * @returns The Transport instance.
     */
    Transport.prototype.removeAllListeners = function () {
        return this;
    };
    return Transport;
}(emitter_1.EventEmitter));
exports.Transport = Transport;
//# sourceMappingURL=transport.js.map