/**
 * Copyright (c) 2017 Spotify AB
 *
 * Fast base62 encoder/decoder.
 *
 * Usage:
 *
 *   Base62.toHex('1C0pasJ0dS2Z46GKh2puYo') // -> '34ff970885ca8fa02c0d6e459377d5d0'
 *                         ^^^
 *                          |
 *               Length-22 base62-encoded ID.
 *         Lengths other than 22 or invalid base62 IDs
 *                  are not supported.
 *
 *   Base62.fromHex('34ff970885ca8fa02c0d6e459377d5d0') // -> '1C0pasJ0dS2Z46GKh2puYo'
 *                         ^^^
 *                          |
 *               Length-32 hex-encoded ID.
 *         Lengths other than 32 are not supported.
 *
 * Written by @ludde, programatically tested and documented by @felipec.
 */
(function() {
  // Alphabets
  var HEX16 = '0123456789abcdef';
  var BASE62 =
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';

  // Hexadecimal fragments
  var HEX256 = [];
  HEX256.length = 256;
  for (var i = 0; i < 256; i++) {
    HEX256[i] = HEX16[i >> 4] + HEX16[i & 0xf];
  }

  // Look-up tables
  var ID62 = [];
  ID62.length = 128;
  for (var i = 0; i < BASE62.length; ++i) {
    ID62[BASE62.charCodeAt(i)] = i;
  }
  var ID16 = [];
  for (var i = 0; i < 16; i++) {
    ID16[HEX16.charCodeAt(i)] = i;
  }
  for (var i = 0; i < 6; i++) {
    ID16['ABCDEF'.charCodeAt(i)] = 10 + i;
  }

  var Base62 = {
    toHex: function(s) {
      if (s.length !== 22) {
        // Can only parse base62 ids with length == 22.
        // Invalid base62 ids will lead to garbage in the output.
        return null;
      }

      // 1 / (2^32)
      var MAX_INT_INV = 2.3283064365386963e-10;
      // 2^32
      var MAX_INT = 0x100000000;
      // 62^3
      var P62_3 = 238328;

      var p0, p1, p2, p3;
      var v;
      // First 7 characters fit in 2^53
      // prettier-ignore
      p0 =
        ID62[s.charCodeAt(0)] * 56800235584 +  // * 62^6
        ID62[s.charCodeAt(1)] * 916132832 +    // * 62^5
        ID62[s.charCodeAt(2)] * 14776336 +     // * 62^4
        ID62[s.charCodeAt(3)] * 238328 +       // * 62^3
        ID62[s.charCodeAt(4)] * 3844 +         // * 62^2
        ID62[s.charCodeAt(5)] * 62 +           // * 62^1
        ID62[s.charCodeAt(6)];                 // * 62^0
      p1 = (p0 * MAX_INT_INV) | 0;
      p0 -= p1 * MAX_INT;
      // 62^10 < 2^64
      v =
        ID62[s.charCodeAt(7)] * 3844 +
        ID62[s.charCodeAt(8)] * 62 +
        ID62[s.charCodeAt(9)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      p1 = p1 * P62_3 + v;
      // 62^13 < 2^96
      v =
        ID62[s.charCodeAt(10)] * 3844 +
        ID62[s.charCodeAt(11)] * 62 +
        ID62[s.charCodeAt(12)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      p2 = v;
      // 62^16 < 2^96
      v =
        ID62[s.charCodeAt(13)] * 3844 +
        ID62[s.charCodeAt(14)] * 62 +
        ID62[s.charCodeAt(15)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      p2 = p2 * P62_3 + v;
      // 62^19 < 2^128
      v =
        ID62[s.charCodeAt(16)] * 3844 +
        ID62[s.charCodeAt(17)] * 62 +
        ID62[s.charCodeAt(18)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
      p3 = v;
      v =
        ID62[s.charCodeAt(19)] * 3844 +
        ID62[s.charCodeAt(20)] * 62 +
        ID62[s.charCodeAt(21)];
      (p0 = p0 * P62_3 + v), (p0 = p0 - (v = (p0 * MAX_INT_INV) | 0) * MAX_INT);
      (p1 = p1 * P62_3 + v), (p1 = p1 - (v = (p1 * MAX_INT_INV) | 0) * MAX_INT);
      (p2 = p2 * P62_3 + v), (p2 = p2 - (v = (p2 * MAX_INT_INV) | 0) * MAX_INT);
      (p3 = p3 * P62_3 + v), (p3 = p3 - (v = (p3 * MAX_INT_INV) | 0) * MAX_INT);
      if (v) {
        // carry not allowed
        return null;
      }
      // prettier-ignore
      return HEX256[p3>>>24]+HEX256[(p3>>>16)&0xFF]+HEX256[(p3>>>8)&0xFF]+HEX256[(p3)&0xFF] +
             HEX256[p2>>>24]+HEX256[(p2>>>16)&0xFF]+HEX256[(p2>>>8)&0xFF]+HEX256[(p2)&0xFF] +
             HEX256[p1>>>24]+HEX256[(p1>>>16)&0xFF]+HEX256[(p1>>>8)&0xFF]+HEX256[(p1)&0xFF] +
             HEX256[p0>>>24]+HEX256[(p0>>>16)&0xFF]+HEX256[(p0>>>8)&0xFF]+HEX256[(p0)&0xFF];
    },

    fromHex: function(s) {
      var i;
      var p0 = 0, p1 = 0, p2 = 0;
      for (i = 0; i < 10; i++) p2 = p2 * 16 + ID16[s.charCodeAt(i)];
      for (i = 0; i < 11; i++) p1 = p1 * 16 + ID16[s.charCodeAt(i + 10)];
      for (i = 0; i < 11; i++) p0 = p0 * 16 + ID16[s.charCodeAt(i + 21)];
      if (isNaN(p0 + p1 + p2)) {
        return null;
      }
      var P16_11 = 17592186044416; // 16^11
      var INV_62 = 1.0 / 62;

      var acc;
      var ret = '';
      i = 0;
      for (; i < 7; ++i) {
        acc = p2;
        p2 = Math.floor(acc * INV_62);
        acc = (acc - p2 * 62) * P16_11 + p1;
        p1 = Math.floor(acc * INV_62);
        acc = (acc - p1 * 62) * P16_11 + p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      p1 += p2 * P16_11;
      for (; i < 15; ++i) {
        acc = p1;
        p1 = Math.floor(acc * INV_62);
        acc = (acc - p1 * 62) * P16_11 + p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      p0 += p1 * P16_11;
      for (; i < 21; ++i) {
        acc = p0;
        p0 = Math.floor(acc * INV_62);
        ret = BASE62[acc - p0 * 62] + ret;
      }
      return BASE62[p0] + ret;
    },

    // Expose the lookup tables
    HEX256: HEX256, // number -> 'hh'
    ID16: ID16,  // hexadecimal char code -> 0..15
    ID62: ID62,  // base62 char code -> 0..61
  };

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = Base62;
  } else {
    window.Base62 = Base62;
  }
})();
