var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { keys, reduce, toPairs } from 'ramda';
export var addKeysPrefix = function (keyList) { return function (prefix) { return function (obj) {
    return toPairs(obj).reduce(function (acc, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        var objKey = keyList.includes(key) ? "" + prefix + key : key;
        return __assign(__assign({}, acc), (_b = {}, _b[objKey] = value, _b));
    }, {});
}; }; };
export var renameKeys = function (keyMap) { return function (obj) {
    return reduce(function (acc, key) {
        if (keyMap[key]) {
            acc[keyMap[key]] = obj[key];
        }
        else {
            acc[key] = obj[key];
        }
        return acc;
    }, {}, keys(obj));
}; };
export default {
    extend: function (target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        return Object.assign.apply(Object, __spreadArrays([target], sources));
    },
    clone: function (obj) {
        return Object.assign({}, obj);
    },
    bindAll: function (obj, keyList) {
        var key;
        if (arguments.length === 1) {
            for (key in obj) {
                if (typeof obj[key] === 'function') {
                    obj[key] = obj[key].bind(obj);
                }
            }
        }
        else if (keyList) {
            for (key in keyList) {
                if (typeof obj[keyList[key]] === 'function') {
                    obj[keyList[key]] = obj[keyList[key]].bind(obj);
                }
            }
        }
        return obj;
    },
    getPreferredUrl: function (videos) {
        if (!Array.isArray(videos) || !videos.length) {
            return null;
        }
        var targetBitRate = 640;
        var mimeTypes = ['video/webm'];
        var preferredVideo = videos
            .filter(function (video) { return mimeTypes.indexOf(video.mimeType) > -1; })
            .sort(function (a, b) {
            var aDiff = Math.abs(a.bitrate - targetBitRate);
            var bDiff = Math.abs(b.bitrate - targetBitRate);
            return aDiff - bDiff;
        });
        return preferredVideo.length ? preferredVideo[0].url : null;
    },
};
//# sourceMappingURL=utils.js.map