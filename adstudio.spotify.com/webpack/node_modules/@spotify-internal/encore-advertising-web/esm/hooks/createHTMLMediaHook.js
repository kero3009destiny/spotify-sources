var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import * as React from 'react';
export default function createHTMLMediaHook(tag) {
    return (elOrProps) => {
        var _a;
        let element;
        let props;
        let stopsOtherMediaWhenPlaying;
        let resetOnEnded;
        if (React.isValidElement(elOrProps)) {
            element = elOrProps;
            (_a = element.props, { stopsOtherMediaWhenPlaying = true,
                resetOnEnded = true } = _a, props = __rest(_a, ["stopsOtherMediaWhenPlaying", "resetOnEnded"]));
        }
        else {
            ({ stopsOtherMediaWhenPlaying = true,
                resetOnEnded = true } = elOrProps, props = __rest(elOrProps, ["stopsOtherMediaWhenPlaying", "resetOnEnded"]));
        }
        const [state, setState] = useSetState({
            canPlay: false,
            buffered: [],
            time: 0,
            duration: 0,
            paused: true,
            muted: false,
            volume: 1,
            playbackRate: 1,
        });
        const ref = React.useRef(null);
        const wrapEvent = (userEvent, proxyEvent) => {
            return (event) => {
                try {
                    proxyEvent === null || proxyEvent === void 0 ? void 0 : proxyEvent(event);
                }
                finally {
                    userEvent === null || userEvent === void 0 ? void 0 : userEvent(event);
                }
            };
        };
        const onPlay = () => setState({ paused: false });
        const onPause = () => setState({ paused: true });
        const onCanPlay = () => setState({ canPlay: true });
        const onVolumeChange = () => {
            const el = ref.current;
            if (!el) {
                return;
            }
            setState({
                muted: el.muted,
                volume: el.volume,
            });
        };
        const onDurationChange = () => {
            const el = ref.current;
            if (!el) {
                return;
            }
            const { duration, buffered } = el;
            setState({
                duration,
                buffered: parseTimeRanges(buffered),
            });
        };
        const onTimeUpdate = () => {
            const el = ref.current;
            if (!el) {
                return;
            }
            setState({ time: el.currentTime });
        };
        const onProgress = () => {
            const el = ref.current;
            if (!el) {
                return;
            }
            setState({ buffered: parseTimeRanges(el.buffered) });
        };
        const onRateChange = () => {
            const el = ref.current;
            if (!el) {
                return;
            }
            setState({ playbackRate: el.playbackRate });
        };
        const onEnded = () => {
            if (!resetOnEnded)
                return;
            const el = ref.current;
            if (!el) {
                return;
            }
            el.currentTime = 0;
        };
        const elementProps = Object.assign(Object.assign({ controls: false }, props), { ref, onPlay: wrapEvent(props.onPlay, onPlay), onPause: wrapEvent(props.onPause, onPause), onCanPlay: wrapEvent(props.onCanPlay, onCanPlay), onVolumeChange: wrapEvent(props.onVolumeChange, onVolumeChange), onDurationChange: wrapEvent(props.onDurationChange, onDurationChange), onTimeUpdate: wrapEvent(props.onTimeUpdate, onTimeUpdate), onProgress: wrapEvent(props.onProgress, onProgress), onRateChange: wrapEvent(props.onRateChange, onRateChange), onEnded: wrapEvent(props.onEnded, onEnded) });
        element = element
            ? React.cloneElement(element, elementProps)
            : React.createElement(tag, elementProps);
        let lockPlay = false;
        const controls = {
            play: () => {
                if (stopsOtherMediaWhenPlaying) {
                    const media = document === null || document === void 0 ? void 0 : document.querySelectorAll('audio,video');
                    for (let i = 0; i < media.length; i += 1) {
                        media[i].pause();
                    }
                }
                const el = ref.current;
                if (!el) {
                    return undefined;
                }
                if (!lockPlay) {
                    const promise = el.play();
                    const isPromise = typeof promise === 'object';
                    if (isPromise) {
                        lockPlay = true;
                        const resetLock = () => {
                            lockPlay = false;
                        };
                        promise.then(resetLock, resetLock);
                    }
                    return promise;
                }
                return undefined;
            },
            pause: () => {
                const el = ref.current;
                if (el && !lockPlay) {
                    el.pause();
                }
            },
            seek: (time) => {
                const el = ref.current;
                if (!el || state.duration === undefined) {
                    return;
                }
                const fixedTime = Math.min(state.duration, Math.max(0, time));
                el.currentTime = fixedTime;
            },
            setVolume: (volume) => {
                const el = ref.current;
                if (!el) {
                    return;
                }
                const fixedVolume = Math.min(1, Math.max(0, volume));
                el.volume = fixedVolume;
                setState({ volume: fixedVolume });
            },
            mute: () => {
                const el = ref.current;
                if (!el) {
                    return;
                }
                el.muted = true;
            },
            unmute: () => {
                const el = ref.current;
                if (!el) {
                    return;
                }
                el.muted = false;
            },
            setPlaybackRate: (rate) => {
                const el = ref.current;
                if (!el || state.duration === undefined) {
                    return;
                }
                el.playbackRate = rate;
                setState({
                    playbackRate: rate,
                });
            },
        };
        React.useEffect(() => {
            const el = ref.current;
            if (!el) {
                if (process.env.NODE_ENV !== 'production') {
                    if (tag === 'audio') {
                        console.error('useAudio() ref to <audio> element is empty at mount. ' +
                            'It seem you have not rendered the audio element, which it ' +
                            'returns as the first argument const [audio] = useAudio(...).');
                    }
                    else if (tag === 'video') {
                        console.error('useVideo() ref to <video> element is empty at mount. ' +
                            'It seem you have not rendered the video element, which it ' +
                            'returns as the first argument const [video] = useVideo(...).');
                    }
                }
                return;
            }
            setState({
                volume: el.volume,
                muted: el.muted,
                paused: el.paused,
            });
            if (props.autoPlay && el.paused) {
                controls.play();
            }
        }, [props.src]);
        return [element, state, controls, ref];
    };
}
function parseTimeRanges(ranges) {
    const result = [];
    for (let i = 0; i < ranges.length; i++) {
        result.push({
            start: ranges.start(i),
            end: ranges.end(i),
        });
    }
    return result;
}
function useSetState(initialState = {}) {
    const [state, set] = React.useState(initialState);
    const setState = React.useCallback(patch => {
        set(prevState => Object.assign({}, prevState, patch instanceof Function ? patch(prevState) : patch));
    }, []);
    return [state, setState];
}
//# sourceMappingURL=createHTMLMediaHook.js.map