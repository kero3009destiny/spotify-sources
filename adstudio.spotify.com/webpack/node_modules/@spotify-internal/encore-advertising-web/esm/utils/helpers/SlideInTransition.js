import React from 'react';
import styled, { css } from 'styled-components';
import { useDelayUnmount } from '../../hooks/useDelayUnmount';
const Collapsible = styled.div `
  ${props => {
    const duration = props.duration || 0;
    const opacityDuration = duration + 200;
    return css `
      will-change: margin-bottom, opacity, max-height, visibility;
      // Advance Default Easing
      // https://encore.spotify.net/web/basics/motion?format=web-js#advance
      transition: margin-bottom ${duration}ms cubic-bezier(0.3, 0, 0, 1),
        opacity ${opacityDuration}ms cubic-bezier(0.3, 0, 0, 1);
      margin-bottom: 0;
      max-height: 1000000px;
      width: 100%;
      opacity: 1;
    `;
}}
`;
const CollapsibleWrapper = styled.div `
  ${props => {
    const duration = props.duration || 0;
    const opacityDuration = duration + 300;
    return css `
      display: flex;
      padding: 30px;
      margin: -30px;
      &:after {
        content: '';
        height: 30px;
        transition: height ${duration}ms linear,
          max-height 0s ${duration}ms linear;
        max-height: 0px;
      }

      ${props.collapsed &&
        css `
        & > ${Collapsible} {
          margin-bottom: -2000px;
          // Recede Default Easing
          // https://encore.spotify.net/web/basics/motion?format=web-js#recede
          transition: margin-bottom ${duration}ms cubic-bezier(1, 0, 0.7, 1),
            opacity ${opacityDuration}ms cubic-bezier(1, 0, 0.7, 1) visibility
              0s ${opacityDuration}ms,
            max-height 0s ${duration}ms;
          visibility: hidden;
          max-height: 0;
          opacity: 0;
        }
        &:after {
          height: 0;
          transition: height ${duration}ms linear;
          max-height: 30px;
        }
      `}

      ${props.isAnimating &&
        css `
        overflow: hidden;
      `}
    `;
}}
`;
export function useDelay({ shouldUnmount, delayTime, }) {
    const [shouldRender, setShouldRender] = React.useState(false);
    React.useEffect(() => {
        let timeoutId;
        if (!shouldUnmount && !shouldRender) {
            setShouldRender(true);
        }
        else if (shouldUnmount && shouldRender) {
            timeoutId = setTimeout(() => setShouldRender(false), delayTime);
        }
        return () => clearTimeout(timeoutId);
    }, [shouldUnmount, delayTime, shouldRender]);
    return shouldRender;
}
export const SlideInTransition = ({ className, collapsed, forceRender, duration = 300, children, }) => {
    const hasMounted = React.useRef(false);
    const [isAnimating, setIsAnimating] = React.useState(false);
    const shouldRender = useDelayUnmount({
        shouldUnmount: !!collapsed && !forceRender,
        delayTime: duration,
    });
    React.useEffect(() => {
        let timeoutId;
        if (hasMounted.current) {
            setIsAnimating(true);
            timeoutId = setTimeout(() => setIsAnimating(false), duration);
        }
        else {
            hasMounted.current = true;
        }
        return () => {
            setIsAnimating(false);
            clearTimeout(timeoutId);
        };
    }, [collapsed, duration]);
    return (React.createElement(CollapsibleWrapper, { className: className, collapsed: collapsed, duration: duration, isAnimating: isAnimating },
        React.createElement(Collapsible, { duration: duration }, shouldRender && children)));
};
//# sourceMappingURL=SlideInTransition.js.map