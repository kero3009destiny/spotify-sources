export default class HTML5AudioWrapper {
    constructor(props) {
        var _a;
        this.onTimeUpdate = () => {
            const playingRatio = this.getCurrentTime() / this.getDuration();
            const currentTime = this.getCurrentTime();
            this.events.setTimeUpdate(playingRatio, currentTime);
        };
        this.onEnded = () => {
            this.stop();
            this.events.ended();
        };
        this.onLoadedMetadata = () => {
            this.events.setDuration(this.getDuration());
        };
        this.pause = () => {
            var _a;
            const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
            if (audioRef) {
                const elapsed = audioRef.currentTime - this.startedAt;
                this.stop();
                this.pausedAt = elapsed;
            }
        };
        this.seek = (time) => {
            var _a;
            const duration = this.getDuration();
            const currentTime = Math.min(Math.round(time * duration), duration);
            if (this.playing) {
                this.play(currentTime);
            }
            else {
                const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
                if (audioRef) {
                    audioRef.currentTime = currentTime;
                    this.pausedAt = currentTime;
                }
            }
        };
        this.stop = () => {
            var _a;
            const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
            if (audioRef) {
                audioRef.pause();
            }
            this.pausedAt = 0;
            this.startedAt = 0;
            this.playing = false;
        };
        this.getDuration = () => {
            var _a;
            const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
            if (audioRef && !this.duration && audioRef.duration) {
                this.duration = audioRef.duration;
            }
            return this.duration || 0;
        };
        this.getCurrentTime = () => {
            var _a;
            const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
            if (audioRef) {
                return Math.min(audioRef.currentTime, this.getDuration());
            }
            return 0;
        };
        this.play = (position) => {
            var _a;
            const offset = position || this.pausedAt;
            const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
            if (audioRef) {
                audioRef.currentTime = offset;
                audioRef.play();
                this.startedAt = audioRef.currentTime - offset;
                this.pausedAt = 0;
                this.playing = true;
            }
        };
        this.clearAnimationFrame = () => { };
        const { audioNode, events } = props;
        this.audioNode = audioNode;
        this.startedAt = 0;
        this.pausedAt = 0;
        this.events = events;
        const audioRef = (_a = this.audioNode) === null || _a === void 0 ? void 0 : _a.current;
        if (audioRef) {
            audioRef.onloadedmetadata = this.onLoadedMetadata;
            audioRef.ontimeupdate = this.onTimeUpdate;
            audioRef.onended = this.onEnded;
        }
    }
}
//# sourceMappingURL=HTML5AudioWrapper.js.map