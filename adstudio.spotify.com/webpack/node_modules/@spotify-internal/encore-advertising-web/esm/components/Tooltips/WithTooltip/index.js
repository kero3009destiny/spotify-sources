var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import { Tooltip, TooltipTrigger } from '@spotify-internal/encore-web';
import styled, { css } from 'styled-components';
import { uniqueId } from 'lodash';
const StyledTooltip = styled(Tooltip) `
  pointer-events: auto;
  white-space: normal;
  ${props => props.width &&
    css `
      min-width: ${props.width};
    `}
`;
const mountedInstances = {};
const tooltipOverlayPrefix = 'withTooltipOverlay-';
const WithTooltipComponent = (_a) => {
    var { className, open, content, placement = TooltipTrigger.right, overlay, withPortal, width, style, onShow, onHide, children } = _a, props = __rest(_a, ["className", "open", "content", "placement", "overlay", "withPortal", "width", "style", "onShow", "onHide", "children"]);
    const [showTooltip, setShowTooltip] = React.useState(false);
    const tooltipId = React.useRef(uniqueId(tooltipOverlayPrefix));
    const hide = React.useCallback((e) => {
        setShowTooltip(false);
        onHide === null || onHide === void 0 ? void 0 : onHide(e);
    }, [onHide]);
    const show = React.useCallback((e) => {
        setShowTooltip(true);
        onShow === null || onShow === void 0 ? void 0 : onShow(e);
    }, [onShow]);
    React.useEffect(() => {
        const id = tooltipId.current;
        mountedInstances[id] = { hide };
        return () => {
            delete mountedInstances[id];
        };
    }, [hide, show, tooltipId]);
    let timeoutId = null;
    const handleOnHide = (e) => {
        var _a, _b;
        (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.persist) === null || _b === void 0 ? void 0 : _b.call(_a);
        timeoutId = window.setTimeout(() => {
            hide(e);
        }, 150);
    };
    const handleOnShow = (e) => {
        var _a, _b;
        (_b = (_a = e) === null || _a === void 0 ? void 0 : _a.persist) === null || _b === void 0 ? void 0 : _b.call(_a);
        document
            .querySelectorAll(`[id^="${tooltipOverlayPrefix}"]`)
            .forEach(overlayInstance => {
            var _a;
            (_a = mountedInstances[overlayInstance.id]) === null || _a === void 0 ? void 0 : _a.hide();
        });
        show(e);
        if (timeoutId) {
            window.clearTimeout(timeoutId);
            timeoutId = null;
        }
    };
    React.useEffect(() => {
        return () => {
            if (timeoutId) {
                window.clearTimeout(timeoutId);
            }
        };
    }, [timeoutId]);
    return (React.createElement(TooltipTrigger, { style: { display: 'unset', width: 'fit-content' }, className: className, placement: placement, withPortal: withPortal, overlay: (open !== null && open !== void 0 ? open : showTooltip) &&
            (overlay !== null && overlay !== void 0 ? overlay : (content && (React.createElement(StyledTooltip, Object.assign({ id: tooltipId.current, width: width, onMouseEnter: handleOnShow, onMouseLeave: handleOnHide, onClick: e => e.stopPropagation(), style: style }, props), content)))), onShow: e => handleOnShow(e), onHide: e => handleOnHide(e) }, children));
};
export const withTooltipHelpers = Object.assign({}, TooltipTrigger);
export const WithTooltip = Object.assign(WithTooltipComponent, withTooltipHelpers);
//# sourceMappingURL=index.js.map