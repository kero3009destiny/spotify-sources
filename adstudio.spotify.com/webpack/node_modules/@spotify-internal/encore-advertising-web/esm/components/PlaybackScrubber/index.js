var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { gray90, white, white30 } from '@spotify-internal/encore-web';
import React from 'react';
import styled, { css } from 'styled-components';
import { plum } from '../../styles/colors';
const TRACK_HEIGHT = '4px';
const TRACK_BORDER_RADIUS = '2px';
const colors = (overMedia) => ({
    fillColor: overMedia ? white : plum,
    backgroundColor: overMedia ? white30 : gray90,
});
const PlaybackScrubberContainer = styled.div `
  position: relative;
  height: ${TRACK_HEIGHT};
  width: 100%;
`;
const StyledPlaybackInput = styled.input `
  -webkit-appearance: none;
  cursor: pointer;
  position: absolute;
  margin: 0;
  z-index: 1;
  width: 100%;
  height: 100%;
  background: transparent;
  border: none;
  outline: none;

  &:disabled {
    cursor: not-allowed;
  }

  /* Unsure why thumb pseudo elements cant be combined */
  &::-webkit-slider-thumb {
    visibility: hidden;
  }
  &::-moz-range-thumb {
    visibility: hidden;
  }
  &::-ms-thumb {
    visibility: hidden;
  }

  &::-ms-ticks-after,
  &::-ms-ticks-before,
  &::-ms-tooltip {
    display: none;
  }
`;
const TrackStyles = css `
  position: absolute;
  width: 100%;
  height: 100%;
  overflow: hidden;
  min-width: 4px;
  border-radius: ${TRACK_BORDER_RADIUS};
  transition: opacity 0.2s;
  opacity: 1;
  ${PlaybackScrubberContainer}:hover & {
    opacity: 0.8;
  }
`;
const TrackBackground = styled.div `
  ${TrackStyles}
  background: ${props => colors(props.overMedia).backgroundColor};
`;
const TrackFill = styled.div `
  ${TrackStyles}
  background: ${props => colors(props.overMedia).fillColor};
  width: ${props => `${props.percentageFilled * 100}%`};
`;
export const PlaybackScrubber = (_a) => {
    var { className, time = 0, duration, step, overMedia, onScrub } = _a, inputProps = __rest(_a, ["className", "time", "duration", "step", "overMedia", "onScrub"]);
    const fixedDuration = !duration || duration <= 0 ? 1 : duration;
    const fixedStep = !step || step <= 0 ? fixedDuration / 100 : step;
    return (React.createElement(PlaybackScrubberContainer, { className: className },
        React.createElement(StyledPlaybackInput, Object.assign({ "data-testid": "scrubber-control", type: "range", min: 0, step: fixedStep, max: fixedDuration, value: time, onChange: e => {
                const changedValue = Number(e.currentTarget.value);
                onScrub === null || onScrub === void 0 ? void 0 : onScrub(changedValue);
            } }, inputProps)),
        React.createElement(TrackBackground, { overMedia: overMedia }),
        React.createElement(TrackFill, { percentageFilled: time / fixedDuration, overMedia: overMedia })));
};
//# sourceMappingURL=index.js.map