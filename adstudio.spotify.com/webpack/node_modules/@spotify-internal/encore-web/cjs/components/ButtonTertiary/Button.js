"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Button = void 0;

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireDefault(require("react"));

var _styledComponents = _interopRequireWildcard(require("styled-components"));

var _styles = require("../../styles");

var _typeHelpers = require("../../typeHelpers");

var _excluded = ["component", "semanticColor", "condensed", "condensedAll", "iconLeading", "iconTrailing", "iconOnly", "buttonSize", "iconSize", "hover", "active", "focus", "isUsingKeyboard", "useBrowserDefaultFocusStyle", "status"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Button = (0, _styledComponents["default"])( /*#__PURE__*/_react["default"].forwardRef(function (_ref, ref) {
  var _ref$component = _ref.component,
      Component = _ref$component === void 0 ? 'button' : _ref$component,
      semanticColor = _ref.semanticColor,
      condensed = _ref.condensed,
      condensedAll = _ref.condensedAll,
      iconLeading = _ref.iconLeading,
      iconTrailing = _ref.iconTrailing,
      iconOnly = _ref.iconOnly,
      buttonSize = _ref.buttonSize,
      iconSize = _ref.iconSize,
      hover = _ref.hover,
      active = _ref.active,
      focus = _ref.focus,
      isUsingKeyboard = _ref.isUsingKeyboard,
      useBrowserDefaultFocusStyle = _ref.useBrowserDefaultFocusStyle,
      status = _ref.status,
      props = (0, _objectWithoutProperties2["default"])(_ref, _excluded);
  return /*#__PURE__*/_react["default"].createElement(Component, Object.assign({}, props, {
    ref: ref
  }));
})).withConfig({
  displayName: "Button",
  componentId: "sc-1dqy6lx-0"
})(["", ""], function (_ref2) {
  var buttonSize = _ref2.buttonSize,
      _ref2$semanticColor = _ref2.semanticColor,
      semanticColor = _ref2$semanticColor === void 0 ? 'textSubdued' : _ref2$semanticColor,
      hover = _ref2.hover,
      active = _ref2.active,
      focus = _ref2.focus,
      useBrowserDefaultFocusStyle = _ref2.useBrowserDefaultFocusStyle,
      status = _ref2.status,
      isUsingKeyboard = _ref2.isUsingKeyboard,
      condensed = _ref2.condensed,
      condensedAll = _ref2.condensedAll,
      iconLeading = _ref2.iconLeading,
      iconTrailing = _ref2.iconTrailing,
      iconOnly = _ref2.iconOnly,
      iconSize = _ref2.iconSize;

  var _getButtonPaddingValu = (0, _styles.getButtonPaddingValues)(buttonSize),
      paddingTopBottom = _getButtonPaddingValu.paddingTopBottom,
      paddingLeftRight = _getButtonPaddingValu.paddingLeftRight;
  /**
   * Since the icons here are not absolute position and the icon size and font size are mismatched for 'md' buttons,
   * we have to account for the extra height added by the icons.
   * TODO: This logic will be removed once we align with mobile font size for buttons.
   */


  var mdIconBtnPaddingTopBottomComp = buttonSize === 'md' && (iconLeading || iconTrailing) ? -2 : 0;
  var paddingTopBottomComp = "".concat((0, _typeHelpers.pxToInt)(paddingTopBottom) + mdIconBtnPaddingTopBottomComp, "px");
  var withIconPaddingLeftRight = _styles.buttonWithIconSidePadding[buttonSize];
  var iconOnlyPadding = "".concat(((0, _typeHelpers.pxToInt)(_styles.buttonHeightMinimum[buttonSize]) - (0, _typeHelpers.pxToInt)(iconSize)) / 2, "px");
  var paddingStyles = (0, _styledComponents.css)(["", " ", " ", " ", " ", ""], !condensedAll && (0, _styledComponents.css)(["padding-top:", ";padding-bottom:", ";"], iconOnly ? iconOnlyPadding : paddingTopBottomComp, iconOnly ? iconOnlyPadding : paddingTopBottomComp), condensedAll && (0, _styledComponents.css)(["padding:0;"]), condensed && (0, _styledComponents.css)(["padding-left:0;padding-right:0;"]), !condensed && !condensedAll && !iconOnly && (0, _styledComponents.css)(["padding-left:", ";padding-right:", ";[dir='rtl'] &{padding-right:", ";padding-left:", ";}"], iconLeading ? withIconPaddingLeftRight : paddingLeftRight, iconTrailing ? withIconPaddingLeftRight : paddingLeftRight, iconLeading ? withIconPaddingLeftRight : paddingLeftRight, iconTrailing ? withIconPaddingLeftRight : paddingLeftRight), !condensed && !condensedAll && iconOnly && (0, _styledComponents.css)(["padding-left:", ";padding-right:", ";"], iconOnlyPadding, iconOnlyPadding));
  var hoverStyles = (0, _styledComponents.css)(["", " ", ""], _styles.buttonStylesHover, semanticColor === 'textSubdued' && (0, _styledComponents.css)(["color:", ";"], (0, _styles.cssColorValue)(_styles.semanticColors.textBase)));
  var activeStyles = (0, _styledComponents.css)(["", " color:", ";"], _styles.buttonStylesActive, (0, _styles.cssColorValue)(_styles.semanticColors.textSubdued));
  var disabledStyles = (0, _styledComponents.css)(["", " color:", ";&::before{background-color:transparent;}&::after{border-color:transparent;}"], _styles.buttonStylesDisabled, (0, _styles.cssColorValue)(_styles.semanticColors.textSubdued));

  var focusStyles = function focusStyles() {
    var focusBorderBase = (condensedAll ? 0 : (0, _typeHelpers.pxToInt)(paddingTopBottomComp)) + _styles.focusBorderWidth;
    var focusBorderLength = iconOnly ? iconSize : "calc(100% - ".concat(condensed || condensedAll ? 0 : (iconLeading || iconTrailing ? (0, _typeHelpers.pxToInt)(withIconPaddingLeftRight) : (0, _typeHelpers.pxToInt)(paddingLeftRight)) * 2, "px)");
    return (0, _styledComponents.css)(["", ";&::after{width:", ";}"], !useBrowserDefaultFocusStyle && (0, _styles.focusBottomBorder)(focusBorderBase, isUsingKeyboard, focus), focusBorderLength);
  };

  return (0, _styledComponents.css)(["", " color:", ";", ";", " &:hover{", "}", " &:active{", "}", " ", " &[disabled],&[aria-disabled='true'],fieldset[disabled] &{", "}"], (0, _styles.buttonStylesBase)(buttonSize, useBrowserDefaultFocusStyle, status), (0, _styles.cssColorValue)(semanticColor), paddingStyles, (iconLeading || iconTrailing) && (0, _styledComponents.css)(["display:inline-flex;align-items:center;justify-content:center;"]), hoverStyles, hover && hoverStyles, activeStyles, active && activeStyles, focusStyles, disabledStyles);
});
exports.Button = Button;