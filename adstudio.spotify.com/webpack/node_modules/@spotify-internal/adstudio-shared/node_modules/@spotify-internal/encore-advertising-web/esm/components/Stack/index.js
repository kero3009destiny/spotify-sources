var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React from 'react';
import styled, { css } from 'styled-components';
import { flexOverrides } from '../../utils/helpers/styleOverrides';
import { spacer24, spacer16, gray90, } from '@spotify-internal/encore-foundation';
import { HorizontalRule } from '@spotify-internal/encore-web';
const StackWrapper = styled.div `
  flex: 1;
`;
const StackItemList = styled.div `
  ${({ direction, gap, rowGap = gap, columnGap = gap, $wrap, reverse }) => css `
    display: flex;
    flex-wrap: ${$wrap ? 'wrap' : 'nowrap'};
    flex-direction: ${getDirection(direction, reverse)};
    align-items: ${direction === 'vertical' ? 'stretch' : 'center'};
    max-width: 100%;
    max-height: 100%;
    column-gap: ${columnGap};
    row-gap: ${rowGap};
    && {
      ${flexOverrides}
    }
  `}
`;
const StackItem = styled.div `
  display: flex;
  align-items: flex-start;
  &:empty {
    display: none;
  }
  && {
    ${flexOverrides}
  }
`;
export const Stack = (_a) => {
    var { className, direction = 'vertical', gap = spacer24, wrap, withDividers, divider: dividerProp, children } = _a, flexProps = __rest(_a, ["className", "direction", "gap", "wrap", "withDividers", "divider", "children"]);
    const divider = dividerProp !== null && dividerProp !== void 0 ? dividerProp : getDefaultDivider(direction);
    const childrenToRender = withDividers
        ? getChildrenWithDividers(children, divider)
        : children;
    return (React.createElement(StackWrapper, { className: className },
        React.createElement(StackItemList, Object.assign({ direction: direction, gap: gap, "$wrap": wrap }, flexProps), childrenToRender)));
};
export const VStack = styled(Stack).attrs({ direction: 'vertical' }) ``;
export const HStack = styled(Stack).attrs({ direction: 'horizontal' }) ``;
Stack.Item = StackItem;
VStack.Item = StackItem;
HStack.Item = StackItem;
const HorizontalDivider = styled(HorizontalRule) `
  width: 100%;
  margin: 0;
  border-color: ${gray90};
`;
const VerticalDivider = styled.div `
  border-left: 1px solid ${gray90};
  height: ${spacer16};
`;
function getDirection(direction, reverse) {
    const suffix = reverse ? '-reverse' : '';
    const flexDirection = direction === 'vertical' ? 'column' : 'row';
    return `${flexDirection}${suffix}`;
}
function getDefaultDivider(direction) {
    if (direction === 'vertical')
        return React.createElement(HorizontalDivider, null);
    return React.createElement(VerticalDivider, null);
}
function getChildrenWithDividers(children, divider) {
    return React.Children.map(children, (child, i) => {
        if (i === React.Children.count(children) - 1)
            return child;
        return (React.createElement(React.Fragment, null,
            child,
            divider));
    });
}
//# sourceMappingURL=index.js.map