"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = webgateFetch;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _debug = _interopRequireDefault(require("debug"));

var _global = require("global");

var _getToken = _interopRequireDefault(require("./getToken"));

var _tokenCache = require("./tokenCache");

var _constants = require("./constants");

var log = (0, _debug["default"])('webgateToken:fetch');
/**
 * we want the control to handle 4xx and 5xx explicitly per API method,
 * but our general network error handling can be shared by the old webgate
 * and any new stuff.
 */

function handleNetworkError(err) {
  var message = err.message;

  if (typeof _global.navigator !== 'undefined' && !_global.navigator.onLine) {
    message = _constants.OFFLINE_ERROR_MESSAGE;
  } else if (message && message.indexOf('Failed to fetch') !== -1) {
    message = _constants.NETWORK_ERROR_MESSAGE;
  }

  var error = new Error(message); // Avoids the 'Error:' prefix for the displayed error message

  error.toString = function () {
    return message;
  };

  throw error;
}
/**
 * the main method that accesses the cached token or blocks loading to fetch
 * one, makes a request, and refreshes the token if it is found to be invalid.
 * @param {string} url - full URL to pass to fetch
 * @param {Object} options - options object to pass to fetch
 * @param {boolean} shouldRetry - flag to be used by the auth token refresh logic
 */


function _webgateFetch(_x) {
  return _webgateFetch2.apply(this, arguments);
}
/**
 * perform a whatwg-fetch with Webgate tokens fetched, cached, and refreshed
 * when appropriate in the background.
 * @param {string} url - full URL to pass to fetch
 * @param {Object} options - options object to pass to fetch
 */


function _webgateFetch2() {
  _webgateFetch2 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee(url) {
    var options,
        shouldRetry,
        _options$body,
        body,
        _options$method,
        method,
        headers,
        wgToken,
        defaultOpts,
        fetchOpts,
        res,
        _args = arguments;

    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            shouldRetry = _args.length > 2 ? _args[2] : undefined;
            _options$body = options.body, body = _options$body === void 0 ? '' : _options$body, _options$method = options.method, method = _options$method === void 0 ? 'GET' : _options$method;
            log('%s %s %s', method, url, body);
            headers = new _global.Headers();
            _context.prev = 5;
            _context.next = 8;
            return (0, _getToken["default"])();

          case 8:
            wgToken = _context.sent;
            _context.next = 15;
            break;

          case 11:
            _context.prev = 11;
            _context.t0 = _context["catch"](5);
            log('failed to get webgate token', _context.t0);
            handleNetworkError(_context.t0);

          case 15:
            if (wgToken) {
              headers.append('Authorization', "Bearer ".concat(wgToken));
            }

            defaultOpts = {
              mode: 'cors',
              method: method,
              headers: headers
            };
            fetchOpts = method.toUpperCase() === 'GET' ? defaultOpts : (0, _objectSpread2["default"])({}, defaultOpts, {
              body: body
            });
            _context.prev = 18;
            _context.next = 21;
            return (0, _global.fetch)(url, fetchOpts);

          case 21:
            res = _context.sent;
            _context.next = 27;
            break;

          case 24:
            _context.prev = 24;
            _context.t1 = _context["catch"](18);
            handleNetworkError(_context.t1);

          case 27:
            if (!(res.status === 401)) {
              _context.next = 35;
              break;
            }

            if (shouldRetry) {
              _context.next = 30;
              break;
            }

            throw res;

          case 30:
            log('refreshing webgate token and retrying');
            (0, _tokenCache.removeCachedWebgateToken)();
            _context.next = 34;
            return _webgateFetch(url, options, false);

          case 34:
            return _context.abrupt("return", _context.sent);

          case 35:
            if (!(res.status >= _constants.THROW_ABOVE_STATUS_CODE)) {
              _context.next = 37;
              break;
            }

            throw res;

          case 37:
            return _context.abrupt("return", res);

          case 38:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[5, 11], [18, 24]]);
  }));
  return _webgateFetch2.apply(this, arguments);
}

function webgateFetch(_x2, _x3) {
  return _webgateFetch3.apply(this, arguments);
}

function _webgateFetch3() {
  _webgateFetch3 = (0, _asyncToGenerator2["default"])(
  /*#__PURE__*/
  _regenerator["default"].mark(function _callee2(url, options) {
    return _regenerator["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", _webgateFetch(url, options, true));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _webgateFetch3.apply(this, arguments);
}
//# sourceMappingURL=fetch.js.map