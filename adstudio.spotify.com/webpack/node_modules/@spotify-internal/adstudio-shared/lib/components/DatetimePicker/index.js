"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DatetimePicker = DatetimePicker;
exports["default"] = exports.handlers = void 0;

var _get2 = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _moment = _interopRequireDefault(require("moment"));

require("moment/min/locales");

var _recompose = require("recompose");

require("react-dates/initialize");

var _reactDates = require("react-dates");

var _isInclusivelyBeforeDay = _interopRequireDefault(require("react-dates/lib/utils/isInclusivelyBeforeDay"));

var _isInclusivelyAfterDay = _interopRequireDefault(require("react-dates/lib/utils/isInclusivelyAfterDay"));

var _constants = require("react-dates/constants");

var _adstudioTape = require("@spotify-internal/adstudio-tape");

var _encoreAdvertisingWeb = require("@spotify-internal/encore-advertising-web");

var _styledComponents = _interopRequireDefault(require("styled-components"));

var _globalStyle = _interopRequireDefault(require("./globalStyle"));

var _timeHelpers = require("../../utils/timeHelpers");

var _TimePicker = _interopRequireDefault(require("./TimePicker"));

require("!style-loader!css-loader!react-dates/lib/css/_datepicker.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Container = _styledComponents["default"].div.withConfig({
  displayName: "DatetimePicker__Container",
  componentId: "sc-1lghd3d-0"
})([""]);

var Label = (0, _styledComponents["default"])(_encoreAdvertisingWeb.Type).withConfig({
  displayName: "DatetimePicker__Label",
  componentId: "sc-1lghd3d-1"
})(["", " padding-bottom:", ";"], function (props) {
  return "color: ".concat(props.error ? _encoreAdvertisingWeb.failure : _encoreAdvertisingWeb.black, ";");
}, _encoreAdvertisingWeb.spacer4);

var LayoutContainer = _styledComponents["default"].div.withConfig({
  displayName: "DatetimePicker__LayoutContainer",
  componentId: "sc-1lghd3d-2"
})(["display:grid;grid-template-columns:130px 130px;grid-gap:70px;"]);

var CustomArrow = _styledComponents["default"].span.withConfig({
  displayName: "DatetimePicker__CustomArrow",
  componentId: "sc-1lghd3d-3"
})(["background-color:", ";display:inline-block;padding:10px 26px;width:70px;"], _encoreAdvertisingWeb.white);

var shouldDisable = function shouldDisable(disabled, input) {
  return disabled === input || disabled === true;
};

function DatetimePicker(_ref) {
  var blockDateRange = _ref.blockDateRange,
      countryCode = _ref.countryCode,
      disabled = _ref.disabled,
      error = _ref.error,
      focusedInput = _ref.focusedInput,
      handleTimeChange = _ref.handleTimeChange,
      handleDateChange = _ref.handleDateChange,
      isOutsideRange = _ref.isOutsideRange,
      openDirection = _ref.openDirection,
      setFocusedInput = _ref.setFocusedInput,
      value = _ref.value,
      tooltipText = _ref.tooltipText,
      tooltipPlacement = _ref.tooltipPlacement,
      startText = _ref.startText,
      endText = _ref.endText;

  _moment["default"].locale(countryCode); // we use `get` here to protect ourselves from an undefined value.
  // by default, this will use the current date and time via `moment(undefined)`


  var startDate = (0, _moment["default"])((0, _get2["default"])(value, 'begin'));
  var endDate = (0, _moment["default"])((0, _get2["default"])(value, 'end'));
  var dateRangeFn = isOutsideRange ? isOutsideRange : blockDateRange;
  var use24HourTime = (0, _timeHelpers.countryHas24HourTime)(countryCode);
  var timeMaximums = (0, _timeHelpers.getTimeMaximums)(use24HourTime); // todo: we should migrate this whole thing to an Encore-style formgroup

  return /*#__PURE__*/_react["default"].createElement(Container, null, /*#__PURE__*/_react["default"].createElement(LayoutContainer, null, /*#__PURE__*/_react["default"].createElement(Label, {
    error: error,
    htmlFor: "".concat(name, "-start-date"),
    variant: _encoreAdvertisingWeb.Type.body2,
    weight: _encoreAdvertisingWeb.Type.bold
  }, /*#__PURE__*/_react["default"].createElement(_adstudioTape.TooltipInfo, {
    placement: tooltipPlacement,
    tooltipText: tooltipText
  }, startText)), /*#__PURE__*/_react["default"].createElement(Label, {
    error: error,
    htmlFor: "".concat(name, "-end-date"),
    variant: _encoreAdvertisingWeb.Type.body2,
    weight: _encoreAdvertisingWeb.Type.bold
  }, endText)), /*#__PURE__*/_react["default"].createElement(_reactDates.DateRangePicker, {
    anchorDirection: _constants.ANCHOR_LEFT,
    customArrowIcon: /*#__PURE__*/_react["default"].createElement(CustomArrow, null, "\u2014"),
    disabled: disabled,
    endDate: endDate,
    endDateId: "".concat(name, "-end-date"),
    focusedInput: focusedInput,
    hideKeyboardShortcutsPanel: true,
    isOutsideRange: dateRangeFn,
    minimumNights: 0,
    onDatesChange: handleDateChange,
    onFocusChange: setFocusedInput,
    openDirection: openDirection,
    startDate: startDate,
    startDateId: "".concat(name, "-start-date")
  }), /*#__PURE__*/_react["default"].createElement(LayoutContainer, null, /*#__PURE__*/_react["default"].createElement(_TimePicker["default"], {
    disabled: shouldDisable(disabled, _constants.START_DATE),
    error: error,
    onChange: function onChange(newValue) {
      return handleTimeChange('begin', newValue);
    },
    timeMaximums: timeMaximums,
    value: (0, _timeHelpers.getTimePickerValues)(startDate, use24HourTime)
  }), /*#__PURE__*/_react["default"].createElement(_TimePicker["default"], {
    disabled: shouldDisable(disabled, _constants.END_DATE),
    error: error,
    onChange: function onChange(newValue) {
      return handleTimeChange('end', newValue);
    },
    timeMaximums: timeMaximums,
    value: (0, _timeHelpers.getTimePickerValues)(endDate, use24HourTime)
  })), /*#__PURE__*/_react["default"].createElement(_globalStyle["default"], {
    error: error,
    override: Container
  }));
}

DatetimePicker.propTypes = {
  blockDateRange: _propTypes["default"].func.isRequired,
  countryCode: _propTypes["default"].string.isRequired,
  disabled: _propTypes["default"].oneOfType([_propTypes["default"].bool, _propTypes["default"].oneOf([_constants.START_DATE, _constants.END_DATE])]),
  endText: _propTypes["default"].string,
  error: _propTypes["default"].oneOfType([_propTypes["default"].node, _propTypes["default"].bool]),
  focusedInput: _propTypes["default"].string,
  handleDateChange: _propTypes["default"].func.isRequired,
  handleTimeChange: _propTypes["default"].func.isRequired,
  isOutsideRange: _propTypes["default"].func,
  openDirection: _propTypes["default"].string,
  setFocusedInput: _propTypes["default"].func.isRequired,
  startText: _propTypes["default"].string,
  tooltipPlacement: _propTypes["default"].string,
  tooltipText: _propTypes["default"].string,
  value: _propTypes["default"].shape({
    begin: _propTypes["default"].string,
    end: _propTypes["default"].string
  })
};
DatetimePicker.defaultProps = {
  tooltipPlacement: 'left',
  tooltipText: "Your ad will start after it's approved, which may be after your start date. All times are set in your local time zone.",
  startText: 'Start',
  endText: 'End',
  countryCode: 'en-US'
};
var handlers = {
  blockDateRange: function blockDateRange(_ref2) {
    var focusedInput = _ref2.focusedInput,
        value = _ref2.value;
    return function (day) {
      var begin = value ? value.begin : undefined;
      var startDate = (0, _moment["default"])(begin);
      var isOutsideRange = false;

      if (focusedInput === _constants.END_DATE) {
        // Blocks dates 365 days after selected start date
        isOutsideRange = (0, _isInclusivelyAfterDay["default"])(day, startDate.add(365, 'days'));
      } // Blocks days before today and 1 year from start date


      return isOutsideRange || (0, _isInclusivelyBeforeDay["default"])(day, (0, _moment["default"])().subtract(1, 'days')) || (0, _isInclusivelyAfterDay["default"])(day, startDate.add(1, 'years').add(1, 'days'));
    };
  },
  handleDateChange: function handleDateChange(_ref3) {
    var prevValue = _ref3.value,
        onChange = _ref3.onChange;
    return function (newDateRange) {
      var startDate = newDateRange.startDate,
          endDate = newDateRange.endDate;

      var newState = _objectSpread({}, prevValue);

      var startDateChanged = startDate ? !startDate.isSame((0, _get2["default"])(prevValue, 'begin')) : false; // Case when dates set and start date is set before previous start date
      // reset end date to 180 days from new start date

      if (endDate && endDate.diff(startDate, 'days') > 365) {
        endDate = (0, _timeHelpers.getNDaysFromDay)(365, startDate);
      } // Case when user selects new start date after current selected end date


      if (startDate && startDateChanged && startDate.isAfter((0, _get2["default"])(prevValue, 'end'))) {
        endDate = (0, _timeHelpers.setEndOfDay)(startDate);
        newState.end = endDate;
      }

      if (startDate && startDateChanged) {
        startDate = (0, _timeHelpers.convertToTimestamp)((0, _timeHelpers.keepTimeFromOldDate)(startDate, (0, _get2["default"])(prevValue, 'begin')));
        newState.begin = startDate;
      }

      if (endDate && !endDate.isSame((0, _get2["default"])(prevValue, 'end'))) {
        var newEndDate = (0, _timeHelpers.convertToTimestamp)((0, _timeHelpers.keepTimeFromOldDate)(endDate, (0, _get2["default"])(prevValue, 'end')));
        newState.end = newEndDate;
      }

      onChange(newState);
    };
  },
  handleTimeChange: function handleTimeChange(_ref4) {
    var prevValue = _ref4.value,
        onChange = _ref4.onChange;
    return function (which, time) {
      return onChange(_objectSpread(_objectSpread({}, prevValue), {}, _defineProperty({}, which, (0, _timeHelpers.replaceTimeInTimestamp)((0, _get2["default"])(prevValue, which), time))));
    };
  }
};
exports.handlers = handlers;

var _default = (0, _recompose.compose)((0, _recompose.withState)('focusedInput', 'setFocusedInput', null), (0, _recompose.withHandlers)(handlers))(DatetimePicker);

exports["default"] = _default;