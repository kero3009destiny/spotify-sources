"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.atLeastOneTrueValue = atLeastOneTrueValue;
exports.locationsFromSameCountry = locationsFromSameCountry;
exports.onlyCountryOrLocation = onlyCountryOrLocation;
exports.combinedLocationValidatorCustomField = exports.deprecatedGeosValidator = exports.locationByCountryValidator = exports.numericStringBelow = exports.numericStringAbove = exports.numericStringBetween = exports.withCustomMessage = void 0;

var _memoize2 = _interopRequireDefault(require("lodash/memoize"));

var _isObject2 = _interopRequireDefault(require("lodash/isObject"));

var _formatNumber = _interopRequireDefault(require("format-number"));

var _validators = require("@spotify-internal/adstudio-web-utils/lib/validators");

var _currency = require("@spotify-internal/adstudio-web-utils/lib/utils/currency");

var _get = _interopRequireDefault(require("lodash/get"));

var _deprecatedGeoHelpers = require("./deprecatedGeoHelpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// helper for wrapping any other validator in a custom message
// to override the default
// FIXME(ADSD-869): There have been cases where message is undefined. We should
//        solve for that, but this at least enables the validation
//        to properly flag an error and prevent submission.
var _withCustomMessage = function _withCustomMessage(validator, message) {
  return function (value, formValues) {
    var originalErrorMessage = validator(value, formValues);

    if (originalErrorMessage && message) {
      return message;
    } else if (originalErrorMessage) {
      return originalErrorMessage;
    }
  };
};

var withCustomMessage = (0, _memoize2["default"])(_withCustomMessage, function (validator, message, cacheKeyExtension) {
  if (cacheKeyExtension) {
    return "".concat(message, "-").concat(cacheKeyExtension);
  }

  return message;
});
exports.withCustomMessage = withCustomMessage;

function atLeastOneTrueValue(value) {
  if (!(0, _isObject2["default"])(value)) {
    throw new Error('"value" is not an object');
  }

  var atLeastOneValueIsTrue = Object.keys(value).some(function (k) {
    return value[k];
  });

  if (!atLeastOneValueIsTrue) {
    return 'Please select at least one value.';
  }
}

var _numericStringBetween = function _numericStringBetween(min, max) {
  var numberFormatter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _formatNumber["default"];
  return function (value) {
    // first, check that the value provided is actually a numeric string.
    var numericStringError = (0, _validators.numericString)(value);

    if (numericStringError) {
      return numericStringError;
    } // turn the string into a number


    var number = (0, _currency.getNumberFromCurrencyString)(value);

    if (typeof min === 'number' && min > number) {
      return "Amount must be ".concat(numberFormatter(min), " or more");
    }

    if (typeof max === 'number' && max < number) {
      return "Amount must be ".concat(numberFormatter(max), " or less");
    }
  };
};

var numericStringBetween = (0, _memoize2["default"])(_numericStringBetween, function (min, max) {
  return "".concat(min, "/").concat(max);
}); // sugar that just relies on numericStringBetween. these could have their own
// impls for performance reasons later.

exports.numericStringBetween = numericStringBetween;
var numericStringAbove = (0, _memoize2["default"])(function (min) {
  var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'USD';
  return _numericStringBetween(min, null, currency);
});
exports.numericStringAbove = numericStringAbove;
var numericStringBelow = (0, _memoize2["default"])(function (max) {
  var currency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'USD';
  return _numericStringBetween(null, max, currency);
});
exports.numericStringBelow = numericStringBelow;

function locationsFromSameCountry(targetedLocations) {
  var locationsAreFromSameCountry = targetedLocations.every(function (location) {
    return targetedLocations[0].countryCode === location.countryCode;
  });

  if (!locationsAreFromSameCountry) {
    return 'You can only target one country per ad.';
  }
}

function onlyCountryOrLocation(targetedLocations) {
  var hasCountry = targetedLocations.some(function (location) {
    var geoType = location.type || location.geoType;
    return geoType === 'COUNTRY';
  });
  var hasLocations = targetedLocations.some(function (location) {
    var geoType = location.type || location.geoType;
    return geoType !== 'COUNTRY';
  });

  if (hasCountry && hasLocations) {
    return 'You can only target one country or locations, not both.';
  }

  return;
}

var locationRequired = withCustomMessage(_validators.required, 'Please select at least one location.');

var locationByCountryValidator = function locationByCountryValidator(value, formValues) {
  if (formValues && formValues.targeting && formValues.targeting.targetWholeCountry) return;
  return locationRequired(value);
};

exports.locationByCountryValidator = locationByCountryValidator;

var deprecatedGeosValidator = function deprecatedGeosValidator(value) {
  if ((0, _deprecatedGeoHelpers.hasDeprecatedGeos)(value)) {
    return 'Please remove any unavailable locations.';
  }

  return;
};

exports.deprecatedGeosValidator = deprecatedGeosValidator;

var combinedLocationValidatorCustomField = function combinedLocationValidatorCustomField(formValueKey) {
  return function (value, formValues) {
    if ((0, _get["default"])(formValues, formValueKey)) return;

    if ((0, _deprecatedGeoHelpers.hasDeprecatedGeos)(value)) {
      return 'Please remove any unavailable locations.';
    }

    return locationRequired(value, formValues);
  };
};

exports.combinedLocationValidatorCustomField = combinedLocationValidatorCustomField;