import _intlMessageformat from "intl-messageformat";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

/**
 * Stores a mapping of localized strings. Can be used to find the
 * closest available string for a given locale.
 */
export class MessageDictionary {
  constructor(messages, defaultLocale) {
    if (defaultLocale === void 0) {
      defaultLocale = 'en-US';
    }

    this.messages = void 0;
    this.defaultLocale = void 0;
    // Clone messages so we don't modify the original object.
    this.messages = _babelRuntimeHelpersEsmExtends({}, messages);
    this.defaultLocale = defaultLocale;
  }

  getStringForLocale(key, locale) {
    let strings = this.messages[locale];

    if (!strings) {
      strings = $e73469445899f72bd9d935bbafe76d4$var$getStringsForLocale(locale, this.messages, this.defaultLocale);
      this.messages[locale] = strings;
    }

    let string = strings[key];

    if (!string) {
      throw new Error("Could not find intl message " + key + " in " + locale + " locale");
    }

    return string;
  }

}

function $e73469445899f72bd9d935bbafe76d4$var$getStringsForLocale(locale, strings, defaultLocale) {
  if (defaultLocale === void 0) {
    defaultLocale = 'en-US';
  }

  // If there is an exact match, use it.
  if (strings[locale]) {
    return strings[locale];
  } // Attempt to find the closest match by language.
  // For example, if the locale is fr-CA (French Canadian), but there is only
  // an fr-FR (France) set of strings, use that.
  // This could be replaced with Intl.LocaleMatcher once it is supported.
  // https://github.com/tc39/proposal-intl-localematcher


  let language = $e73469445899f72bd9d935bbafe76d4$var$getLanguage(locale);

  for (let key in strings) {
    if (key.startsWith(language + '-')) {
      return strings[key];
    }
  } // Nothing close, use english.


  return strings[defaultLocale];
}

function $e73469445899f72bd9d935bbafe76d4$var$getLanguage(locale) {
  // @ts-ignore
  if (Intl.Locale) {
    // @ts-ignore
    return new Intl.Locale(locale).language;
  }

  return locale.split('-')[0];
}

/**
 * Formats ICU Message strings to create localized strings from a MessageDictionary.
 */
export class MessageFormatter {
  constructor(locale, messages) {
    this.locale = void 0;
    this.messages = void 0;
    this.cache = void 0;
    this.locale = locale;
    this.messages = messages;
    this.cache = {};
  }

  format(key, variables) {
    let message = this.cache[key];

    if (!message) {
      let msg = this.messages.getStringForLocale(key, this.locale);

      if (!msg) {
        throw new Error("Could not find intl message " + key + " in " + this.locale + " locale");
      }

      message = new _intlMessageformat(msg, this.locale);
      this.cache[key] = message;
    }

    return message.format(variables);
  }

}
//# sourceMappingURL=module.js.map
