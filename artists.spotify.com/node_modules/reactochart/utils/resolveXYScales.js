"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveXYScales;

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _compact = _interopRequireDefault(require("lodash/compact"));

var _omitBy = _interopRequireDefault(require("lodash/omitBy"));

var _isUndefined = _interopRequireDefault(require("lodash/isUndefined"));

var _isNull = _interopRequireDefault(require("lodash/isNull"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _inRange = _interopRequireDefault(require("lodash/inRange"));

var _defaults = _interopRequireDefault(require("lodash/defaults"));

var _isNumber = _interopRequireDefault(require("lodash/isNumber"));

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _Data = require("./Data");

var _Margin = require("./Margin");

var _Scale = require("./Scale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * `resolveXYScales` is a higher-order-component.
 *
 * @param {Component} Component - The React Component (class) which should be wrapped by this HOC
 * @returns {Component} - A Component which auto-resolves XY scales from given props
 */
function isValidScaleType(scaleType) {
  const validScaleTypes = ['ordinal', 'time', 'log', 'pow', 'linear'];
  return validScaleTypes.includes(scaleType);
}

function areValidScaleTypes(scaleTypes) {
  return scaleTypes.every(isValidScaleType);
}

function mapOverChildren(children, iteratee, ...iterateeArgs) {
  // loop over all children (react elements) and call iteratee (a function) on each one
  // iteratee is called with parameters (child.props, child.type, ...iterateeArgs)
  if (!(0, _isFunction.default)(iteratee)) throw new Error('mapOverChildren iteratee must be a function');
  return (0, _compact.default)(_react.default.Children.map(children, child => {
    if (!child || ! /*#__PURE__*/_react.default.isValidElement(child)) return null;
    return iteratee(child.props, child.type, ...iterateeArgs);
  }));
}

function omitNullUndefined(obj) {
  return (0, _omitBy.default)(obj, v => (0, _isUndefined.default)(v) || (0, _isNull.default)(v));
}

function resolveXYScales(ComposedComponent) {
  var _class, _temp;

  return _temp = _class = class extends _react.default.Component {
    constructor(...args) {
      super(...args);

      _defineProperty(this, "_makeScales", ({
        width,
        height,
        xScaleType,
        yScaleType,
        invertXScale,
        invertYScale,
        xDomain,
        yDomain,
        xScale,
        yScale,
        marginTop,
        marginBottom,
        marginLeft,
        marginRight,
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      }) => {
        const spacing = {
          top: spacingTop,
          bottom: spacingBottom,
          left: spacingLeft,
          right: spacingRight
        };
        const margin = {
          top: marginTop,
          bottom: marginBottom,
          left: marginLeft,
          right: marginRight
        };
        const innerChartWidth = (0, _Margin.innerWidth)(width, margin);
        const innerChartHeight = (0, _Margin.innerHeight)(height, margin);
        let xScaleResult = xScale;
        let yScaleResult = yScale; // use existing scales if provided, otherwise create new

        if (!(0, _Scale.isValidScale)(xScaleResult)) {
          // innerRange functions produce range (i.e. [5,20]) and map function normalizes to 0 (i.e. [0,15])
          const xRange = (0, _Margin.innerRangeX)(innerChartWidth, spacing).map(v => v - (spacing.left || 0));
          xScaleResult = (0, _Scale.initScale)(xScaleType).domain(xDomain).range(xRange); // reverse scale domain if `invertXScale` is passed

          if (invertXScale) {
            xScaleResult.domain(xScaleResult.domain().reverse());
          }
        }

        if (!(0, _Scale.isValidScale)(yScale)) {
          const yRange = (0, _Margin.innerRangeY)(innerChartHeight, spacing).map(v => v - (spacing.top || 0));
          yScaleResult = (0, _Scale.initScale)(yScaleType).domain(yDomain).range(yRange); // reverse scale domain if `invertYScale` is passed

          if (invertYScale) {
            yScaleResult.domain(yScaleResult.domain().reverse());
          }
        }

        return {
          xScale: xScaleResult,
          yScale: yScaleResult
        };
      });
    }

    _resolveScaleType(props, Component) {
      let {
        xScaleType,
        yScaleType
      } = props;

      const isDone = () => areValidScaleTypes([xScaleType, yScaleType]); // short-circuit if both scale types provided


      if (isDone()) return {
        xScaleType,
        yScaleType
      }; // if Component provides a custom static getScaleType method
      // use it to determine remaining scale types

      if ((0, _isFunction.default)(Component.getScaleType)) {
        const componentScaleTypes = omitNullUndefined(Component.getScaleType(props));
        ({
          xScaleType,
          yScaleType
        } = Object.assign(componentScaleTypes, omitNullUndefined({
          xScaleType,
          yScaleType
        })));
        if (isDone()) return {
          xScaleType,
          yScaleType
        };
      } // if component has domain props,
      // infer the data type, & use that to get scale type


      if (!isValidScaleType(xScaleType) && (0, _Data.isValidDomain)(props.xDomain)) {
        xScaleType = (0, _Scale.scaleTypeFromDataType)((0, _Scale.inferDataTypeFromDomain)(props.xDomain));
      }

      if (!isValidScaleType(yScaleType) && (0, _Data.isValidDomain)(props.yDomain)) {
        yScaleType = (0, _Scale.scaleTypeFromDataType)((0, _Scale.inferDataTypeFromDomain)(props.yDomain));
      }

      if (isDone()) return {
        xScaleType,
        yScaleType
      }; // if Component has data or datasets props,
      // infer the data type, & use that to get scale type

      if (Array.isArray(props.data) || Array.isArray(props.datasets)) {
        const datasets = Array.isArray(props.datasets) ? props.datasets : [props.data];

        if (!isValidScaleType(xScaleType)) {
          xScaleType = (0, _Scale.scaleTypeFromDataType)((0, _Data.inferDatasetsType)(datasets, (0, _Data.makeAccessor2)(props.x)));
        }

        if (!isValidScaleType(yScaleType)) {
          yScaleType = (0, _Scale.scaleTypeFromDataType)((0, _Data.inferDatasetsType)(datasets, (0, _Data.makeAccessor2)(props.y)));
        }

        if (isDone()) return {
          xScaleType,
          yScaleType
        };
      } // if Component has children,
      // recurse through descendants to resolve their scale types the same way


      if (_react.default.Children.count(props.children)) {
        const childrenScaleTypes = mapOverChildren(props.children, this._resolveScaleType.bind(this));

        if (!isValidScaleType(xScaleType)) {
          const childXScaleTypes = (0, _compact.default)((0, _uniq.default)(childrenScaleTypes.map(childScaleTypes => childScaleTypes.xScaleType)));
          if (!childXScaleTypes.length === 1) console.warn("Multiple children with different X scale types found - defaulting to 'ordinal'");
          xScaleType = childXScaleTypes.length === 1 ? childXScaleTypes[0] : 'ordinal';
        }

        if (!isValidScaleType(yScaleType)) {
          const childYScaleTypes = (0, _compact.default)((0, _uniq.default)(childrenScaleTypes.map(childScaleTypes => childScaleTypes.yScaleType)));
          if (!childYScaleTypes.length === 1) console.warn("Multiple children with different Y scale types found - defaulting to 'ordinal'");
          yScaleType = childYScaleTypes.length === 1 ? childYScaleTypes[0] : 'ordinal';
        }
      } // if(!isDone()) console.warn(`resolveXYScales was unable to resolve both scale types. xScaleType: ${xScaleType}, yScaleType: ${yScaleType}`);


      return {
        xScaleType,
        yScaleType
      };
    }

    _resolveDomain(props, Component, xScaleType, yScaleType) {
      let {
        xDomain,
        yDomain
      } = props;
      const {
        includeXZero,
        includeYZero
      } = props;
      const xDataType = (0, _Scale.dataTypeFromScaleType)(xScaleType);
      const yDataType = (0, _Scale.dataTypeFromScaleType)(yScaleType);

      const isXDone = () => (0, _Data.isValidDomain)(xDomain, xDataType);

      const isYDone = () => (0, _Data.isValidDomain)(yDomain, yDataType);

      const isDone = () => isXDone() && isYDone(); // short-circuit if all domains provided


      if (isDone()) return {
        xDomain,
        yDomain
      }; // if Component provides a custom static getScaleType method
      // use it to determine remaining scale types

      if ((0, _isFunction.default)(Component.getDomain)) {
        const {
          xDomain: componentXDomain,
          yDomain: componentYDomain
        } = Component.getDomain(_objectSpread(_objectSpread({}, props), {}, {
          xScaleType,
          yScaleType
        }));
        if (!isXDone() && componentXDomain && !(0, _Data.isValidDomain)(componentXDomain, xDataType)) console.warn(`Component.getDomain returned an invalid domain for data type '${xDataType}': ${componentXDomain} - ignoring`);
        if (!isXDone() && (0, _Data.isValidDomain)(componentXDomain, xDataType)) xDomain = componentXDomain;
        if (!isYDone() && componentYDomain && !(0, _Data.isValidDomain)(componentYDomain, yDataType)) console.warn(`Component.getDomain returned an invalid domain for data type '${yDataType}': ${componentYDomain} - ignoring`);
        if (!isYDone() && (0, _Data.isValidDomain)(componentYDomain, yDataType)) yDomain = componentYDomain;
      } // if Component has data or datasets props,
      // use the default domainFromDatasets function to determine a domain from them


      if (!isDone() && (Array.isArray(props.data) || Array.isArray(props.datasets))) {
        const datasets = Array.isArray(props.datasets) ? props.datasets : [props.data];

        if (!isXDone()) {
          xDomain = (0, _Data.domainFromDatasets)(datasets, (0, _Data.makeAccessor2)(props.x), xDataType);
        }

        if (!isYDone()) {
          yDomain = (0, _Data.domainFromDatasets)(datasets, (0, _Data.makeAccessor2)(props.y), yDataType);
        }
      } // if Component has children,
      // recurse through descendants to resolve their domains the same way,
      // and combine them into a single domain, if there are multiple


      if (!isDone() && _react.default.Children.count(props.children)) {
        const childrenDomains = mapOverChildren(props.children, this._resolveDomain.bind(this), xScaleType, yScaleType);

        if (!isXDone()) {
          const childXDomains = (0, _compact.default)(childrenDomains.map(childDomains => childDomains.xDomain));
          xDomain = (0, _Data.combineDomains)(childXDomains, xDataType);
        }

        if (!isYDone()) {
          const childYDomains = (0, _compact.default)(childrenDomains.map(childDomains => childDomains.yDomain));
          yDomain = (0, _Data.combineDomains)(childYDomains, yDataType);
        }
      }

      if (isDone()) {
        if (includeXZero && !(0, _inRange.default)(0, ...xDomain)) {
          // If both are negative set max of domain to 0
          if (xDomain[0] < 0 && xDomain[1] < 0) {
            xDomain[1] = 0;
          } else {
            xDomain[0] = 0;
          }
        }

        if (includeYZero && !(0, _inRange.default)(0, ...yDomain)) {
          // If both are negative set max of domain to 0
          if (yDomain[0] < 0 && yDomain[1] < 0) {
            yDomain[1] = 0;
          } else {
            yDomain[0] = 0;
          }
        }
      } // TODO handle resolveXYScales not calculating the domain
      // Because this is recursive on its children it will log this warn for children missing domain
      // even though it is later inferred by parent later during the recursion
      // if (!isDone()) {
      //   console.warn(`resolveXYScales was unable to resolve both domains. xDomain: ${xDomain}, yDomain: ${yDomain}`);
      // }


      return {
        xDomain,
        yDomain
      };
    }

    _resolveTickDomain(props, Component, {
      xScaleType,
      yScaleType,
      xDomain,
      yDomain,
      xScale,
      yScale
    }) {
      if ((0, _isFunction.default)(Component.getTickDomain)) {
        const componentTickDomains = Component.getTickDomain(_objectSpread({
          xScaleType,
          yScaleType,
          xDomain,
          yDomain,
          xScale,
          yScale
        }, props));
        return omitNullUndefined(componentTickDomains);
      }

      if (_react.default.Children.count(props.children)) {
        const childrenTickDomains = mapOverChildren(props.children, this._resolveTickDomain.bind(this), {
          xScaleType,
          yScaleType,
          xDomain,
          yDomain,
          xScale,
          yScale
        });
        const childrenXTickDomains = (0, _compact.default)(childrenTickDomains.map(childTickDomains => childTickDomains.xTickDomain));
        const xTickDomain = childrenXTickDomains.length ? (0, _Data.combineDomains)(childrenXTickDomains, (0, _Scale.dataTypeFromScaleType)(xScaleType)) : undefined;
        const childrenYTickDomains = (0, _compact.default)(childrenTickDomains.map(childTickDomains => childTickDomains.yTickDomain));
        const yTickDomain = childrenYTickDomains.length ? (0, _Data.combineDomains)(childrenYTickDomains, (0, _Scale.dataTypeFromScaleType)(yScaleType)) : undefined;
        return omitNullUndefined({
          xTickDomain,
          yTickDomain
        });
      }

      return {};
    }

    _resolveMargin(props, Component, {
      xScaleType,
      yScaleType,
      xDomain,
      yDomain,
      xScale,
      yScale
    }) {
      let {
        marginTop,
        marginBottom,
        marginLeft,
        marginRight
      } = props;

      const isDone = () => [marginTop, marginBottom, marginLeft, marginRight].every(_isNumber.default); // short-circuit if all margins provided


      if (isDone()) return {
        marginTop,
        marginBottom,
        marginLeft,
        marginRight
      }; // if Component provides a custom static getMargin method
      // use it to determine remaining domains

      if ((0, _isFunction.default)(Component.getMargin)) {
        const componentMargin = omitNullUndefined(Component.getMargin(_objectSpread(_objectSpread({}, props), {}, {
          xScaleType,
          yScaleType,
          xDomain,
          yDomain,
          xScale,
          yScale
        })));
        ({
          marginTop,
          marginBottom,
          marginLeft,
          marginRight
        } = Object.assign(componentMargin, omitNullUndefined({
          marginTop,
          marginBottom,
          marginLeft,
          marginRight
        })));
        if (isDone()) return {
          marginTop,
          marginBottom,
          marginLeft,
          marginRight
        };
      } // if Component has children,
      // recurse through descendants to resolve their margins the same way,
      // and combine them into a single margin, if there are multiple


      if (_react.default.Children.count(props.children)) {
        const childrenMargins = mapOverChildren(props.children, this._resolveMargin.bind(this), {
          xScaleType,
          yScaleType,
          xDomain,
          yDomain,
          xScale,
          yScale
        }); // console.log('combining child margins', childMargins);

        const childrenMargin = (0, _Data.combineBorderObjects)(childrenMargins.map(childMargins => ({
          top: childMargins.marginTop,
          bottom: childMargins.marginBottom,
          left: childMargins.marginLeft,
          right: childMargins.marginRight
        })));
        marginTop = (0, _isUndefined.default)(marginTop) ? childrenMargin.top : marginTop;
        marginBottom = (0, _isUndefined.default)(marginBottom) ? childrenMargin.bottom : marginBottom;
        marginLeft = (0, _isUndefined.default)(marginLeft) ? childrenMargin.left : marginLeft;
        marginRight = (0, _isUndefined.default)(marginRight) ? childrenMargin.right : marginRight;
      }

      return {
        marginTop,
        marginBottom,
        marginLeft,
        marginRight
      };
    }

    _resolveSpacing(props, Component, {
      xScaleType,
      yScaleType,
      xDomain,
      yDomain,
      xScale,
      yScale
    }) {
      let {
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      } = props;

      const isDone = () => [spacingTop, spacingBottom, spacingLeft, spacingRight].every(_isNumber.default); // short-circuit if all spacing provided


      if (isDone()) return {
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      }; // if Component provides a custom static getSpacing method
      // use it to determine remaining domains

      if ((0, _isFunction.default)(Component.getSpacing)) {
        const componentSpacing = omitNullUndefined(Component.getSpacing(_objectSpread(_objectSpread({}, props), {}, {
          xScaleType,
          yScaleType,
          xDomain,
          yDomain,
          xScale,
          yScale
        })));
        ({
          spacingTop,
          spacingBottom,
          spacingLeft,
          spacingRight
        } = Object.assign(componentSpacing, omitNullUndefined({
          spacingTop,
          spacingBottom,
          spacingLeft,
          spacingRight
        })));
        if (isDone()) return {
          spacingTop,
          spacingBottom,
          spacingLeft,
          spacingRight
        };
      } // if Component has children,
      // recurse through descendants to resolve their spacings the same way,
      // and combine them into a single spacing, if there are multiple


      if (_react.default.Children.count(props.children)) {
        const childrenSpacings = mapOverChildren(props.children, this._resolveSpacing.bind(this), {
          xScaleType,
          yScaleType,
          xDomain,
          yDomain,
          xScale,
          yScale
        });
        const childrenSpacing = (0, _Data.combineBorderObjects)(childrenSpacings.map(childSpacing => ({
          top: childSpacing.spacingTop,
          bottom: childSpacing.spacingBottom,
          left: childSpacing.spacingLeft,
          right: childSpacing.spacingRight
        })));
        spacingTop = (0, _isUndefined.default)(spacingTop) ? childrenSpacing.top : spacingTop;
        spacingBottom = (0, _isUndefined.default)(spacingBottom) ? childrenSpacing.bottom : spacingBottom;
        spacingLeft = (0, _isUndefined.default)(spacingLeft) ? childrenSpacing.left : spacingLeft;
        spacingRight = (0, _isUndefined.default)(spacingRight) ? childrenSpacing.right : spacingRight;
      }

      if (isDone()) return {
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      };
    }

    render() {
      const {
        props
      } = this;
      const {
        width,
        height,
        invertXScale,
        invertYScale
      } = props; // scales not provided, so we have to resolve them
      // first resolve scale types and domains
      // const scaleType = this._resolveScaleType(props, ComposedComponent);

      const {
        xScaleType,
        yScaleType
      } = this._resolveScaleType(props, ComposedComponent); // const domain = this._resolveDomain(props, ComposedComponent, scaleType);


      let {
        xDomain,
        yDomain
      } = this._resolveDomain(props, ComposedComponent, xScaleType, yScaleType);

      if (invertXScale) xDomain = xDomain.slice().reverse();
      if (invertYScale) yDomain = yDomain.slice().reverse(); // create a temporary scale with size & domain, which may be used by the Component to calculate margin/tickDomain
      // (eg. to create and measure labels for the scales)
      // let tempScale = this._makeScales(scaleOptions);

      let scaleOptions = {
        width,
        height,
        xScaleType,
        yScaleType,
        xDomain,
        yDomain,
        invertXScale,
        invertYScale,
        marginTop: props.marginTop,
        marginBottom: props.marginBottom,
        marginLeft: props.marginLeft,
        marginRight: props.marginRight,
        spacingTop: props.spacingTop,
        spacingBottom: props.spacingBottom,
        spacingLeft: props.spacingLeft,
        spacingRight: props.spacingRight,
        xScale: props.xScale,
        yScale: props.yScale
      }; // create a temporary scale with size & domain, which may be used by the Component to calculate margin/tickDomain
      // (eg. to create and measure labels for the scales)

      let tempScale = this._makeScales(scaleOptions);

      const {
        xScale: tempXScale,
        yScale: tempYScale
      } = tempScale; // getTickDomain gives children the opportunity to modify the domain to include their scale ticks
      // (can't happen in getDomain, because it can't be done until the base domain/tempScale has been created)
      // nice-ing happens in the getTickDomain function inside of _resolveTickDomain

      const {
        xTickDomain,
        yTickDomain
      } = this._resolveTickDomain(props, ComposedComponent, {
        xScaleType,
        yScaleType,
        xDomain,
        yDomain,
        xScale: tempXScale,
        yScale: tempYScale
      });

      if ((0, _Data.isValidDomain)(xTickDomain, (0, _Scale.dataTypeFromScaleType)(xScaleType))) {
        xDomain = (0, _Data.combineDomains)([xDomain, xTickDomain], (0, _Scale.dataTypeFromScaleType)(xScaleType));
      }

      if ((0, _Data.isValidDomain)(yTickDomain, (0, _Scale.dataTypeFromScaleType)(yScaleType))) {
        yDomain = (0, _Data.combineDomains)([yDomain, yTickDomain], (0, _Scale.dataTypeFromScaleType)(yScaleType));
      } // update tempScale to use new domain before creating margins


      scaleOptions = _objectSpread(_objectSpread({}, scaleOptions), {}, {
        xDomain,
        yDomain
      });
      tempScale = this._makeScales(scaleOptions); // then resolve the margins

      const {
        marginTop,
        marginBottom,
        marginLeft,
        marginRight
      } = (0, _defaults.default)(this._resolveMargin(props, ComposedComponent, {
        xScaleType,
        yScaleType,
        xDomain,
        yDomain,
        xScale: tempScale.xScale,
        yScale: tempScale.yScale
      }), {
        marginTop: 0,
        marginBottom: 0,
        marginLeft: 0,
        marginRight: 0
      });
      const {
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      } = (0, _defaults.default)(this._resolveSpacing(props, ComposedComponent, {
        xScaleType,
        yScaleType,
        xDomain,
        yDomain,
        xScale: tempScale.xScale,
        yScale: tempScale.yScale
      }), {
        spacingTop: 0,
        spacingBottom: 0,
        spacingLeft: 0,
        spacingRight: 0
      }); // create real scales from resolved margins

      scaleOptions = _objectSpread(_objectSpread({}, scaleOptions), {}, {
        marginTop,
        marginBottom,
        marginLeft,
        marginRight,
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      });

      const {
        xScale,
        yScale
      } = this._makeScales(scaleOptions);

      const passedProps = Object.assign({}, this.props, {
        xScale,
        yScale,
        xDomain,
        yDomain,
        xScaleType,
        yScaleType,
        marginTop,
        marginBottom,
        marginLeft,
        marginRight,
        spacingTop,
        spacingBottom,
        spacingLeft,
        spacingRight
      });
      return /*#__PURE__*/_react.default.createElement(ComposedComponent, passedProps); // todo throw if cannot resolve scaleType
      // todo throw if cannot resolve domain
      // todo check to make sure margins didn't change after scales resolved?
    }

  }, _defineProperty(_class, "propTypes", {
    /**
     * Scale determined by our resolveXYScales higher order component.
     * Override this prop if you'd like to pass in your own d3 scale.
     */
    xScale: _propTypes.default.func,

    /**
     * Scale determined by our resolveXYScales higher order component.
     * Override this prop if you'd like to pass in your own d3 scale.
     */
    yScale: _propTypes.default.func,

    /**
     * Internal top margin, in pixels.
     */
    marginTop: _propTypes.default.number,

    /**
     * Internal bottom margin, in pixels.
     */
    marginBottom: _propTypes.default.number,

    /**
     * Internal left margin, in pixels.
     */
    marginLeft: _propTypes.default.number,

    /**
     * Internal right margin, in pixels.
     */
    marginRight: _propTypes.default.number,

    /**
     * Internal top spacing of XYPlot, in pixels.
     */
    spacingTop: _propTypes.default.number,

    /**
     * Internal bottom spacing of XYPlot, in pixels.
     */
    spacingBottom: _propTypes.default.number,

    /**
     * Internal left spacing of XYPlot, in pixels.
     */
    spacingLeft: _propTypes.default.number,

    /**
     * Internal right spacing of XYPlot, in pixels.
     */
    spacingRight: _propTypes.default.number,

    /**
     * Whether or not to invert the x scale
     */
    invertXScale: _propTypes.default.bool,

    /**
     * Whether or not to invert the y scale
     */
    invertYScale: _propTypes.default.bool,

    /**
     * (outer) width of the chart (SVG element).
     */
    width: _propTypes.default.number,

    /**
     * (outer) width of the chart (SVG element).
     */
    height: _propTypes.default.number
  }), _defineProperty(_class, "getScaleType", ComposedComponent.getScaleType), _defineProperty(_class, "getSpacing", ComposedComponent.getSpacing), _defineProperty(_class, "getDomain", ComposedComponent.getDomain), _defineProperty(_class, "getMargin", ComposedComponent.getMargin), _defineProperty(_class, "defaultProps", ComposedComponent.defaultProps), _temp;
}
//# sourceMappingURL=resolveXYScales.js.map