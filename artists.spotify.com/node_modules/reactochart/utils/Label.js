"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultFormats = getDefaultFormats;
exports.makeLabelFormatters = makeLabelFormatters;
exports.checkLabelsDistinct = checkLabelsDistinct;
exports.checkRangesOverlap = checkRangesOverlap;
exports.countRangeOverlaps = countRangeOverlaps;
exports.getLabelXRange = getLabelXRange;
exports.getLabelYRange = getLabelYRange;
exports.getLabelXOverhang = getLabelXOverhang;
exports.getLabelYOverhang = getLabelYOverhang;
exports.getLabelsXOverhang = getLabelsXOverhang;
exports.getLabelsYOverhang = getLabelsYOverhang;

var _isString = _interopRequireDefault(require("lodash/isString"));

var _map = _interopRequireDefault(require("lodash/map"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _tail = _interopRequireDefault(require("lodash/tail"));

var _min = _interopRequireDefault(require("lodash/min"));

var _max = _interopRequireDefault(require("lodash/max"));

var _reduce = _interopRequireDefault(require("lodash/reduce"));

var _identity = _interopRequireDefault(require("lodash/identity"));

var _d3TimeFormat = require("d3-time-format");

var _d3Format = require("d3-format");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefaultFormats(scaleType) {
  const defaultTimeFormats = ['%Y', "'%y", '%b %Y', '%m/%Y']; // Number format examples for a value of 1234.55555
  // https://github.com/d3/d3-format

  const defaultNumberFormats = ['~s', // 1.23456k
  ',d', // 1,235
  '.1~f', // 1234.6
  '.2~f', // 1234.56
  '.4~f', // 1234.5556
  '.6~f' // 1234.555555
  ];
  return scaleType === 'ordinal' ? [_identity.default] : scaleType === 'time' ? defaultTimeFormats : defaultNumberFormats;
}

function makeLabelFormatters(formats, scaleType) {
  return formats.map(format => {
    if (!(0, _isString.default)(format)) return format;
    return scaleType === 'time' ? value => (0, _d3TimeFormat.timeFormat)(format)(value) : value => (0, _d3Format.format)(format)(value);
  });
}

function checkLabelsDistinct(labels) {
  // given a set of label objects with text properties,
  // return true iff each label has distinct text (ie. no duplicate label texts)
  const labelStrs = (0, _map.default)(labels, 'text');
  return (0, _uniq.default)(labelStrs).length === labelStrs.length;
}

function checkRangesOverlap(a, b) {
  // given two number or date ranges of the form [start, end],
  // returns true if the ranges overlap
  if (![a, b].every(range => Array.isArray(range) && range.length === 2 && range.every(rangeVal => rangeVal !== null && isFinite(rangeVal)) && range[0] <= range[1])) throw new Error('checkRangesOverlap expects 2 range arrays with 2 numbers each, first <= second');
  return a[0] <= b[1] && b[0] <= a[1];
}

function countRangeOverlaps(ranges) {
  // given a list of ranges of the form [[start, end], ...]
  // counts the number of adjacent ranges which touch or overlap each other
  // todo: instead of counting overlaps, sum the amount by which they overlap & choose least overlap
  return (0, _tail.default)(ranges).reduce((sum, range, i) => {
    const prevRange = ranges[i]; // (not [i-1], _.tail skips first range)

    return checkRangesOverlap(prevRange, range) ? sum + 1 : sum;
  }, 0);
}

function getLabelXRange(scale, label, anchor = 'middle') {
  const anchorOffsets = {
    start: 0,
    middle: -0.5,
    end: -1
  };
  const x1 = scale(label.value) + (anchorOffsets[anchor] || 0) * label.width;
  return [x1, x1 + label.width];
}

function getLabelYRange(scale, label, anchor = 'middle') {
  const anchorOffsets = {
    top: 0,
    middle: -0.5,
    bottom: -1
  };
  const y1 = scale(label.value) + (anchorOffsets[anchor] || 0) * label.height;
  return [y1, y1 + label.height];
}

function getLabelXOverhang(scale, label, anchor = 'middle') {
  const [labelLeft, labelRight] = getLabelXRange(scale, label, anchor);
  const overhangLeft = Math.ceil(Math.max((0, _min.default)(scale.range()) - labelLeft, 0));
  const overhangRight = Math.ceil(Math.max(labelRight - (0, _max.default)(scale.range()), 0));
  return [overhangLeft, overhangRight];
}

function getLabelYOverhang(scale, label, anchor = 'middle') {
  const [labelTop, labelBottom] = getLabelYRange(scale, label, anchor);
  const overhangTop = Math.ceil(Math.max((0, _min.default)(scale.range()) - labelTop, 0));
  const overhangBottom = Math.ceil(Math.max(labelBottom - (0, _max.default)(scale.range()), 0));
  return [overhangTop, overhangBottom];
}

function getLabelsXOverhang(scale, labels, anchor = 'middle') {
  return (0, _reduce.default)(labels, ([left, right], label) => {
    const [thisLeft, thisRight] = getLabelXOverhang(scale, label, anchor);
    return [Math.max(left, thisLeft), Math.max(right, thisRight)];
  }, [0, 0]);
}

function getLabelsYOverhang(scale, labels, anchor = 'middle') {
  return (0, _reduce.default)(labels, ([top, bottom], label) => {
    const [thisTop, thisBottom] = getLabelYOverhang(scale, label, anchor);
    return [Math.max(top, thisTop), Math.max(bottom, thisBottom)];
  }, [0, 0]);
}
//# sourceMappingURL=Label.js.map