"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = xyPropsEqual;
exports.xyPropsEqualDebug = xyPropsEqualDebug;
exports.defaultPropKeysToDeepCheck = void 0;

var _omit = _interopRequireDefault(require("lodash/omit"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _get = _interopRequireDefault(require("lodash/get"));

var _shallowEqual = _interopRequireDefault(require("./shallowEqual"));

var _Scale = require("./Scale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// xyPropsEqual is a function used by XYPlot-type charts,
// in their `shouldComponentUpdate` methods, for determining whether next props are the same as previous props.
// in a perfect world this would just be a simple shallow equality check,
// however some props are almost always passed as object/array literals (so they never ===)
// or require special equality checks (eg. d3 scales)
// default list of props to check for *deep equality* using _.isEqual
// can be overridden by components by passing `propKeysToDeepCheck` argument
// todo: decide whether data really belongs on this list? deep-checking data can be slow, but re-rendering is even slower
const defaultPropKeysToDeepCheck = ['margin', 'scaleType', 'spacing', 'domain', 'style', 'data' // not worth deepchecking data due to perf issues
];
exports.defaultPropKeysToDeepCheck = defaultPropKeysToDeepCheck;

function xyPropsEqual(propsA, propsB, customKeysToDeepCheck = [], includeDefaults = true) {
  const propKeysToDeepCheck = includeDefaults ? defaultPropKeysToDeepCheck.concat(customKeysToDeepCheck) : customKeysToDeepCheck;
  const propKeysToSkipShallowCheck = propKeysToDeepCheck.concat('scale');
  const equalityCheck = // most keys just get shallow-equality checked
  (0, _shallowEqual.default)((0, _omit.default)(propsA, propKeysToSkipShallowCheck), (0, _omit.default)(propsB, propKeysToSkipShallowCheck)) && propKeysToDeepCheck.every(key => (0, _isEqual.default)(propsA[key], propsB[key])) && ['x', 'y'].every(key => {
    return (0, _Scale.scaleEqual)((0, _get.default)(propsA, `scale[${key}]`), (0, _get.default)(propsA, `scale[${key}]`));
  });
  return equalityCheck;
}
/* eslint-disable */


function xyPropsEqualDebug(propsA, propsB, customKeysToDeepCheck = [], includeDefaults = true) {
  const propKeysToDeepCheck = includeDefaults ? defaultPropKeysToDeepCheck.concat(customKeysToDeepCheck) : customKeysToDeepCheck; // debug version of xyPropsEqual which console.logs, for figuring out which props are failing equality check
  // const start = performance.now();

  const propKeysToSkipShallowCheck = propKeysToDeepCheck.concat('scale');
  const result = // most keys just get shallow-equality checked
  (0, _shallowEqual.default)((0, _omit.default)(propsA, propKeysToSkipShallowCheck), (0, _omit.default)(propsB, propKeysToSkipShallowCheck)) && propKeysToDeepCheck.every(key => {
    const isDeepEqual = (0, _isEqual.default)(propsA[key], propsB[key]);
    if (!isDeepEqual) console.log(`xyProps: ${key} not equal`);
    return isDeepEqual;
  }) && ['x', 'y'].every(key => {
    const isScaleEqual = (0, _Scale.scaleEqual)(propsA.scale[key], propsB.scale[key]);
    if (!isScaleEqual) console.log(`xyProps: scale.${key} not equal`);
    return isScaleEqual;
  }); // console.log('xyProps isEqual', isEqual);
  // console.log('took', performance.now() - start);

  return result;
}
/* eslint-enable */
//# sourceMappingURL=xyPropsEqual.js.map