"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scaleTypeFromDataType = scaleTypeFromDataType;
exports.dataTypeFromScaleType = dataTypeFromScaleType;
exports.inferDataTypeFromDomain = inferDataTypeFromDomain;
exports.inferScaleType = inferScaleType;
exports.initScale = initScale;
exports.isValidScale = isValidScale;
exports.hasXYScales = hasXYScales;
exports.getScaleTicks = getScaleTicks;
exports.getTickDomain = getTickDomain;
exports.scaleEqual = scaleEqual;
exports.indexOfClosestNumberInList = indexOfClosestNumberInList;
exports.invertPointScale = invertPointScale;

var _get = _interopRequireDefault(require("lodash/get"));

var _isDate = _interopRequireDefault(require("lodash/isDate"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _isObject = _interopRequireDefault(require("lodash/isObject"));

var _isEqual = _interopRequireDefault(require("lodash/isEqual"));

var _isNumber = _interopRequireDefault(require("lodash/isNumber"));

var _identity = _interopRequireDefault(require("lodash/identity"));

var _d3Scale = require("d3-scale");

var _Data = require("./Data");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scaleTypeFromDataType(dataType) {
  return (0, _get.default)({
    number: 'linear',
    time: 'time',
    categorical: 'ordinal'
  }, dataType, 'ordinal');
}

function dataTypeFromScaleType(scaleType) {
  return (0, _get.default)({
    linear: 'number',
    log: 'number',
    pow: 'number',
    time: 'time',
    ordinal: 'categorical'
  }, scaleType, 'categorical');
}

function inferDataTypeFromDomain(domain) {
  if (!Array.isArray(domain)) throw new Error('invalid domain, inferDataTypeFromDomain cannot infer data type');
  return domain.length !== 2 ? 'categorical' : domain.every(_isNumber.default) ? 'number' : domain.every(_isDate.default) ? 'time' : 'categorical';
}

function inferScaleType(scale) {
  return !scale.ticks ? 'ordinal' : (0, _isDate.default)(scale.domain()[0]) ? 'time' : scale.base ? 'log' : scale.exponent ? 'pow' : 'linear';
}

function initScale(scaleType) {
  switch (scaleType) {
    case 'linear':
      return (0, _d3Scale.scaleLinear)();

    case 'time':
      return (0, _d3Scale.scaleTime)();

    case 'ordinal':
      return (0, _d3Scale.scalePoint)();

    case 'log':
      return (0, _d3Scale.scaleLog)();

    case 'pow':
      return (0, _d3Scale.scalePow)();

    default:
      return;
  }
}

function isValidScale(scale) {
  return (0, _isFunction.default)(scale) && (0, _isFunction.default)(scale.domain) && (0, _isFunction.default)(scale.range);
}

function hasXYScales(scale) {
  return (0, _isObject.default)(scale) && isValidScale(scale.x) && isValidScale(scale.y);
}

function getScaleTicks(scale, scaleType, tickCount = 10) {
  return (scaleType || inferScaleType(scale)) === 'ordinal' ? scale.domain() : scale.ticks(tickCount);
}

function getTickDomain(scale, {
  ticks,
  tickCount,
  nice
} = {}) {
  const scaleType = inferScaleType(scale);
  const scaleDomain = scale.domain();

  if (nice && scaleType !== 'ordinal') {
    // If nicing, initialize a new scale and nice it
    // eslint-disable-next-line no-param-reassign
    scale = scale.copy().domain(scaleDomain).nice(tickCount || 10);
  }

  if (Array.isArray(ticks)) {
    return (0, _Data.combineDomains)([scale.domain(), (0, _Data.domainFromData)(ticks, _identity.default, dataTypeFromScaleType(scaleType))]);
  } else if (nice && scaleType !== 'ordinal') return scale.domain(); // return undefined by default, if we have no options pertaining to ticks

}

function scaleEqual(scaleA, scaleB) {
  return !isValidScale(scaleA) || !isValidScale(scaleB) ? scaleA === scaleB // safe fallback
  : // check scale equality
  (0, _isEqual.default)(scaleA.domain(), scaleB.domain()) && (0, _isEqual.default)(scaleA.range(), scaleB.range());
}

function indexOfClosestNumberInList(number, list) {
  return list.reduce((closestI, current, i) => {
    return Math.abs(current - number) < Math.abs(list[closestI] - number) ? i : closestI;
  }, 0);
}

function invertPointScale(scale, rangeValue) {
  const domain = scale.domain(); // shim until d3.scalePoint.invert() is implemented for real
  // given a value from the output range, returns the *nearest* corresponding value in the input domain

  const rangePoints = domain.map(domainValue => scale(domainValue));

  if (rangePoints.length <= 1) {
    return domain[0];
  }

  const isDescending = rangePoints[0] > rangePoints[1];

  if (isDescending) {
    domain.reverse();
    rangePoints.reverse();
  }

  const nearestPointIndex = indexOfClosestNumberInList(rangeValue, rangePoints);
  return domain[nearestPointIndex];
}
//# sourceMappingURL=Scale.js.map