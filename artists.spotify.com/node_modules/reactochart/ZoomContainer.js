"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Selection = require("d3-selection");

var _d3Zoom = require("d3-zoom");

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// todo: make sure this correctly handles new props getting passed in, doesn't double bind events
function zoomTransformFromProps(props) {
  const {
    zoomScale,
    zoomX,
    zoomY
  } = props;
  return _d3Zoom.zoomIdentity.translate(zoomX || 0, zoomY || 0).scale(zoomScale || 1);
}
/**
 * `ZoomContainer` is a wrapper that gives users the ability to zoom in, zoom out and drag its children components.
 */


class ZoomContainer extends _react.default.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "state", {
      lastZoomTransform: null,
      selection: null
    });

    _defineProperty(this, "handleZoom", (event, ...args) => {
      const nextZoomTransform = event.transform;

      if (this.props.controlled) {
        // zoom transform should be controlled by props, but d3-zoom has already applied new transform to this.zoom
        // (even though props haven't changed), so we must *undo* it by applying lastZoomTransform to this.zoom
        const {
          selection,
          lastZoomTransform
        } = this.state; // unbind zoom event first, so that manually setting transform doesn't trigger handleZoom infinite loop

        this.zoom.on('zoom', null);
        this.zoom.transform(selection, lastZoomTransform);
        this.zoom.on('zoom', this.handleZoom);
      } else {
        // *uncontrolled* (stateful) ZoomContainer, we want to keep the transform applied by d3-zoom;
        // but since the state is inside d3-zoom, we need to update something on this.state to trigger re-render
        this.setState({
          zoomKey: Math.random()
        });
      }

      if (this.props.onZoom) this.props.onZoom(nextZoomTransform, ...args);
    });

    this.svgRef = /*#__PURE__*/_react.default.createRef();
  }

  componentDidMount() {
    const initialZoomTransform = zoomTransformFromProps(this.props);
    const selection = (0, _d3Selection.select)(this.svgRef.current);
    this.zoom = (0, _d3Zoom.zoom)();
    selection.call(this.zoom);

    if (this.props.disableMouseWheelZoom) {
      selection.call(this.zoom).on('wheel.zoom', null);
    } else {
      selection.call(this.zoom);
    }

    this.zoom.transform(selection, initialZoomTransform);

    this._updateZoomProps();

    this.zoom.on('zoom', this.handleZoom);
    this.setState({
      selection,
      lastZoomTransform: initialZoomTransform
    });
  }

  componentDidUpdate(prevProps) {
    const nextProps = this.props;

    if (prevProps.controlled) {
      // if controlled component and zoom props have changed, apply the new zoom props to d3-zoom
      // (unbind handler first so as not to create infinite callback loop)
      const hasChangedZoom = nextProps.zoomX !== prevProps.zoomX || nextProps.zoomY !== prevProps.zoomY || nextProps.zoomScale !== prevProps.zoomScale;

      if (hasChangedZoom) {
        this.zoom.on('zoom', null);
        const nextZoomTransform = zoomTransformFromProps(nextProps);
        this.zoom.transform(this.state.selection, nextZoomTransform);
        this.zoom.on('zoom', this.handleZoom); // update state.lastZoomTransform so we can revert d3-zoom to this next time it's changed internally
        // eslint-disable-next-line react/no-did-update-set-state

        this.setState({
          lastZoomTransform: nextZoomTransform
        });
      }
    }

    this._updateZoomProps(nextProps);
  }

  _updateZoomProps(props) {
    let propsToUse = props;
    if (!propsToUse) propsToUse = this.props;
    const {
      extent,
      scaleExtent,
      translateExtent,
      clickDistance,
      duration,
      interpolate,
      constrain,
      filter,
      touchable,
      wheelDelta
    } = propsToUse;
    if (Array.isArray(extent)) this.zoom.extent(extent);
    if (Array.isArray(scaleExtent)) this.zoom.scaleExtent(scaleExtent);
    if (Array.isArray(translateExtent)) this.zoom.translateExtent(translateExtent);
    if (clickDistance !== null && isFinite(clickDistance)) this.zoom.clickDistance(clickDistance);
    if (duration !== null && isFinite(duration)) this.zoom.duration(duration);
    if ((0, _isFunction.default)(interpolate)) this.zoom.interpolate(interpolate);
    if ((0, _isFunction.default)(constrain)) this.zoom.constrain(constrain);
    if ((0, _isFunction.default)(filter)) this.zoom.filter(filter);
    if ((0, _isFunction.default)(touchable)) this.zoom.touchable(touchable);
    if ((0, _isFunction.default)(wheelDelta)) this.zoom.wheelDelta(wheelDelta);
  }

  render() {
    const theZoomTransform = this.svgRef && this.svgRef.current ? (0, _d3Zoom.zoomTransform)(this.svgRef.current) : null;
    return /*#__PURE__*/_react.default.createElement("svg", {
      ref: this.svgRef,
      width: this.props.width,
      height: this.props.height
    }, /*#__PURE__*/_react.default.createElement("g", {
      width: this.props.width,
      height: this.props.height,
      transform: theZoomTransform
    }, this.props.children));
  }

}

exports.default = ZoomContainer;

_defineProperty(ZoomContainer, "propTypes", {
  /**
   * (outer) width of the chart (SVG element).
   */
  width: _propTypes.default.number,

  /**
   * (outer) width of the chart (SVG element).
   */
  height: _propTypes.default.number,

  /**
   * Zoom callback function, called when zoom changes.
   * For controlled version of this component, you should update zoomX, zoomY and zoomScale props in this callback.
   */
  onZoom: _propTypes.default.func,

  /**
   * Boolean which determines whether the component is "controlled" (true) or "stateful" (false).
   * When true, zoom transformation is controlled entirely by the `zoomX`, `zoomY` and `zoomScale` props, which
   * you are responsible for updating in the `onZoom` callback function.
   * When false, zoom transformation is handled by internal state, and the `zoomX`, `zoomY` and `zoomScale` props
   * specify only the initial X, Y and scale transformation of the component.
   */
  controlled: _propTypes.default.bool,

  /**
   * Disables wheel-driven zooming (say to not interfere with native scrolling).
   */
  disableMouseWheelZoom: _propTypes.default.bool,

  /**
   * The X-coordinate of the zoom transformation (or initial X-coordinate, if `controlled` is false).
   */
  zoomX: _propTypes.default.number,

  /**
   * The Y-coordinate of the zoom transformation (or initial Y-coordinate, if `controlled` is false).
   */
  zoomY: _propTypes.default.number,

  /**
   * The scaling factor of the zoom transformation (or initial scaling, if `controlled` is false).
   * 1.0 is normal size, 2.0 is double size, 0.5 is half size.
   */
  zoomScale: _propTypes.default.number,

  /**
   * Sets the viewport extent to the specified array of points [[x0, y0], [x1, y1]],
   * where [x0, y0] is the top-left corner of the viewport and [x1, y1] is the bottom-right corner of the viewport.
   * See d3-zoom docs for more information.
   */
  extent: _propTypes.default.array,

  /**
   * Sets the scale extent to the specified array of numbers [k0, k1]
   * where k0 is the minimum allowed scale factor and k1 is the maximum allowed scale factor.
   * See d3-zoom docs for more information.
   */
  scaleExtent: _propTypes.default.array,

  /**
   * Sets the translate extent to the specified array of points [[x0, y0], [x1, y1]],
   * where [x0, y0] is the top-left corner of the world and [x1, y1] is the bottom-right corner of the world.
   * See d3-zoom docs for more information.
   */
  translateExtent: _propTypes.default.array,

  /**
   * Sets the maximum distance that the mouse can move between mousedown and mouseup that will trigger
   * a subsequent click event.
   * See d3-zoom docs for more information.
   */
  clickDistance: _propTypes.default.number,

  /**
   * Sets the duration for zoom transitions on double-click and double-tap to the specified number of milliseconds.
   * See d3-zoom docs for more information.
   */
  duration: _propTypes.default.number,

  /**
   * Sets the interpolation factory for zoom transitions to the specified function.
   * See d3-zoom docs for more information.
   */
  interpolate: _propTypes.default.func,

  /**
   * Sets the transform constraint function to the specified function.
   * See d3-zoom docs for more information.
   */
  constrain: _propTypes.default.func,

  /**
   * Sets the zoom event filter to the specified function.
   * See d3-zoom docs for more information.
   */
  filter: _propTypes.default.func,

  /**
   * Sets the touch support detector to the specified function.
   * See d3-zoom docs for more information.
   */
  touchable: _propTypes.default.func,

  /**
   * Sets the wheel delta function to the specified function.
   * See d3-zoom docs for more information.
   */
  wheelDelta: _propTypes.default.func,
  children: _propTypes.default.any
});

_defineProperty(ZoomContainer, "defaultProps", {
  width: 800,
  height: 600,
  controlled: false,
  disableMouseWheelZoom: false,
  zoomX: 0,
  zoomY: 0,
  zoomScale: 1
});
//# sourceMappingURL=ZoomContainer.js.map