"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _inRange = _interopRequireDefault(require("lodash/inRange"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _fromPairs = _interopRequireDefault(require("lodash/fromPairs"));

var _omit = _interopRequireDefault(require("lodash/omit"));

var _isNull = _interopRequireDefault(require("lodash/isNull"));

var _isUndefined = _interopRequireDefault(require("lodash/isUndefined"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _util = require("./util");

var _Margin = require("./utils/Margin");

var _resolveXYScales = _interopRequireDefault(require("./utils/resolveXYScales"));

var _Scale = require("./utils/Scale");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getMouseOptions(event, {
  xScale,
  yScale,
  height,
  width,
  marginTop,
  marginBottom,
  marginLeft,
  marginRight
}) {
  const chartBB = event.currentTarget.getBoundingClientRect();
  const outerX = Math.round(event.clientX - chartBB.left);
  const outerY = Math.round(event.clientY - chartBB.top);
  const innerX = outerX - (marginLeft || 0);
  const innerY = outerY - (marginTop || 0);
  const chartSize = (0, _Margin.innerSize)({
    width,
    height
  }, {
    top: marginTop,
    bottom: marginBottom,
    left: marginLeft,
    right: marginRight
  });
  const xScaleType = (0, _Scale.inferScaleType)(xScale);
  const yScaleType = (0, _Scale.inferScaleType)(yScale);
  const xValue = !(0, _inRange.default)(innerX, 0, chartSize.width) ? null : xScaleType === 'ordinal' ? (0, _Scale.invertPointScale)(xScale, innerX) : xScale.invert(innerX);
  const yValue = !(0, _inRange.default)(innerY, 0, chartSize.height) ? null : yScaleType === 'ordinal' ? (0, _Scale.invertPointScale)(yScale, innerY) : yScale.invert(innerY);
  return {
    event,
    outerX,
    outerY,
    innerX,
    innerY,
    xValue,
    yValue,
    xScale,
    yScale,
    marginTop,
    marginBottom,
    marginLeft,
    marginRight
  };
}

class XYPlot extends _react.default.Component {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "onXYMouseEvent", (callbackKey, event) => {
      const callback = this.props[callbackKey];
      if (!(0, _isFunction.default)(callback)) return;
      const options = getMouseOptions(event, this.props);
      callback(options);
    });

    _defineProperty(this, "onMouseMove", this.onXYMouseEvent.bind(this, 'onMouseMove'));

    _defineProperty(this, "onMouseDown", this.onXYMouseEvent.bind(this, 'onMouseDown'));

    _defineProperty(this, "onMouseUp", this.onXYMouseEvent.bind(this, 'onMouseUp'));

    _defineProperty(this, "onClick", this.onXYMouseEvent.bind(this, 'onClick'));

    _defineProperty(this, "onMouseEnter", this.onXYMouseEvent.bind(this, 'onMouseEnter'));

    _defineProperty(this, "onMouseLeave", this.onXYMouseEvent.bind(this, 'onMouseLeave'));
  }

  render() {
    const {
      width,
      height,
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      spacingTop,
      spacingBottom,
      spacingLeft,
      spacingRight,
      xyPlotContainerStyle,
      xyPlotStyle,
      xyPlotClassName,
      // Passed in as prop from resolveXYScales
      xScale,
      yScale
    } = this.props; // subtract margin + spacing from width/height to obtain inner width/height of panel & chart area
    // panelSize is the area including chart + spacing but NOT margin
    // chartSize is smaller, chart *only*, not including margin or spacing

    const panelSize = (0, _Margin.innerSize)({
      width,
      height
    }, {
      top: marginTop,
      bottom: marginBottom,
      left: marginLeft,
      right: marginRight
    });
    const chartSize = (0, _Margin.innerSize)(panelSize, {
      top: spacingTop,
      bottom: spacingBottom,
      left: spacingLeft,
      right: spacingRight
    });
    const handlerNames = ['onMouseMove', 'onMouseEnter', 'onMouseLeave', 'onMouseDown', 'onMouseUp', 'onClick'];
    const handlers = (0, _fromPairs.default)(handlerNames.map(handlerName => [handlerName, (0, _util.methodIfFuncProp)(handlerName, this.props, this)]));
    const scales = {
      xScale,
      yScale
    }; // Props that shouldn't be sent down to children
    // because they're either unnecessary or we don't want them to
    // override any children props

    const omittedProps = [...handlerNames, 'xyPlotContainerStyle', 'xyPlotStyle', 'xyPlotClassName'];

    const propsForChildren = _objectSpread(_objectSpread(_objectSpread({}, (0, _omit.default)(this.props, omittedProps)), chartSize), scales);

    const className = `rct-xy-plot ${xyPlotClassName}`;
    return /*#__PURE__*/_react.default.createElement("svg", _extends({
      width,
      height,
      className,
      style: xyPlotContainerStyle
    }, handlers), /*#__PURE__*/_react.default.createElement("rect", _extends({
      className: "rct-chart-background"
    }, {
      width,
      height
    }, {
      "aria-hidden": "true"
    })), /*#__PURE__*/_react.default.createElement("g", {
      transform: `translate(${marginLeft + spacingLeft}, ${marginTop + spacingTop})`,
      className: "rct-chart-inner"
    }, /*#__PURE__*/_react.default.createElement("rect", _extends({
      transform: `translate(${-spacingLeft}, ${-spacingTop})`,
      className: "rct-plot-background",
      style: xyPlotStyle,
      "aria-hidden": "true"
    }, panelSize)), _react.default.Children.map(this.props.children, child => {
      return (0, _isNull.default)(child) || (0, _isUndefined.default)(child) ? null : /*#__PURE__*/_react.default.cloneElement(child, propsForChildren);
    })));
  }

}

_defineProperty(XYPlot, "propTypes", {
  /**
   * (outer) width of the chart (SVG element).
   */
  width: _propTypes.default.number,

  /**
   * (outer) width of the chart (SVG element).
   */
  height: _propTypes.default.number,

  /**
   * The X domain of the data as an array.
   * For numerical scales, this is represented as [min, max] of the data;
   * for ordinal/categorical scales it is an array of known values ie. ['a', 'b', 'c'].
   * Automatically determined from data if not passed.
   */
  xDomain: _propTypes.default.array,

  /**
   * The Y domain of the data as an array.
   * For numerical scales, this is represented as [min, max] of the data;
   * for ordinal/categorical scales it is an array of known values ie. ['a', 'b', 'c'].
   * Automatically determined from data if not passed.
   */
  yDomain: _propTypes.default.array,
  xScaleType: _propTypes.default.string,
  yScaleType: _propTypes.default.string,

  /**
   * Whether or not to invert the x scale
   */
  invertXScale: _propTypes.default.bool,

  /**
   * Whether or not to invert the y scale
   */
  invertYScale: _propTypes.default.bool,

  /**
   * Whether or not to coerce 0 into your x domain
   */
  includeXZero: _propTypes.default.bool,

  /**
   * Whether or not to coerce 0 into your y domain
   */
  includeYZero: _propTypes.default.bool,

  /**
   * Internal top margin, in pixels.
   */
  marginTop: _propTypes.default.number,

  /**
   * Internal bottom margin, in pixels.
   */
  marginBottom: _propTypes.default.number,

  /**
   * Internal left margin, in pixels.
   */
  marginLeft: _propTypes.default.number,

  /**
   * Internal right margin, in pixels.
   */
  marginRight: _propTypes.default.number,

  /**
   * Internal top spacing of XYPlot, in pixels.
   */
  spacingTop: _propTypes.default.number,

  /**
   * Internal bottom spacing of XYPlot, in pixels.
   */
  spacingBottom: _propTypes.default.number,

  /**
   * Internal left spacing of XYPlot, in pixels.
   */
  spacingLeft: _propTypes.default.number,

  /**
   * Internal right spacing of XYPlot, in pixels.
   */
  spacingRight: _propTypes.default.number,
  // todo implement padding (helper for spacing)
  // paddingTop: PropTypes.number,
  // paddingBottom: PropTypes.number,
  // paddingLeft: PropTypes.number,
  // paddingRight: PropTypes.number,
  onMouseMove: _propTypes.default.func,
  onMouseEnter: _propTypes.default.func,
  onMouseLeave: _propTypes.default.func,
  onMouseDown: _propTypes.default.func,
  onMouseUp: _propTypes.default.func,
  onClick: _propTypes.default.func,

  /**
   * Inline style object to be applied to the parent SVG element that wraps XYPlot.
   */
  xyPlotContainerStyle: _propTypes.default.object,

  /**
   * Inline style object to be applied to the plot.
   * This is the inner rect DOM element where the graphs are rendered within the axes.
   */
  xyPlotStyle: _propTypes.default.object,

  /**
   * Class attribute applied to xy plot
   */
  xyPlotClassName: _propTypes.default.string,

  /**
   * Scale determined by our resolveXYScales higher order component.
   * Override this prop if you'd like to pass in your own d3 scale.
   */
  xScale: _propTypes.default.func,

  /**
   * Scale determined by our resolveXYScales higher order component.
   * Override this prop if you'd like to pass in your own d3 scale.
   */
  yScale: _propTypes.default.func,
  children: _propTypes.default.any
});

_defineProperty(XYPlot, "defaultProps", {
  width: 400,
  height: 250,
  invertXScale: false,
  invertYScale: false,
  includeXZero: false,
  includeYZero: false,
  xyPlotContainerStyle: {},
  xyPlotStyle: {},
  xyPlotClassName: ''
});

const XYPlotResolved = (0, _resolveXYScales.default)(XYPlot);
var _default = XYPlotResolved;
exports.default = _default;
//# sourceMappingURL=XYPlot.js.map