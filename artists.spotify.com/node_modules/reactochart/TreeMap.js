"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Hierarchy = require("d3-hierarchy");

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _uniq = _interopRequireDefault(require("lodash/uniq"));

var _map = _interopRequireDefault(require("lodash/map"));

var _isUndefined = _interopRequireDefault(require("lodash/isUndefined"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _isString = _interopRequireDefault(require("lodash/isString"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var CustomPropTypes = _interopRequireWildcard(require("./utils/CustomPropTypes"));

var _Data = require("./utils/Data");

var _TreeMapNode = _interopRequireDefault(require("./TreeMapNode"));

var _TreeMapNodeLabel = _interopRequireDefault(require("./TreeMapNodeLabel"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * `TreeMap` displays hierarchical data where a leaf node's rectangle has an area proportional to a specified dimension of the data.
 */
class TreeMap extends _react.default.Component {
  static initTreemap(rootNode, tree, options) {
    // create a d3 treemap layout function,
    // and configure it with the given options
    const {
      getValue,
      sort
    } = options;
    const treeRoot = rootNode.sum(d => {
      if ((0, _isFunction.default)(getValue)) return getValue(d);else if ((0, _isString.default)(getValue)) return d[getValue];
      return 0;
    });
    return tree(sort ? treeRoot.sort(sort) : treeRoot).descendants();
  }

  static getStateFromProps(props) {
    const tree = getTree(props);
    const rootNode = getRootNode((0, _cloneDeep.default)(props.data), props);
    const prevProps = (0, _cloneDeep.default)(props);
    return {
      tree,
      rootNode,
      prevProps
    };
  }

  static getDerivedStateFromProps(newProps, state) {
    const {
      width,
      height,
      data,
      sticky
    } = state.prevProps; // if height, width, or the data changes, or if the treemap is not sticky, re-initialize the layout function
    // todo reevaluate this logic

    if (!sticky || width !== newProps.width || height !== newProps.height || JSON.stringify(data) !== JSON.stringify(newProps.data)) {
      return TreeMap.getStateFromProps(newProps);
    }

    return null;
  }

  constructor(props) {
    super(props);
    this.state = TreeMap.getStateFromProps(props);
  }

  render() {
    const {
      width,
      height,
      nodeStyle,
      labelStyle,
      getLabel,
      minLabelWidth,
      minLabelHeight,
      onClickNode,
      onMouseEnterNode,
      onMouseLeaveNode,
      onMouseMoveNode,
      NodeComponent,
      NodeLabelComponent
    } = this.props;
    const {
      rootNode,
      tree
    } = this.state;
    const nodes = TreeMap.initTreemap(rootNode, tree, this.props);
    const style = {
      position: 'relative',
      width,
      height
    };
    const parentNames = (0, _uniq.default)((0, _map.default)(nodes, 'parent.data.name'));
    return /*#__PURE__*/_react.default.createElement("div", _extends({
      className: "rct-tree-map"
    }, {
      style
    }), nodes.map((node, i) => /*#__PURE__*/_react.default.createElement(NodeComponent, {
      node,
      nodeStyle,
      minLabelWidth,
      minLabelHeight,
      labelStyle,
      getLabel,
      parentNames,
      NodeLabelComponent,
      onClickNode,
      onMouseEnterNode,
      onMouseLeaveNode,
      onMouseMoveNode,
      key: `node-${i}`
    })));
  }

}

_defineProperty(TreeMap, "propTypes", {
  width: _propTypes.default.number.isRequired,
  height: _propTypes.default.number.isRequired,

  /**
   * Data is an object with a key of `children` and an array of objects as its value.
   * i.e. { children: [{ children: [{ size: 3 }, { size: 8 }] }, { size: 4 }]}
   */
  data: _propTypes.default.object.isRequired,

  /**
   * Key or accessor to retrieve value of data point
   */
  getValue: CustomPropTypes.getter,

  /**
   * Key or accessor to retrieve children of data point
   */
  getChildren: CustomPropTypes.getter,

  /**
   * Key or accessor to retrieve label for given Node
   */
  getLabel: CustomPropTypes.getter,

  /**
   * Function passed in to sort nodes
   */
  sort: _propTypes.default.func,
  // options for d3 treemap layout - see d3 docs

  /**
   * See d3 docs for treemap - Adds outer and inner padding to tree
   */
  padding: _propTypes.default.number,

  /**
   * See d3 docs for treemap - Enables or disables rounding
   */
  round: _propTypes.default.bool,

  /**
   * If sticky, on data change the TreeMap will not force a recreation of the tree and animate data changes.
   * Otherwise we recreate the tree given its new props
   */
  sticky: _propTypes.default.bool,

  /**
   * Sets the desired aspect ratio of the generated rectangles
   */
  ratio: _propTypes.default.number,

  /**
   * Inline style object applied to each Node,
   * or accessor function which returns a style object
   */
  nodeStyle: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),

  /**
   * Inline style object applied to each Label,
   * or accessor function which returns a style object
   */
  labelStyle: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),
  minLabelWidth: _propTypes.default.number,
  minLabelHeight: _propTypes.default.number,

  /**
   * `onClick` event handler callback, called when user clicks a NodeComponent.
   */
  onClickNode: _propTypes.default.func,

  /**
   * `mouseenter` event handler callback, called when user's mouse enters a NodeComponent.
   */
  onMouseEnterNode: _propTypes.default.func,

  /**
   * `mouseleave` event handler callback, called when user's mouse leaves a NodeComponent.
   */
  onMouseLeaveNode: _propTypes.default.func,

  /**
   * `mousemove` event handler callback, called when user's mouse moves within a NodeComponent.
   */
  onMouseMoveNode: _propTypes.default.func,

  /**
   * Optional treemap node, otherwise we default to our TreeMapNode component
   */
  NodeComponent: _propTypes.default.func,

  /**
   * Optional treemap node label, otherwise we default to our TreeMapNodeLabel component
   */
  NodeLabelComponent: _propTypes.default.func
});

_defineProperty(TreeMap, "defaultProps", {
  getValue: 'value',
  getChildren: 'children',
  getLabel: 'name',
  minLabelWidth: 0,
  minLabelHeight: 0,
  NodeComponent: _TreeMapNode.default,
  NodeLabelComponent: _TreeMapNodeLabel.default
});

function getRootNode(data, options) {
  const {
    getChildren
  } = options;
  return (0, _d3Hierarchy.hierarchy)(data, (0, _Data.makeAccessor)(getChildren));
}

function getTree(options) {
  const {
    width,
    height,
    ratio,
    round,
    padding
  } = options;
  const tiling = !(0, _isUndefined.default)(ratio) ? _d3Hierarchy.treemapResquarify.ratio(ratio) : _d3Hierarchy.treemapResquarify;
  const tree = (0, _d3Hierarchy.treemap)().tile(tiling).size([width, height]);
  if (!(0, _isUndefined.default)(padding)) tree.paddingOuter(padding);
  if (!(0, _isUndefined.default)(round)) tree.round(round);
  return tree;
}

var _default = TreeMap;
exports.default = _default;
//# sourceMappingURL=TreeMap.js.map