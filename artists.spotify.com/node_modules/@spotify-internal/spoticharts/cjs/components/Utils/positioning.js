"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpacing = exports.getBucketWidth = void 0;
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const first_1 = __importDefault(require("lodash/first"));
const last_1 = __importDefault(require("lodash/last"));
const clamp_1 = __importDefault(require("lodash/clamp"));
const Data_1 = require("reactochart/utils/Data");
const getBucketWidth = ({ barThickness, barSpacing, bucketPadding = 0, bucketSpacing = 0, valueAccessors = [], stacked = false, }) => {
    const barsPerBucket = valueAccessors.length;
    const totalBarSpacing = (barsPerBucket - 1) * barSpacing;
    const totalBarWidth = barsPerBucket * barThickness;
    const usingBucketPadding = bucketSpacing === 0 && bucketPadding && bucketPadding > 0;
    const actualBucketPadding = usingBucketPadding ? bucketPadding * 2 : 0;
    if (stacked) {
        return [barThickness, barThickness + actualBucketPadding];
    }
    const bucketSansPadding = totalBarSpacing + totalBarWidth;
    return [bucketSansPadding, bucketSansPadding + actualBucketPadding];
};
exports.getBucketWidth = getBucketWidth;
const getSpacing = props => {
    const { bucketSpacing = 0, bucketPadding = 0, horizontal, xScale, yScale, data, xDomain, yDomain, bucketAccessor, width, height, } = props;
    const [, bucketWidth] = exports.getBucketWidth(props);
    const derivedBarPadding = bucketWidth / 2;
    const barsDomain = horizontal ? yDomain : xDomain;
    const barsScale = horizontal ? yScale : xScale;
    const dimension = horizontal ? height : width;
    const barsDataDomain = Data_1.domainFromData(data, bucketAccessor);
    const [domainHead, domainTail] = sortBy_1.default([first_1.default(barsDomain), last_1.default(barsDomain)].map(d => barsScale(d)));
    const [dataDomainHead, dataDomainTail] = sortBy_1.default([first_1.default(barsDataDomain), last_1.default(barsDataDomain)].map(d => barsScale(d)));
    const [spacingTail, spacingHead] = [
        clamp_1.default(derivedBarPadding - (domainTail - dataDomainTail), 0, derivedBarPadding),
        clamp_1.default(derivedBarPadding - (dataDomainHead - domainHead), 0, derivedBarPadding),
    ];
    const dataLength = data.length;
    let totalBucketsSize;
    let sideSpacing = 0;
    if (dimension && (bucketSpacing > 0 || bucketPadding > 0)) {
        totalBucketsSize =
            bucketWidth * dataLength + (dataLength - 1) * bucketSpacing;
        sideSpacing = ((dimension || totalBucketsSize * 2) - totalBucketsSize) / 2;
    }
    if (horizontal) {
        return {
            spacingTop: spacingHead + sideSpacing,
            spacingBottom: spacingTail + sideSpacing,
            spacingLeft: 0,
            spacingRight: 0,
        };
    }
    return {
        spacingTop: 0,
        spacingBottom: 0,
        spacingLeft: spacingHead + sideSpacing,
        spacingRight: spacingTail + sideSpacing,
    };
};
exports.getSpacing = getSpacing;
//# sourceMappingURL=positioning.js.map