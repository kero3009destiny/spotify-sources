"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const prop_types_1 = __importDefault(require("prop-types"));
const styled_components_1 = __importDefault(require("styled-components"));
const get_1 = __importDefault(require("lodash/get"));
const partial_1 = __importStar(require("lodash/partial"));
const isFunction_1 = __importDefault(require("lodash/isFunction"));
const isDate_1 = __importDefault(require("lodash/isDate"));
const isNumber_1 = __importDefault(require("lodash/isNumber"));
const BucketedBar_1 = __importDefault(require("../BucketedBar"));
const CustomPropTypes = __importStar(require("reactochart/utils/CustomPropTypes"));
const Data_1 = require("reactochart/utils/Data");
const xyPropsEqual_1 = __importDefault(require("reactochart/utils/xyPropsEqual"));
const Utils_1 = require("../Utils");
const LINEAR_SCALE_TYPE = 'linear';
const TIME_SCALE_TYPE = 'time';
const ORDINAL_SCALE_TYPE = 'categorical';
const backgroundRectEl = props => react_1.default.createElement("rect", Object.assign({}, props));
const BackgroundRect = styled_components_1.default(backgroundRectEl) `
  fill: rgba(0, 0, 0, 0);
  transition: fill 0.1s ease-out;
`;
class BucketingBarChart extends react_1.Component {
    static getScaleType(props) {
        const { horizontal, data, bucketAccessor } = props;
        const bucketAxis = horizontal ? 'y' : 'x';
        const rangeAxis = horizontal ? 'x' : 'y';
        const rangeScaleType = LINEAR_SCALE_TYPE;
        const sampleData = bucketAccessor(data[0]);
        let bucketedScaleType = ORDINAL_SCALE_TYPE;
        if (isDate_1.default(sampleData)) {
            bucketedScaleType = TIME_SCALE_TYPE;
        }
        else if (isNumber_1.default(sampleData)) {
            bucketedScaleType = LINEAR_SCALE_TYPE;
        }
        return {
            [`${rangeAxis}ScaleType`]: rangeScaleType,
            [`${bucketAxis}ScaleType`]: bucketedScaleType,
        };
    }
    static getDomain(props) {
        const { horizontal, data, valueAccessors, bucketAccessor, stacked } = props;
        const bucketAxis = horizontal ? 'y' : 'x';
        const rangeAxis = horizontal ? 'x' : 'y';
        const rangeDomain = Data_1.domainFromRangeData(data, partial_1.default(BucketingBarChart.getLowestStart, valueAccessors), partial_1.default(BucketingBarChart.getHighestEnd, valueAccessors, stacked), 'number');
        const bucketedDomain = Data_1.domainFromData(data, bucketAccessor);
        return {
            [`${rangeAxis}Domain`]: rangeDomain,
            [`${bucketAxis}Domain`]: bucketedDomain,
        };
    }
    static getLowestStart(valueAccessors, data) {
        return valueAccessors.reduce((p, { start }) => (start(data) < p ? start(data) : p), 0);
    }
    static getHighestEnd(valueAccessors, isStacked, data) {
        if (isStacked) {
            return valueAccessors.reduce((p, { end }) => end(data) + p, 0);
        }
        return valueAccessors.reduce((p, { end }) => (end(data) > p ? end(data) : p), 0);
    }
    shouldComponentUpdate(nextProps) {
        const shouldUpdate = !xyPropsEqual_1.default(this.props, nextProps, ['barStyle']);
        return shouldUpdate;
    }
    render() {
        const { xScale, xDomain, yScale, yDomain, data, horizontal, barThickness, barStyle = {}, barSpacing, valueAccessors, bucketAccessor, colors = [], stacked, showLabel, labelFormat, labelStyle, labelDistance, selectedBucketIndex, selectedBucketStyles, darkenOnHover, } = this.props;
        const valuesPerBucket = valueAccessors.length;
        const [barGroupingWidth, bucketWidth] = Utils_1.getBucketWidth(this.props);
        const barColors = colors.length > 0 ? colors : [null];
        return (react_1.default.createElement("g", null,
            darkenOnHover && (react_1.default.createElement("filter", { id: "brightness" },
                react_1.default.createElement("feComponentTransfer", null,
                    react_1.default.createElement("feFuncR", { type: "linear", slope: "0.7" }),
                    react_1.default.createElement("feFuncG", { type: "linear", slope: "0.7" }),
                    react_1.default.createElement("feFuncB", { type: "linear", slope: "0.7" })))),
            data.map((d, bucketIndex) => {
                const isSelected = selectedBucketIndex === bucketIndex;
                const bucketScale = horizontal ? yScale : xScale;
                const valueScale = horizontal ? xScale : yScale;
                const bucketPosition = bucketScale(bucketAccessor(d)) -
                    (stacked ? barThickness : bucketWidth) / 2;
                const groupingPosition = bucketWidth / 2 - (stacked ? barThickness : barGroupingWidth) / 2;
                const scaledLowestStart = valueScale(BucketingBarChart.getLowestStart(valueAccessors, d));
                const scaledHighestEnd = valueScale(BucketingBarChart.getHighestEnd(valueAccessors, stacked, d));
                const [onMouseEnterBucket, onMouseMoveBucket, onMouseLeaveBucket, onClickBucket,] = [
                    'onMouseEnterBucket',
                    'onMouseMoveBucket',
                    'onMouseLeaveBucket',
                    'onClickBucket',
                ].map(eventName => {
                    const callback = get_1.default(this.props, eventName);
                    return isFunction_1.default(callback)
                        ? partial_1.default(callback, partial_1.placeholder, d, {
                            start: scaledLowestStart,
                            end: scaledHighestEnd,
                            bucket: bucketScale(bucketAccessor(d)),
                            bucketIndex,
                            bucketData: d,
                        })
                        : null;
                });
                const bucketDepth = scaledLowestStart - scaledHighestEnd;
                const mouseHitBoxDepth = horizontal
                    ? xScale(xDomain[1]) - xScale(xDomain[0])
                    : yScale(yDomain[0]) - yScale(yDomain[1]);
                let stackOffset = 0;
                return (react_1.default.createElement("g", { key: `bucket-${bucketIndex}`, transform: `translate(${horizontal ? 0 : bucketPosition},${horizontal ? bucketPosition : 0})`, onMouseEnter: onMouseEnterBucket, onMouseMove: onMouseMoveBucket, onMouseLeave: onMouseLeaveBucket, onClick: onClickBucket },
                    react_1.default.createElement(BackgroundRect, { width: horizontal ? mouseHitBoxDepth : bucketWidth, height: horizontal ? bucketWidth : mouseHitBoxDepth, style: isSelected
                            ? Object.assign({ fill: 'rgba(0,0,0,0.07)' }, selectedBucketStyles) : {
                            fill: 'rgba(0,0,0,0)',
                        } }),
                    !stacked && (react_1.default.createElement("rect", { transform: `translate(${horizontal ? scaledHighestEnd : 0},${horizontal ? 0 : scaledHighestEnd})`, width: horizontal ? bucketDepth : bucketWidth, height: horizontal ? bucketWidth : bucketDepth, stroke: 0, fill: "rgba(0,0,0,0)" })),
                    valueAccessors.map(({ start, end }, valueIndex) => {
                        const barProps = {
                            x: horizontal ? start(d) + stackOffset : 0,
                            y: horizontal ? 0 : start(d) + stackOffset,
                            bucketOffset: stacked
                                ? 0
                                : valueIndex * (barThickness + barSpacing) +
                                    groupingPosition,
                            xEnd: horizontal ? end(d) + stackOffset : undefined,
                            yEnd: horizontal ? undefined : end(d) + stackOffset,
                            xScale,
                            yScale,
                            key: `chart-bar-${bucketIndex}-${valueIndex}`,
                            thickness: barThickness,
                            style: d.barStyle || barStyle,
                            fill: barColors[valueIndex % barColors.length] || undefined,
                            showLabel: stacked
                                ? valueIndex === valuesPerBucket - 1 && showLabel
                                : showLabel,
                            labelFormat,
                            labelStyle,
                            labelDistance,
                            darkenOnHover,
                        };
                        const [onMouseEnterBar, onMouseMoveBar, onMouseLeaveBar, onClickBar,] = [
                            'onMouseEnterBar',
                            'onMouseMoveBar',
                            'onMouseLeaveBar',
                            'onClickBar',
                        ].map(eventName => {
                            const callback = get_1.default(this.props, eventName);
                            return isFunction_1.default(callback)
                                ? partial_1.default(callback, partial_1.placeholder, d, {
                                    start: horizontal ? barProps.x : barProps.y,
                                    end: horizontal ? barProps.xEnd : barProps.yEnd,
                                    bucketOffset: barProps.bucketOffset,
                                    bucket: bucketScale(bucketAccessor(d)),
                                    bucketIndex,
                                    barIndex: valueIndex,
                                    bucketData: d,
                                })
                                : null;
                        });
                        if (stacked) {
                            stackOffset = end(d) + stackOffset;
                        }
                        return (react_1.default.createElement(BucketedBar_1.default, Object.assign({}, barProps, { onMouseEnter: onMouseEnterBar, onMouseLeave: onMouseLeaveBar, onMouseMove: onMouseMoveBar, onClick: onClickBar })));
                    })));
            })));
    }
}
exports.default = BucketingBarChart;
BucketingBarChart.propTypes = {
    data: prop_types_1.default.array,
    horizontal: prop_types_1.default.bool,
    height: prop_types_1.default.number,
    width: prop_types_1.default.number,
    x: CustomPropTypes.valueOrAccessor,
    xEnd: CustomPropTypes.valueOrAccessor,
    y: CustomPropTypes.valueOrAccessor,
    yEnd: CustomPropTypes.valueOrAccessor,
    xScale: prop_types_1.default.func,
    xDomain: prop_types_1.default.array,
    yScale: prop_types_1.default.func,
    yDomain: prop_types_1.default.array,
    barThickness: prop_types_1.default.number.isRequired,
    barSpacing: prop_types_1.default.number.isRequired,
    barStyle: prop_types_1.default.oneOfType([prop_types_1.default.object, prop_types_1.default.func]),
    barClassName: prop_types_1.default.oneOfType([prop_types_1.default.string, prop_types_1.default.func]),
    onMouseMoveBar: prop_types_1.default.func,
    onMouseEnterBar: prop_types_1.default.func,
    onMouseLeaveBar: prop_types_1.default.func,
    onClickBar: prop_types_1.default.func,
    onMouseMoveBucket: prop_types_1.default.func,
    onMouseEnterBucket: prop_types_1.default.func,
    onMouseLeaveBucket: prop_types_1.default.func,
    onClickBucket: prop_types_1.default.func,
    stacked: prop_types_1.default.bool,
    showLabel: prop_types_1.default.bool,
    labelFormat: prop_types_1.default.func,
    labelDistance: prop_types_1.default.number,
    labelStyle: prop_types_1.default.object,
    valueAccessors: prop_types_1.default.arrayOf(prop_types_1.default.shape({
        start: prop_types_1.default.func.isRequired,
        end: prop_types_1.default.func.isRequired,
    })),
    bucketAccessor: prop_types_1.default.func.isRequired,
    bucketPadding: prop_types_1.default.number,
    bucketSpacing: prop_types_1.default.number,
    selectedBucketIndex: prop_types_1.default.number,
    selectedBucketStyles: prop_types_1.default.object,
    colors: prop_types_1.default.arrayOf(prop_types_1.default.string),
    darkenOnHover: prop_types_1.default.bool,
};
BucketingBarChart.defaultProps = {
    data: [],
    horizontal: false,
    barThickness: 16,
    barClassName: '',
    barStyle: {},
    barSpacing: 4,
    labelStyle: {},
    bucketSpacing: 0,
    darkenOnHover: false,
};
BucketingBarChart.getSpacing = Utils_1.getSpacing;
//# sourceMappingURL=index.js.map