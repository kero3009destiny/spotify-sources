"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventSenderReporter = void 0;
const event_sender_1 = __importDefault(require("spotify-event-sender/event_sender"));
const createSemanticMetricClient_1 = __importDefault(require("spotify-event-definitions/events/createSemanticMetricClient"));
const createSemanticMetricClientNonAuth_1 = __importDefault(require("spotify-event-definitions/events/createSemanticMetricClientNonAuth"));
const spotify_event_sender_1 = __importDefault(require("spotify-event-sender"));
const isomorphic_logger_1 = __importDefault(require("@spotify-internal/isomorphic-logger"));
const constants_1 = require("../constants");
function getEventCreator(transport) {
    return (metric) => {
        return transport.isAuthenticated()
            ? createSemanticMetricClient_1.default(metric)
            : createSemanticMetricClientNonAuth_1.default(metric);
    };
}
class EventSenderReporter {
    constructor(logger, createEvent, environment = 'browser') {
        this.logger = logger;
        this.createEvent = createEvent;
        this.environment = environment;
    }
    static create(config) {
        const options = {
            getToken: config.getToken,
            enableDebugInfo: config.enableDebugInfo,
            noAuthentication: !config.getToken,
        };
        if (config.internal) {
            options.endpoints = {
                webgate: constants_1.INTERNAL_WEBGATE_URL,
            };
        }
        if (config.context) {
            options.context = [...config.context];
        }
        const logger = spotify_event_sender_1.default(options);
        const createEvent = getEventCreator(logger._transport);
        return new EventSenderReporter(logger, createEvent, config.environment);
    }
    static createWithCustomTransport(config) {
        const logger = event_sender_1.default.create({
            transport: config.transport,
            enableDebugInfo: config.enableDebugInfo,
        });
        const createEvent = getEventCreator(config.transport);
        return new EventSenderReporter(logger, createEvent, config.environment);
    }
    send(metrics) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const metric of metrics) {
                const clonedMetric = Object.assign({}, metric);
                clonedMetric.tags = Object.assign({}, clonedMetric.tags);
                if (clonedMetric.tags.environment) {
                    isomorphic_logger_1.default.error('`tags.environment` must not be set. It is a reserved tag and will be overwritten.');
                }
                clonedMetric.tags.environment = this.environment;
                this.logger.log(this.createEvent(Object.assign({}, clonedMetric)), false);
            }
            return this.logger.flush();
        });
    }
}
exports.EventSenderReporter = EventSenderReporter;
//# sourceMappingURL=EventSender.js.map