var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
import React, { useContext, useEffect, useReducer, useRef } from 'react';
import { FormLayout, } from '../../types';
import CheckoutContext from '../CheckoutProvider';
import { computeTooltipPosition, getFormComponent, Tooltip, } from './layoutHelpers';
import Pci from '../FormLayout/Pci/Pci';
import PciClient from '../../pci-client';
import { cssFileUri, rtlCssFileUri } from '../../constants/cssFileUri';
import { pciUrlMapping } from '../CheckoutProvider/environment';
import { getBool } from '../../lib/remoteConfiguration';
import PaymentMethodHeader from '../PaymentMethodHeader/PaymentMethodHeader';
import { triggeredErrorOnFormValidationEvent } from '../../lib/tracking/exportableEventPayloadDefinitions';
import { FormWrapper } from './components';
import { useSelector } from 'react-redux';
var ActionType;
(function (ActionType) {
    ActionType[ActionType["SHOW_TOOLTIP"] = 0] = "SHOW_TOOLTIP";
    ActionType[ActionType["HIDE_TOOLTIP"] = 1] = "HIDE_TOOLTIP";
    ActionType[ActionType["IFRAME_HAS_LOADED"] = 2] = "IFRAME_HAS_LOADED";
    ActionType[ActionType["SET_PCI_CLIENT"] = 3] = "SET_PCI_CLIENT";
    ActionType[ActionType["DECREMENT_RETRY_COUNTER"] = 4] = "DECREMENT_RETRY_COUNTER";
    ActionType[ActionType["SET_RETRY_INTERVAL"] = 5] = "SET_RETRY_INTERVAL";
    ActionType[ActionType["PCI_LOADING_FAILED"] = 6] = "PCI_LOADING_FAILED";
})(ActionType || (ActionType = {}));
var pciReducer = function (state, action) {
    switch (action.type) {
        case ActionType.SHOW_TOOLTIP: {
            var _a = action.payload, pciData = _a.pciData, messageKey = _a.messageKey, offset = _a.offset, pciNameRef = _a.pciNameRef;
            var message = pciData.tooltips[messageKey];
            var position = computeTooltipPosition(offset, messageKey, pciNameRef.current);
            return __assign(__assign({}, state), { tooltip: { message: message, position: position } });
        }
        case ActionType.HIDE_TOOLTIP:
            return __assign(__assign({}, state), { tooltip: null });
        case ActionType.SET_PCI_CLIENT:
            return __assign(__assign({}, state), { pciClient: action.payload });
        case ActionType.IFRAME_HAS_LOADED:
            return __assign(__assign({}, state), { iframeIsLoading: false, hasLoaded: true });
        case ActionType.DECREMENT_RETRY_COUNTER:
            return __assign(__assign({}, state), { retryCounter: state.retryCounter - 1 });
        case ActionType.SET_RETRY_INTERVAL:
            return __assign(__assign({}, state), { retryInterval: state.retryInterval * 1.5 });
        case ActionType.PCI_LOADING_FAILED:
            return __assign(__assign({}, state), { pciLoadingFailed: true });
        default:
            return state;
    }
};
var defaultFormLayout = [
    {
        type: FormLayout.None,
        options: {},
    },
];
var getPciComponent = function (layout) {
    return layout.find(function (i) { return i.type === FormLayout.Pci; });
};
var overridePciConfig = function (config, environment, isRtl) {
    var overrides = {
        url: pciUrlMapping[environment],
        stylesheets: [cssFileUri],
        fieldValidationOnBlur: true,
        autoAdvance: true,
    };
    if (isRtl) {
        overrides.stylesheets = [rtlCssFileUri];
    }
    return Object.assign(config, overrides);
};
var usePreloadPciClient = function (checkout, state, createPciClient, dispatch) {
    useEffect(function () {
        var _a;
        var providerWithPci = checkout.redux.providerCollection.getProviderWithPci();
        if (providerWithPci &&
            !state.pciClient &&
            checkout.redux.providerCollection.allProviders.length > 1 &&
            ((_a = checkout.activePaymentProvider) === null || _a === void 0 ? void 0 : _a.id) !== providerWithPci.id) {
            var pciItem = getPciComponent(providerWithPci.layout);
            if (!pciItem) {
                return;
            }
            var pciClient = createPciClient(pciItem);
            dispatch({ type: ActionType.SET_PCI_CLIENT, payload: pciClient });
        }
    }, [checkout.redux.providerCollection]);
};
var usePci = function (pciNameRef, checkout, shouldAttemptPciReload) {
    var isRtl = useSelector(function (state) { return state.isRtl; });
    var _a = __read(useReducer(pciReducer, {
        tooltip: null,
        pciClient: null,
        iframeIsLoading: true,
        hasLoaded: false,
        retryInterval: 3000,
        retryCounter: 5,
        pciLoadingFailed: false,
    }), 2), state = _a[0], dispatch = _a[1];
    var createPciClient = function (pciItem) {
        var config = overridePciConfig(pciItem.options.pci, checkout.environment, isRtl);
        var pciClient = new PciClient(pciNameRef.current, config);
        pciClient.opts = __assign(__assign({}, pciClient.opts), pciItem.options.pci);
        pciClient.load();
        checkout.setIsLoading(true);
        pciClient.on('load', function () {
            dispatch({ type: ActionType.IFRAME_HAS_LOADED });
            pciClient.triggerResize();
            checkout.setIsLoading(false);
        });
        pciClient.off('tooltip:show');
        pciClient.off('tooltip:hide');
        pciClient.on('tooltip:show', function (messageKey, offset) {
            if (pciNameRef.current) {
                dispatch({
                    type: ActionType.SHOW_TOOLTIP,
                    payload: {
                        pciData: pciItem.options,
                        messageKey: messageKey,
                        offset: offset,
                        pciNameRef: pciNameRef,
                    },
                });
            }
        });
        pciClient.on('tooltip:hide', function () {
            dispatch({ type: ActionType.HIDE_TOOLTIP });
        });
        var pciTranslations = pciItem.options.errorMessages;
        var onErrorsCallback = function (field, errorCode) {
            var _a;
            var errorMessage = (_a = pciTranslations[errorCode]) !== null && _a !== void 0 ? _a : pciTranslations[field];
            pciClient.showFieldError(field, errorMessage);
            pciClient.triggerResize();
            checkout.dispatchExportableEvent(triggeredErrorOnFormValidationEvent({
                paymentProviderId: checkout.redux.providerCollection.activeProviderId,
                field: field,
            }));
            checkout.trackingMethods.trackPaymentErrorMessage(errorMessage, errorCode, 'form-error');
        };
        pciClient.on('error:show', onErrorsCallback);
        return pciClient;
    };
    var stateRef = useRef(state);
    stateRef.current = state;
    useEffect(function () {
        if (!shouldAttemptPciReload) {
            return;
        }
        setTimeout(function () {
            dispatch({ type: ActionType.DECREMENT_RETRY_COUNTER });
            if (stateRef.current.hasLoaded) {
                return;
            }
            else if (stateRef.current.retryCounter === 0) {
                checkout.setIsLoading(false);
                dispatch({ type: ActionType.PCI_LOADING_FAILED });
            }
            else {
                if (stateRef.current.pciClient) {
                    stateRef.current.pciClient.reload();
                    dispatch({ type: ActionType.SET_RETRY_INTERVAL });
                }
            }
        }, state.retryInterval);
    }, [stateRef.current.retryInterval, stateRef.current.hasLoaded]);
    usePreloadPciClient(checkout, state, createPciClient, dispatch);
    useEffect(function () {
        var pciItem = checkout.activePaymentProvider &&
            getPciComponent(checkout.activePaymentProvider.layout);
        if (pciItem) {
            var pciClient = state.pciClient || createPciClient(pciItem);
            checkout.setFormData('pci', { pciClient: pciClient });
            dispatch({ type: ActionType.SET_PCI_CLIENT, payload: pciClient });
        }
    }, [checkout.activePaymentProvider]);
    useEffect(function () {
        if (state.pciClient) {
            state.pciClient.on('trigger:submit', checkout.submit.bind(null, true));
        }
        return function () {
            if (state.pciClient) {
                state.pciClient.off('trigger:submit');
            }
        };
    }, [checkout.submit]);
    return state;
};
export default function ProviderForm(_a) {
    var _b;
    var shouldBreakRowsAtSmallerWidth = _a.shouldBreakRowsAtSmallerWidth;
    var checkout = useContext(CheckoutContext.Context);
    var pciNameRef = useRef(null);
    var paymentProvider = checkout.activePaymentProvider;
    var shouldAttemptPciReload = getBool('should_attempt_pci_reload', checkout.checkoutProps.clientName);
    var pciState = usePci(pciNameRef, checkout, shouldAttemptPciReload);
    var providerFormLayout = (paymentProvider && paymentProvider.layout) || [];
    var pciComponent = getPciComponent(providerFormLayout);
    var isPciHidden = typeof pciComponent === 'undefined' || ((_b = pciComponent.options) === null || _b === void 0 ? void 0 : _b.hidden);
    var pciProps = {
        isHidden: isPciHidden,
        nameRef: pciNameRef,
        isIframeLoading: pciState.iframeIsLoading,
        pciLoadingFailed: pciState.pciLoadingFailed,
    };
    useEffect(function () {
        if (isPciHidden || !pciState.pciClient)
            return;
        pciState.pciClient.triggerResize();
    }, [isPciHidden, pciState.pciClient]);
    return (React.createElement(FormWrapper, { "data-testid": "provider-form" },
        React.createElement(PaymentMethodHeader, null),
        pciState.tooltip && (React.createElement(Tooltip, { top: pciState.tooltip.position.top, left: pciState.tooltip.position.left, right: pciState.tooltip.position.right }, pciState.tooltip.message)),
        React.createElement(Pci.Component, __assign({ key: "pci" }, pciProps)),
        paymentProvider &&
            (providerFormLayout.length === 0
                ? defaultFormLayout
                : providerFormLayout).map(function (formLayout, key) {
                return getFormComponent(formLayout, '', key, checkout.formData, checkout.setFormData, shouldBreakRowsAtSmallerWidth);
            })));
}
