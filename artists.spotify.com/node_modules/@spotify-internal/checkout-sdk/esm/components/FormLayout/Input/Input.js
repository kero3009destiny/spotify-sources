var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
import React, { useEffect, useState } from 'react';
import { InputValidationType, } from '../../../types';
import { getEmailValidationRule, validateRule, } from '../../../lib/ruleValidator';
import FieldLevelErrors from '../FieldLevelErrors';
import { HintMessage } from '../components';
import { InputFormGroup, InputTooltip, useTrackIndividualErrorEvent, } from '../../ProviderForm/layoutHelpers';
import TooltipIcon from './TooltipIcon';
import { getValueByMask, handleBackspace, validateMask } from './mask';
import { InputComponent, Label, PrefixLabel, TooltipIconContainer, } from './components';
import { connect } from 'react-redux';
var BACKSPACE_CHAR_CODE = 8;
var mapStateToProps = function (state) { return ({
    validationErrorMessages: state.strings.validationErrorMessages,
}); };
var connector = connect(mapStateToProps);
export function Input(_a) {
    var options = _a.options, value = _a.value, onChange = _a.onChange, validationErrorMessages = _a.validationErrorMessages;
    var onErrorDispatch = useTrackIndividualErrorEvent();
    var _b = __read(useState(undefined), 2), errorMessage = _b[0], setErrorMessage = _b[1];
    var _c = __read(useState(options.validationRules || []), 2), validationRules = _c[0], setValidationRules = _c[1];
    var _d = __read(useState(false), 2), showTooltip = _d[0], setShowTooltip = _d[1];
    var _e = __read(useState(undefined), 2), inputMask = _e[0], setInputMask = _e[1];
    useEffect(function () {
        if (options.dataType === 'email') {
            var emailRule = validationErrorMessages.email;
            setValidationRules(__spread(validationRules, [
                getEmailValidationRule(emailRule),
            ]));
        }
    }, [options.dataType]);
    useEffect(function () {
        if (options.initialValue) {
            onChange(options.initialValue);
        }
        validationRules.map(function (rule) {
            if (rule.type === InputValidationType.Mask) {
                setInputMask(rule.value);
            }
        });
    }, []);
    var getRule = function (ruleType) {
        if (validationRules) {
            return validationRules.find(function (r) { return r.type === ruleType; });
        }
        return undefined;
    };
    var getRuleValue = function (ruleType, defaultValue) {
        if (defaultValue === void 0) { defaultValue = undefined; }
        if (!validationRules)
            return defaultValue;
        var rule = getRule(ruleType);
        if (!rule)
            return defaultValue;
        return rule.value;
    };
    var computeErrorMessages = function (forceErrorMessage) {
        if (forceErrorMessage === void 0) { forceErrorMessage = false; }
        var shouldValidate = validationRules && (forceErrorMessage || !!value);
        if (shouldValidate) {
            var message = undefined;
            var regexRule = getRule(InputValidationType.Regex);
            var requiredRule = getRule(InputValidationType.Required);
            var maskRule = getRule(InputValidationType.Mask);
            if (regexRule) {
                message = validateRule(regexRule, value);
            }
            else if (maskRule) {
                message = validateMask(maskRule, value);
            }
            else if (requiredRule) {
                var requiredValidation = validationErrorMessages.required;
                message = validateRule(requiredRule, value, requiredValidation);
            }
            setErrorMessage(message);
        }
    };
    var input = (React.createElement(InputComponent, { id: options.name, onBlur: function () {
            computeErrorMessages();
        }, value: value, onChange: function (event) {
            if (inputMask) {
                event.preventDefault();
                return;
            }
            onChange(event.target.value);
        }, onKeyDown: function (event) {
            if (inputMask) {
                var isBackspace = (event.which || event.keyCode || event.charCode) ===
                    BACKSPACE_CHAR_CODE;
                if (!isBackspace) {
                    return;
                }
                onChange(handleBackspace(inputMask, event));
            }
        }, onInput: function (event) {
            if (inputMask) {
                var text = getValueByMask(inputMask, event);
                event.preventDefault();
                if (text !== undefined) {
                    onChange(text);
                }
            }
        }, type: options.dataType, name: options.name, placeholder: options.placeholder ? options.placeholder : ' ', hasErrors: !!errorMessage, pattern: getRuleValue(InputValidationType.Regex), required: getRuleValue(InputValidationType.Required, false), minLength: getRuleValue(InputValidationType.MinLength), maxLength: getRuleValue(InputValidationType.MaxLength), onInvalid: function () {
            computeErrorMessages(true);
            onErrorDispatch(options.name);
        }, prefixLength: options.prefix ? options.prefix.length : 0 }));
    if (options.prefix) {
        input = (React.createElement(React.Fragment, null,
            options.prefix && React.createElement(PrefixLabel, null, options.prefix),
            input));
    }
    var label = !!options.label && (React.createElement(Label, { htmlFor: options.name }, options.label));
    return (React.createElement(InputFormGroup, { size: options.size },
        showTooltip && React.createElement(InputTooltip, null, options.tooltip),
        options.tooltip && (React.createElement(TooltipIconContainer, { onMouseOver: function () {
                setShowTooltip(true);
            }, onMouseOut: function () { return setShowTooltip(false); } },
            React.createElement(TooltipIcon, null))),
        input,
        label,
        React.createElement(FieldLevelErrors, { errors: errorMessage ? [errorMessage] : [] }),
        React.createElement(HintMessage, { shouldHide: !!errorMessage || !options.hintMessage }, options.hintMessage)));
}
export default connector(Input);
