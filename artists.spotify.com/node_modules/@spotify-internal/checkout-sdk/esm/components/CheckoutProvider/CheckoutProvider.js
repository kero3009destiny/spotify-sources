var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
import React, { createContext, useEffect, useState, useRef } from 'react';
import { connect, useSelector } from 'react-redux';
import { captureException } from '@sentry/browser';
import uuid from 'uuid-random';
import { BackendType } from '../../api/backend';
import { postRequest } from '../../api/migrationBackend';
import { handleResponse } from '../../lib/responseHandler';
import { Environment, getFetchParams } from './environment';
import { getCheckoutViewId, trackCheckoutPaymentView, useTrackers, } from './trackers';
import { createSubmitCallback } from './createSubmitCallback';
import version from '../../constants/version';
import { loadedDefaultPaymentMethodEvent, submittedValidPaymentFormEvent, userSelectedPaymentMethodEvent, } from '../../lib/tracking/exportableEventPayloadDefinitions';
import { useGetPaymentProviders } from './hooks';
import { checkoutSliceActions, } from '../../lib/store/checkoutSlice';
import { bindActionCreators } from '@reduxjs/toolkit';
import PaymentProviderCollection from '../../lib/PaymentProviderCollection';
import { additionalFormIsLoading } from '../../lib/additionalForms';
import shouldUseAddressCollectionSdk from '../../lib/shouldUseAddressCollectionSdk';
var Context = createContext(null);
var Consumer = Context.Consumer, Provider = Context.Provider;
export var useTrackPaymentValidationError = function (errors, customErrors, trackingMethods) {
    var _a = __read(useState([]), 2), trackedErrors = _a[0], setTrackedErrors = _a[1];
    useEffect(function () {
        if (!errors.length && trackedErrors.length > 0) {
            setTrackedErrors([]);
        }
        errors.forEach(function (error) {
            var errorId = error.value;
            if (trackedErrors.indexOf(errorId) === -1) {
                setTimeout(function () {
                    trackingMethods.trackCheckoutPaymentValidationError();
                }, 0);
                setTrackedErrors(function (prevTrackedErrors) { return __spread(prevTrackedErrors, [errorId]); });
            }
        });
    }, [trackedErrors, errors]);
    var _b = __read(useState(0), 2), customErrorCount = _b[0], setCustomErrorCount = _b[1];
    useEffect(function () {
        if (customErrors) {
            var untrackedEvents = customErrors.length - customErrorCount;
            for (var i = 0; i < untrackedEvents; i++) {
                trackingMethods.trackCheckoutPaymentValidationError();
            }
            setCustomErrorCount(customErrors.length);
        }
        else {
            setCustomErrorCount(0);
        }
    }, [customErrors]);
};
export function handleRequest(request, onSuccess, checkoutReduxActions) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, ok, body, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _c.trys.push([0, 2, , 3]);
                    return [4, request];
                case 1:
                    _a = _c.sent(), ok = _a.ok, body = _a.body;
                    checkoutReduxActions.setIsLoading(false);
                    if (ok && body) {
                        handleResponse(body, checkoutReduxActions, onSuccess);
                        return [2];
                    }
                    if (body) {
                        checkoutReduxActions.addErrors(body.data.errors);
                    }
                    else {
                        throw Error();
                    }
                    return [3, 3];
                case 2:
                    _b = _c.sent();
                    checkoutReduxActions.showGlobalError();
                    return [3, 3];
                case 3: return [2];
            }
        });
    });
}
var DEFAULT_BACKEND_CONFIGURATION = {
    backendType: BackendType.WEBSITE,
    csrfToken: '',
};
function CheckoutProvider(props) {
    var _this = this;
    var _a, _b, _c, _d;
    var formId = props.formId, flowId = props.flowId, attemptId = props.attemptId, isPaymentFormValid = props.isPaymentFormValid, skipPaymentAttemptTracking = props.skipPaymentAttemptTracking;
    var _e = props.checkoutReduxActions, setFormId = _e.setFormId, setFlowId = _e.setFlowId, setAttemptId = _e.setAttemptId, setIsPaymentFormValid = _e.setIsPaymentFormValid, setSkipPaymentAttemptTracking = _e.setSkipPaymentAttemptTracking;
    var environment = props.environment || Environment.PRODUCTION;
    var fetchParams = getFetchParams(props.premium !== undefined, environment, props.clientData, props.clientConfig, version);
    var additionalForms = (_a = props.checkoutProps.additionalForms) !== null && _a !== void 0 ? _a : [];
    var hasAddressCollectionSdk = useSelector(function (state) { return state.checkoutProps.hasAddressCollectionSdk; });
    var useAddressCollectionSdk = props.configurationResolved &&
        shouldUseAddressCollectionSdk(props.country, props.remoteConfigResolver, hasAddressCollectionSdk);
    useEffect(function () {
        if (props.providerCollection.activeProviderId) {
            setFlowId(uuid());
        }
    }, [props.providerCollection.activeProviderId]);
    var dispatchExportableEvent = (_b = props.onTrackingEventDispatch) !== null && _b !== void 0 ? _b : (function () { });
    useEffect(function () {
        var _a;
        if (props.providerCollection.activeProviderId) {
            setFormId(((_a = props.providerCollection.activeProvider) === null || _a === void 0 ? void 0 : _a.formId) || '');
        }
    }, [(_c = props.providerCollection.activeProvider) === null || _c === void 0 ? void 0 : _c.formId]);
    var trackingMethods = useTrackers(flowId, formId || '', attemptId, props.country, props.providerCollection.activeProviderId, props.providerCollection.allProviders, props.clientData, environment, props.premium);
    var initialFlowStart = useRef(true);
    useEffect(function () {
        if (!props.providerCollection.activeProviderId) {
            return;
        }
        trackingMethods.trackCheckoutFlowStart();
        var exportablePayload = {
            paymentProviderId: props.providerCollection.activeProviderId,
        };
        var exportableEventResponse = userSelectedPaymentMethodEvent(exportablePayload);
        if (initialFlowStart.current) {
            exportableEventResponse = loadedDefaultPaymentMethodEvent(exportablePayload);
            initialFlowStart.current = false;
        }
        dispatchExportableEvent(exportableEventResponse);
    }, [flowId]);
    useEffect(function () {
        if (!props.providerCollection.activeProviderId || !flowId) {
            return;
        }
        trackingMethods.trackCheckoutFormView();
    }, [flowId, formId]);
    useGetPaymentProviders(fetchParams, {
        paymentProviderIds: props.paymentProviderIds,
        country: props.country,
        isPayment: props.isPayment,
        locale: props.locale,
        storedPaymentDetails: props.showStoredPaymentDetails || false,
        clientId: props.clientId,
    }, trackingMethods, props.remoteConfigResolver, props.checkoutReduxActions);
    var _f = __read(useState({}), 2), formData = _f[0], setFormData = _f[1];
    useEffect(function () {
        if (props.delayedRequest.url) {
            window.setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                var request;
                var _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            request = postRequest(fetchParams.additionalParameters, props.delayedRequest.url, ((_a = props.providerCollection.activeProvider) === null || _a === void 0 ? void 0 : _a.backendConfiguration) ||
                                DEFAULT_BACKEND_CONFIGURATION, fetchParams.headers, {});
                            return [4, handleRequest(request, props.checkoutProps.onSuccess, props.checkoutReduxActions)];
                        case 1:
                            _b.sent();
                            return [2];
                    }
                });
            }); }, props.delayedRequest.period);
        }
    }, [props.delayedRequest]);
    function createFormDataNamespace(providerId) {
        setFormData(function (currentFormData) {
            var _a;
            if (!Object.hasOwnProperty.call(currentFormData, providerId)) {
                return __assign(__assign({}, currentFormData), (_a = {}, _a[providerId] = {}, _a));
            }
            return currentFormData;
        });
    }
    useEffect(function () {
        createFormDataNamespace(props.providerCollection.activeProviderId);
    }, [props.providerCollection.activeProviderId]);
    function updateActiveProviderId(nextProviderId) {
        if (props.clearCustomErrors)
            props.clearCustomErrors();
        props.checkoutReduxActions.clearErrors();
        createFormDataNamespace(nextProviderId);
        props.checkoutReduxActions.setActiveProviderId(nextProviderId);
    }
    function enableProviderSelection() {
        var _a;
        if (props.clearCustomErrors)
            props.clearCustomErrors();
        props.checkoutReduxActions.clearErrors();
        props.checkoutReduxActions.showInitialForm();
        setFormId(((_a = props.providerCollection.activeProvider) === null || _a === void 0 ? void 0 : _a.formId) || '');
    }
    var getCtaLabel = function (consumerCtaLabel) {
        var activeProvider = props.providerCollection.activeProvider;
        if (activeProvider && activeProvider.ctaLabel) {
            return activeProvider.ctaLabel;
        }
        if (consumerCtaLabel) {
            return consumerCtaLabel;
        }
        return props.ctaLabel;
    };
    useEffect(function () {
        if (!attemptId)
            return;
        var trackValidatedFormSubmitted = function () {
            dispatchExportableEvent(submittedValidPaymentFormEvent({
                paymentProviderId: props.providerCollection.activeProviderId,
            }));
        };
        var onSubmit = createSubmitCallback(fetchParams)(props.providerCollection.activeProvider, formData[props.providerCollection.activeProviderId], props.checkoutReduxActions, getCheckoutViewId(), props, function (request) {
            return handleRequest(request, props.checkoutProps.onSuccess, props.checkoutReduxActions);
        }, trackingMethods, attemptId, flowId, skipPaymentAttemptTracking, trackValidatedFormSubmitted, additionalForms, useAddressCollectionSdk);
        if (isPaymentFormValid && !props.isLoading) {
            onSubmit();
        }
        else {
            trackingMethods.trackCheckoutPaymentAttempt('');
        }
    }, [attemptId]);
    var generateNewAttemptId = function (isValid, shouldSkipPaymentAttemptTracking) {
        if (shouldSkipPaymentAttemptTracking) {
            setSkipPaymentAttemptTracking(true);
        }
        else {
            setSkipPaymentAttemptTracking(false);
        }
        setIsPaymentFormValid(isValid);
        setAttemptId(uuid());
    };
    var provider = {
        submit: generateNewAttemptId,
        appendErrors: props.checkoutReduxActions.addErrors,
        setActivePaymentProviderId: updateActiveProviderId,
        setProviderSelectionEnabled: enableProviderSelection,
        activePaymentProvider: props.providerCollection.activeProvider,
        getPaymentProviders: function () {
            if (!props.providerCollection.hasProviders) {
                var err = new Error('Provider has not been fetched.');
                captureException(err);
                throw err;
            }
            return props.providerCollection.allProviders;
        },
        hasPaymentProviders: function () { return props.providerCollection.hasProviders; },
        isConfigurationResolved: function () { return props.configurationResolved; },
        setConfigurationResolved: props.checkoutReduxActions.setConfigurationResolved,
        getCtaLabel: getCtaLabel,
        setFormData: function (key, sectionData) {
            setFormData(function (currentFormData) {
                var _a, _b;
                return __assign(__assign({}, currentFormData), (_a = {}, _a[props.providerCollection.activeProviderId] = __assign(__assign({}, currentFormData[props.providerCollection.activeProviderId]), (_b = {}, _b[key] = sectionData, _b)), _a));
            });
        },
        formData: formData[props.providerCollection.activeProviderId],
        setIsLoading: props.checkoutReduxActions.setIsLoading,
        showRedirectOverlay: props.isRedirectOverlayShowing,
        showWaitOverlay: props.isWaitOverlayShowing,
        redirectMessage: props.redirectMessage,
        isRtl: props.isRtl,
        trackingMethods: trackingMethods,
        premiumData: props.premium,
        baseUrl: fetchParams.baseUrl,
        checkoutProps: props.checkoutProps,
        onSuccess: props.checkoutProps.onSuccess,
        onOpenCountryPicker: props.checkoutProps.onOpenCountryPicker,
        environment: environment,
        checkoutWidth: props.checkoutWidth,
        dispatchExportableEvent: dispatchExportableEvent,
        isLoading: props.isLoading ||
            !props.configurationResolved ||
            additionalFormIsLoading((_d = props.checkoutProps.additionalForms) !== null && _d !== void 0 ? _d : []),
        redux: {
            changePaymentMethodLabel: props.changePaymentMethodLabel,
            moreProviderLogosLabel: props.moreProviderLogosLabel,
            paymentDetailsLabel: props.paymentDetailsLabel,
            cancelLabel: props.cancelLabel,
            providerCollection: props.providerCollection,
            checkoutActions: props.checkoutReduxActions,
            errors: props.errors,
            isFetchDataError: props.isFetchDataError,
            flowStep: props.flowStep,
        },
    };
    useEffect(function () {
        if (props.providerCollection.activeProviderId) {
            trackCheckoutPaymentView();
        }
    }, [props.providerCollection.activeProviderId]);
    useTrackPaymentValidationError(props.errors, props.customErrors, trackingMethods);
    return React.createElement(Provider, { value: provider }, props.children);
}
var mapStateToProps = function (state) { return ({
    errors: state.errors,
    isLoading: state.isLoading,
    attemptId: state.attemptId,
    flowId: state.flowId,
    formId: state.formId,
    changePaymentMethodLabel: state.strings.changePaymentMethodLabel,
    moreProviderLogosLabel: state.strings.moreProviderLogosLabel,
    paymentDetailsLabel: state.strings.paymentDetailsLabel,
    globalErrorMessage: state.strings.globalErrorMessage,
    redirectMessage: state.strings.redirectMessage,
    ctaLabel: state.strings.ctaLabel,
    cancelLabel: state.strings.cancelLabel,
    validationErrorMessages: state.strings.validationErrorMessages,
    isRtl: state.isRtl,
    providerCollection: PaymentProviderCollection.fromJSON(state.providerCollection),
    isPaymentFormValid: state.isPaymentFormValid,
    skipPaymentAttemptTracking: state.skipPaymentAttemptTracking,
    configurationResolved: state.configurationResolved,
    delayedRequest: state.delayedRequest,
    isWaitOverlayShowing: state.isWaitOverlayShowing,
    isRedirectOverlayShowing: state.isRedirectOverlayShowing,
    isFetchDataError: state.isFetchDataError,
    flowStep: state.flowStep,
}); };
var mapDispatchToProps = function (dispatch) { return ({
    checkoutReduxActions: bindActionCreators(checkoutSliceActions, dispatch),
}); };
export default {
    Context: Context,
    Consumer: Consumer,
    Provider: connect(mapStateToProps, mapDispatchToProps)(CheckoutProvider),
};
