var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import DataLoader from 'dataloader';
import { read } from 'react-read';
import { useEffect, useReducer, useCallback } from 'react';
export function createBatchLoader(batchLoadFn, opts = {}) {
    return new DataLoader((keys) => __awaiter(this, void 0, void 0, function* () {
        try {
            const results = yield batchLoadFn(keys);
            return results;
        }
        catch (error) {
            return keys.map(() => error);
        }
    }), opts);
}
export function createLoader(loadFn, opts = {}) {
    return createBatchLoader(([key]) => __awaiter(this, void 0, void 0, function* () {
        const result = yield loadFn(key);
        return [result];
    }), Object.assign(Object.assign({}, opts), { batch: false }));
}
function getCached(loader, key) {
    const options = loader._options;
    const promiseCache = loader._promiseCache;
    const cacheKeyFn = options && options.cacheKeyFn;
    const cacheKey = cacheKeyFn ? cacheKeyFn(key) : key;
    return promiseCache.get(cacheKey);
}
export function put(loader, key, value) {
    const cached = getCached(loader, key);
    loader.clear(key).prime(key, value);
    try {
        read(loader.load(key));
    }
    catch (suspender) {
        if (!cached)
            return;
        const deferred = getDeffered(cached);
        deferred.resolve(suspender);
    }
}
export function useLoader(loader, key) {
    const [, rerender] = useReducer(state => state + 1, 0);
    const source = loader.load(key);
    const data = read(source);
    const boundPut = useCallback((value) => {
        return put(loader, key, value);
    }, [loader, key]);
    useEffect(() => {
        let subscribed = true;
        const deferred = getDeffered(source);
        deferred.then(() => subscribed && rerender());
        return () => {
            subscribed = false;
        };
    }, [source]);
    return [data, boundPut];
}
const defferedKey = Symbol('deffered');
function getDeffered(source) {
    if (!source[defferedKey]) {
        const deferred = (source[defferedKey] = {});
        deferred.promise = new Promise((resolve, reject) => {
            deferred.resolve = resolve;
            deferred.reject = reject;
        });
    }
    return source[defferedKey];
}
//# sourceMappingURL=createLoader.js.map