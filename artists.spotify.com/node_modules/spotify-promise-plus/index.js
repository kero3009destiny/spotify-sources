'use strict';

var Promise = global.Promise;

if (!Promise) {
  throw new Error('Fatal: no Promise implementation available.');
}

// Make extensions non-enumerable if possible.
var defineProperty;
if (Object.defineProperty) {
  defineProperty = function(object, property, value) {
    if (object[property]) {
      // Don't override if already implemented.
      return object;
    }
    Object.defineProperty(object, property, {
      value: value,
      configurable: true,
      writable: true
    });
    return object;
  };
} else {
  defineProperty = function(object, property, value) {
    if (object[property]) {
      // Don't override if already implemented.
      return object;
    }
    object[property] = value;
    return object;
  };
}

defineProperty(Promise, 'defer', function() {
  var deferred = {};
  deferred.promise = new Promise(function(resolve, reject) {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
});

/**
 * Spreads an iterable resolved value as parameters to the resolved function.
 *
 * Note that this method calls Promise.all() internally.
 *
 * @param {function(...*)} resolved The function to be called when a
 *     promise is fulfilled.
 * @param {function(*)} rejected The function to be called when a
 *     promise failed.
 * @return {Spotify.Promise} A new promise that could be used to chain handlers.
 */
defineProperty(Promise.prototype, 'spread', function(resolved, rejected) {
  return this.then(function(value) {
    return Promise.all(value);
  }).then(function(spreaded) {
    if (spreaded.length === 1) {
      // Special case. If it's only one item, call it immediately to avoid
      // apply() overhead.
      return resolved(spreaded[0]);
    }
    return resolved.apply(this, spreaded);
  }, rejected);
});

/**
 * Export public interface
 */
module.exports = Promise;
