import { isFocusVisible, useHover, usePress } from "@react-aria/interactions";
import { getItemCount } from "@react-stately/collections";
import { useSelectableList, useSelectableItem } from "@react-aria/selection";
import _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import { useOverlayTrigger } from "@react-aria/overlays";
import { useId, filterDOMProps, mergeProps, useSlotId } from "@react-aria/utils";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";

/**
 * Provides the behavior and accessibility implementation for a menu trigger.
 * @param props - Props for the menu trigger.
 * @param state - State for the menu trigger.
 */
export function useMenuTrigger(props, state, ref) {
  let {
    type = 'menu',
    isDisabled
  } = props;
  let menuTriggerId = useId();
  let {
    triggerProps,
    overlayProps
  } = useOverlayTrigger({
    type
  }, state, ref);

  let onKeyDown = e => {
    if (isDisabled) {
      return;
    }

    if (ref && ref.current) {
      switch (e.key) {
        case 'ArrowDown':
        case 'Enter':
        case ' ':
          // Stop propagation, unless it would already be handled by useKeyboard.
          if (!('continuePropagation' in e)) {
            e.stopPropagation();
          }

          e.preventDefault();
          state.toggle('first');
          break;

        case 'ArrowUp':
          if (!('continuePropagation' in e)) {
            e.stopPropagation();
          }

          e.preventDefault();
          state.toggle('last');
          break;
      }
    }
  };

  return {
    menuTriggerProps: _babelRuntimeHelpersEsmExtends({}, triggerProps, {
      id: menuTriggerId,

      onPressStart(e) {
        // For consistency with native, open the menu on mouse/key down, but touch up.
        if (e.pointerType !== 'touch' && e.pointerType !== 'keyboard' && !isDisabled) {
          // If opened with a screen reader, auto focus the first item.
          // Otherwise, the menu itself will be focused.
          state.toggle(e.pointerType === 'virtual' ? 'first' : null);
        }
      },

      onPress(e) {
        if (e.pointerType === 'touch' && !isDisabled) {
          state.toggle();
        }
      },

      onKeyDown
    }),
    menuProps: _babelRuntimeHelpersEsmExtends({}, overlayProps, {
      'aria-labelledby': menuTriggerId
    })
  };
}

/**
 * Provides the behavior and accessibility implementation for a menu component.
 * A menu displays a list of actions or options that a user can choose.
 * @param props - Props for the menu.
 * @param state - State for the menu, as returned by `useListState`.
 */
export function useMenu(props, state, ref) {
  let {
    shouldFocusWrap = true
  } = props,
      otherProps = _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose(props, ["shouldFocusWrap"]);

  if (!props['aria-label'] && !props['aria-labelledby']) {
    console.warn('An aria-label or aria-labelledby prop is required for accessibility.');
  }

  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let {
    listProps
  } = useSelectableList(_babelRuntimeHelpersEsmExtends({}, otherProps, {
    ref,
    selectionManager: state.selectionManager,
    collection: state.collection,
    disabledKeys: state.disabledKeys,
    shouldFocusWrap
  }));
  return {
    menuProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({
      role: 'menu'
    }, listProps))
  };
}

/**
 * Provides the behavior and accessibility implementation for an item in a menu.
 * See `useMenu` for more details about menus.
 * @param props - Props for the item.
 * @param state - State for the menu, as returned by `useTreeState`.
 */
export function useMenuItem(props, state, ref) {
  let {
    isSelected,
    isDisabled,
    key,
    onClose,
    closeOnSelect,
    isVirtualized,
    onAction
  } = props;
  let role = 'menuitem';

  if (state.selectionManager.selectionMode === 'single') {
    role = 'menuitemradio';
  } else if (state.selectionManager.selectionMode === 'multiple') {
    role = 'menuitemcheckbox';
  }

  let labelId = useSlotId();
  let descriptionId = useSlotId();
  let keyboardId = useSlotId();
  let ariaProps = {
    'aria-disabled': isDisabled,
    role,
    'aria-label': props['aria-label'],
    'aria-labelledby': labelId,
    'aria-describedby': [descriptionId, keyboardId].filter(Boolean).join(' ') || undefined
  };

  if (state.selectionManager.selectionMode !== 'none') {
    ariaProps['aria-checked'] = isSelected;
  }

  if (isVirtualized) {
    ariaProps['aria-posinset'] = state.collection.getItem(key).index;
    ariaProps['aria-setsize'] = getItemCount(state.collection);
  }

  let onKeyDown = e => {
    // Ignore repeating events, which may have started on the menu trigger before moving
    // focus to the menu item. We want to wait for a second complete key press sequence.
    if (e.repeat) {
      return;
    }

    switch (e.key) {
      case ' ':
        if (!isDisabled && state.selectionManager.selectionMode === 'none' && closeOnSelect !== false && onClose) {
          onClose();
        }

        break;

      case 'Enter':
        // The Enter key should always close on select, except if overridden.
        if (!isDisabled && closeOnSelect !== false && onClose) {
          onClose();
        }

        break;
    }
  };

  let onPressStart = e => {
    if (e.pointerType === 'keyboard' && onAction) {
      onAction(key);
    }
  };

  let onPressUp = e => {
    if (e.pointerType !== 'keyboard') {
      if (onAction) {
        onAction(key);
      } // Pressing a menu item should close by default in single selection mode but not multiple
      // selection mode, except if overridden by the closeOnSelect prop.


      if (onClose && (closeOnSelect != null ? closeOnSelect : state.selectionManager.selectionMode !== 'multiple')) {
        onClose();
      }
    }
  };

  let {
    itemProps
  } = useSelectableItem({
    selectionManager: state.selectionManager,
    key,
    ref,
    shouldSelectOnPressUp: true
  });
  let {
    pressProps
  } = usePress({
    onPressStart,
    onPressUp,
    isDisabled
  });
  let {
    hoverProps
  } = useHover({
    isDisabled,

    onHoverStart() {
      if (!isFocusVisible()) {
        state.selectionManager.setFocused(true);
        state.selectionManager.setFocusedKey(key);
      }
    }

  });
  return {
    menuItemProps: _babelRuntimeHelpersEsmExtends({}, ariaProps, mergeProps(itemProps, pressProps, hoverProps, {
      onKeyDown
    })),
    labelProps: {
      id: labelId
    },
    descriptionProps: {
      id: descriptionId
    },
    keyboardShortcutProps: {
      id: keyboardId
    }
  };
}

/**
 * Provides the behavior and accessibility implementation for a section in a menu.
 * See `useMenu` for more details about menus.
 * @param props - Props for the section.
 */
export function useMenuSection(props) {
  let {
    heading,
    'aria-label': ariaLabel
  } = props;
  let headingId = useId();
  return {
    itemProps: {
      role: 'presentation'
    },
    headingProps: heading ? {
      // Techincally, menus cannot contain headings according to ARIA.
      // We hide the heading from assistive technology, and only use it
      // as a label for the nested group.
      id: headingId,
      'aria-hidden': true
    } : {},
    groupProps: {
      role: 'group',
      'aria-label': ariaLabel,
      'aria-labelledby': heading ? headingId : undefined
    }
  };
}
//# sourceMappingURL=module.js.map
