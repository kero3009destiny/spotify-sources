import { useLongPress, usePress } from "@react-aria/interactions";
import { useLocale, useCollator } from "@react-aria/i18n";
import { focusWithoutScrolling, mergeProps, useEvent, isAppleDevice, isMac } from "@react-aria/utils";
import { focusSafely, getFocusableTreeWalker } from "@react-aria/focus";
import { useEffect, useRef, useMemo } from "react";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";

function $d9657c365c2f735bcaf048eee8599a4a$export$isNonContiguousSelectionModifier(e) {
  // Ctrl + Arrow Up/Arrow Down has a system wide meaning on macOS, so use Alt instead.
  // On Windows and Ubuntu, Alt + Space has a system wide meaning.
  return isAppleDevice() ? e.altKey : e.ctrlKey;
}

function $d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) {
  if (isMac()) {
    return e.metaKey;
  }

  return e.ctrlKey;
}

/**
 * Handles typeahead interactions with collections.
 */
export function useTypeSelect(options) {
  let {
    keyboardDelegate,
    selectionManager,
    onTypeSelect
  } = options;
  let state = useRef({
    search: '',
    timeout: null
  }).current;

  let onKeyDown = e => {
    let character = $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(e.key);

    if (!character || e.ctrlKey || e.metaKey) {
      return;
    } // Do not propagate the Spacebar event if it's meant to be part of the search.
    // When we time out, the search term becomes empty, hence the check on length.
    // Trimming is to account for the case of pressing the Spacebar more than once,
    // which should cycle through the selection/deselection of the focused item.


    if (character === ' ' && state.search.trim().length > 0) {
      e.preventDefault();

      if (!('continuePropagation' in e)) {
        e.stopPropagation();
      }
    }

    state.search += character; // Use the delegate to find a key to focus.
    // Prioritize items after the currently focused item, falling back to searching the whole list.

    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.

    if (key == null) {
      key = keyboardDelegate.getKeyForSearch(state.search);
    }

    if (key != null) {
      selectionManager.setFocusedKey(key);

      if (onTypeSelect) {
        onTypeSelect(key);
      }
    }

    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = '';
    }, 500);
  };

  return {
    typeSelectProps: {
      // Using a capturing listener to catch the keydown event before
      // other hooks in order to handle the Spacebar event.
      onKeyDownCapture: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}

function $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(key) {
  // If the key is of length 1, it is an ASCII value.
  // Otherwise, if there are no ASCII characters in the key name,
  // it is a Unicode character.
  // See https://www.w3.org/TR/uievents-key/
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }

  return '';
}

/**
 * Handles interactions with selectable collections.
 */
export function useSelectableCollection(options) {
  let {
    selectionManager: manager,
    keyboardDelegate: delegate,
    ref,
    autoFocus = false,
    shouldFocusWrap = false,
    disallowEmptySelection = false,
    disallowSelectAll = false,
    selectOnFocus = manager.selectionBehavior === 'replace',
    disallowTypeAhead = false,
    shouldUseVirtualFocus,
    allowsTabNavigation = false,
    isVirtualized,
    // If no scrollRef is provided, assume the collection ref is the scrollable region
    scrollRef = ref
  } = options;
  let {
    direction
  } = useLocale();

  let onKeyDown = e => {
    // Prevent option + tab from doing anything since it doesn't move focus to the cells, only buttons/checkboxes
    if (e.altKey && e.key === 'Tab') {
      e.preventDefault();
    } // Keyboard events bubble through portals. Don't handle keyboard events
    // for elements outside the collection (e.g. menus).


    if (!ref.current.contains(e.target)) {
      return;
    }

    const navigateToKey = (key, childFocus) => {
      if (key != null) {
        manager.setFocusedKey(key, childFocus);

        if (e.shiftKey && manager.selectionMode === 'multiple') {
          manager.extendSelection(key);
        } else if (selectOnFocus && !$d9657c365c2f735bcaf048eee8599a4a$export$isNonContiguousSelectionModifier(e)) {
          manager.replaceSelection(key);
        }
      }
    };

    switch (e.key) {
      case 'ArrowDown':
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey == null ? void 0 : delegate.getFirstKey();

            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getFirstKey == null ? void 0 : delegate.getFirstKey(manager.focusedKey);
            }

            navigateToKey(nextKey);
          }

          break;
        }

      case 'ArrowUp':
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey == null ? void 0 : delegate.getLastKey();

            if (nextKey == null && shouldFocusWrap) {
              nextKey = delegate.getLastKey == null ? void 0 : delegate.getLastKey(manager.focusedKey);
            }

            navigateToKey(nextKey);
          }

          break;
        }

      case 'ArrowLeft':
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyLeftOf(manager.focusedKey);
            navigateToKey(nextKey, direction === 'rtl' ? 'first' : 'last');
          }

          break;
        }

      case 'ArrowRight':
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyRightOf(manager.focusedKey);
            navigateToKey(nextKey, direction === 'rtl' ? 'last' : 'first');
          }

          break;
        }

      case 'Home':
        if (delegate.getFirstKey) {
          e.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, $d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e));
          manager.setFocusedKey(firstKey);

          if ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(firstKey);
          } else if (selectOnFocus) {
            manager.replaceSelection(firstKey);
          }
        }

        break;

      case 'End':
        if (delegate.getLastKey) {
          e.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, $d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e));
          manager.setFocusedKey(lastKey);

          if ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(lastKey);
          } else if (selectOnFocus) {
            manager.replaceSelection(lastKey);
          }
        }

        break;

      case 'PageDown':
        if (delegate.getKeyPageBelow) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);
          navigateToKey(nextKey);
        }

        break;

      case 'PageUp':
        if (delegate.getKeyPageAbove) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);
          navigateToKey(nextKey);
        }

        break;

      case 'a':
        if ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {
          e.preventDefault();
          manager.selectAll();
        }

        break;

      case 'Escape':
        e.preventDefault();

        if (!disallowEmptySelection) {
          manager.clearSelection();
        }

        break;

      case 'Tab':
        {
          if (!allowsTabNavigation) {
            // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
            // However, collections should be treated as a single tab stop, with arrow key navigation internally.
            // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
            // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
            // in the collection, so that the browser default behavior will apply starting from that element
            // rather than the currently focused one.
            if (e.shiftKey) {
              ref.current.focus();
            } else {
              let walker = getFocusableTreeWalker(ref.current, {
                tabbable: true
              });
              let next;
              let last;

              do {
                last = walker.lastChild();

                if (last) {
                  next = last;
                }
              } while (last);

              if (next && !next.contains(document.activeElement)) {
                focusWithoutScrolling(next);
              }
            }

            break;
          }
        }
    }
  }; // Store the scroll position so we can restore it later.


  let scrollPos = useRef({
    top: 0,
    left: 0
  });
  useEvent(scrollRef, 'scroll', isVirtualized ? null : () => {
    scrollPos.current = {
      top: scrollRef.current.scrollTop,
      left: scrollRef.current.scrollLeft
    };
  });

  let onFocus = e => {
    if (manager.isFocused) {
      // If a focus event bubbled through a portal, reset focus state.
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }

      return;
    } // Focus events can bubble through portals. Ignore these events.


    if (!e.currentTarget.contains(e.target)) {
      return;
    }

    manager.setFocused(true);

    if (manager.focusedKey == null) {
      let navigateToFirstKey = key => {
        if (key != null) {
          manager.setFocusedKey(key);

          if (selectOnFocus) {
            manager.replaceSelection(key);
          }
        }
      }; // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
      // Attempt to detect whether the user is tabbing forward or backward into the collection
      // and either focus the first or last item accordingly.


      let relatedTarget = e.relatedTarget;

      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        var _manager$lastSelected;

        navigateToFirstKey((_manager$lastSelected = manager.lastSelectedKey) != null ? _manager$lastSelected : delegate.getLastKey());
      } else {
        var _manager$firstSelecte;

        navigateToFirstKey((_manager$firstSelecte = manager.firstSelectedKey) != null ? _manager$firstSelecte : delegate.getFirstKey());
      }
    } else if (!isVirtualized) {
      // Restore the scroll position to what it was before.
      scrollRef.current.scrollTop = scrollPos.current.top;
      scrollRef.current.scrollLeft = scrollPos.current.left; // Refocus and scroll the focused item into view if it exists within the scrollable region.

      let element = scrollRef.current.querySelector("[data-key=\"" + manager.focusedKey + "\"]");

      if (element) {
        // This prevents a flash of focus on the first/last element in the collection
        focusWithoutScrolling(element);
        $a9b9aa71af07c56ab1d89ca45381f4b$var$scrollIntoView(scrollRef.current, element);
      }
    }
  };

  let onBlur = e => {
    // Don't set blurred and then focused again if moving focus within the collection.
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };

  const autoFocusRef = useRef(autoFocus);
  useEffect(() => {
    if (autoFocusRef.current) {
      let focusedKey = null; // Check focus strategy to determine which item to focus

      if (autoFocus === 'first') {
        focusedKey = delegate.getFirstKey();
      }

      if (autoFocus === 'last') {
        focusedKey = delegate.getLastKey();
      } // If there are any selected keys, make the first one the new focus target


      let selectedKeys = manager.selectedKeys;

      if (selectedKeys.size) {
        focusedKey = selectedKeys.values().next().value;
      }

      manager.setFocused(true);
      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.

      if (focusedKey == null && !shouldUseVirtualFocus) {
        focusSafely(ref.current);
      }
    }

    autoFocusRef.current = false; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // If not virtualized, scroll the focused element into view when the focusedKey changes.
  // When virtualized, Virtualizer handles this internally.

  useEffect(() => {
    if (!isVirtualized && manager.focusedKey && scrollRef != null && scrollRef.current) {
      let element = scrollRef.current.querySelector("[data-key=\"" + manager.focusedKey + "\"]");

      if (element) {
        $a9b9aa71af07c56ab1d89ca45381f4b$var$scrollIntoView(scrollRef.current, element);
      }
    }
  }, [isVirtualized, scrollRef, manager.focusedKey]);
  let handlers = {
    onKeyDown,
    onFocus,
    onBlur,

    onMouseDown(e) {
      // Ignore events that bubbled through portals.
      if (e.currentTarget.contains(e.target)) {
        // Prevent focus going to the collection when clicking on the scrollbar.
        e.preventDefault();
      }
    }

  };
  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: manager
  });

  if (!disallowTypeAhead) {
    handlers = mergeProps(typeSelectProps, handlers);
  } // If nothing is focused within the collection, make the collection itself tabbable.
  // This will be marshalled to either the first or last item depending on where focus came from.
  // If using virtual focus, don't set a tabIndex at all so that VoiceOver on iOS 14 doesn't try
  // to move real DOM focus to the element anyway.


  let tabIndex;

  if (!shouldUseVirtualFocus) {
    tabIndex = manager.focusedKey == null ? 0 : -1;
  }

  return {
    collectionProps: _babelRuntimeHelpersEsmExtends({}, handlers, {
      tabIndex
    })
  };
}
/**
 * Scrolls `scrollView` so that `element` is visible.
 * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),
 * but doesn't affect parents above `scrollView`.
 */

function $a9b9aa71af07c56ab1d89ca45381f4b$var$scrollIntoView(scrollView, element) {
  let offsetX = $a9b9aa71af07c56ab1d89ca45381f4b$var$relativeOffset(scrollView, element, 'left');
  let offsetY = $a9b9aa71af07c56ab1d89ca45381f4b$var$relativeOffset(scrollView, element, 'top');
  let width = element.offsetWidth;
  let height = element.offsetHeight;
  let x = scrollView.scrollLeft;
  let y = scrollView.scrollTop;
  let maxX = x + scrollView.offsetWidth;
  let maxY = y + scrollView.offsetHeight;

  if (offsetX <= x) {
    x = offsetX;
  } else if (offsetX + width > maxX) {
    x += offsetX + width - maxX;
  }

  if (offsetY <= y) {
    y = offsetY;
  } else if (offsetY + height > maxY) {
    y += offsetY + height - maxY;
  }

  scrollView.scrollLeft = x;
  scrollView.scrollTop = y;
}
/**
 * Computes the offset left or top from child to ancestor by accumulating
 * offsetLeft or offsetTop through intervening offsetParents.
 */


function $a9b9aa71af07c56ab1d89ca45381f4b$var$relativeOffset(ancestor, child, axis) {
  const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';
  let sum = 0;

  while (child.offsetParent) {
    sum += child[prop];

    if (child.offsetParent === ancestor) {
      // Stop once we have found the ancestor we are interested in.
      break;
    } else if (child.offsetParent.contains(ancestor)) {
      // If the ancestor is not `position:relative`, then we stop at
      // _its_ offset parent, and we subtract off _its_ offset, so that
      // we end up with the proper offset from child to ancestor.
      sum -= ancestor[prop];
      break;
    }

    child = child.offsetParent;
  }

  return sum;
}

/**
 * Handles interactions with an item in a selectable collection.
 */
export function useSelectableItem(options) {
  let {
    selectionManager: manager,
    key,
    ref,
    shouldSelectOnPressUp,
    isVirtualized,
    shouldUseVirtualFocus,
    focus,
    isDisabled,
    onAction
  } = options;

  let onSelect = e => {
    if (e.pointerType === 'keyboard' && $d9657c365c2f735bcaf048eee8599a4a$export$isNonContiguousSelectionModifier(e)) {
      manager.toggleSelection(key);
    } else {
      if (manager.selectionMode === 'none') {
        return;
      }

      if (manager.selectionMode === 'single') {
        if (manager.isSelected(key) && !manager.disallowEmptySelection) {
          manager.toggleSelection(key);
        } else {
          manager.replaceSelection(key);
        }
      } else if (e && e.shiftKey) {
        manager.extendSelection(key);
      } else if (manager.selectionBehavior === 'toggle' || e && ($d9657c365c2f735bcaf048eee8599a4a$export$isCtrlKeyPressed(e) || e.pointerType === 'touch' || e.pointerType === 'virtual')) {
        // if touch or virtual (VO) then we just want to toggle, otherwise it's impossible to multi select because they don't have modifier keys
        manager.toggleSelection(key);
      } else {
        manager.replaceSelection(key);
      }
    }
  }; // Focus the associated DOM node when this item becomes the focusedKey


  let isFocused = key === manager.focusedKey;
  useEffect(() => {
    if (isFocused && manager.isFocused && !shouldUseVirtualFocus && document.activeElement !== ref.current) {
      if (focus) {
        focus();
      } else {
        focusSafely(ref.current);
      }
    }
  }, [ref, isFocused, manager.focusedKey, manager.childFocusStrategy, manager.isFocused, shouldUseVirtualFocus]); // Set tabIndex to 0 if the element is focused, or -1 otherwise so that only the last focused
  // item is tabbable.  If using virtual focus, don't set a tabIndex at all so that VoiceOver
  // on iOS 14 doesn't try to move real DOM focus to the item anyway.

  let itemProps = {};

  if (!shouldUseVirtualFocus) {
    itemProps = {
      tabIndex: isFocused ? 0 : -1,

      onFocus(e) {
        if (e.target === ref.current) {
          manager.setFocusedKey(key);
        }
      }

    };
  }

  let modality = useRef(null);
  let hasPrimaryAction = onAction && manager.selectionMode === 'none';
  let hasSecondaryAction = onAction && manager.selectionMode !== 'none' && manager.selectionBehavior === 'replace';
  let allowsSelection = !isDisabled && manager.canSelectItem(key); // By default, selection occurs on pointer down. This can be strange if selecting an
  // item causes the UI to disappear immediately (e.g. menus).
  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.
  // onPress requires a pointer down event on the same element as pointer up. For menus,
  // we want to be able to have the pointer down on the trigger that opens the menu and
  // the pointer up on the menu item rather than requiring a separate press.
  // For keyboard events, selection still occurs on key down.

  let itemPressProps = {};

  if (shouldSelectOnPressUp) {
    itemPressProps.onPressStart = e => {
      modality.current = e.pointerType;

      if (e.pointerType === 'keyboard') {
        onSelect(e);
      }
    };

    itemPressProps.onPressUp = e => {
      if (e.pointerType !== 'keyboard') {
        onSelect(e);
      }
    };

    itemPressProps.onPress = hasPrimaryAction ? () => onAction() : null;
  } else {
    // On touch, it feels strange to select on touch down, so we special case this.
    itemPressProps.onPressStart = e => {
      modality.current = e.pointerType;

      if (e.pointerType !== 'touch' && e.pointerType !== 'virtual') {
        onSelect(e);
      }
    };

    itemPressProps.onPress = e => {
      if (e.pointerType === 'touch' || e.pointerType === 'virtual' || hasPrimaryAction) {
        // Single tap on touch with selectionBehavior = 'replace' performs an action, i.e. navigation.
        // Also perform action on press up when selectionMode = 'none'.
        if (hasPrimaryAction || hasSecondaryAction) {
          onAction();
        } else {
          onSelect(e);
        }
      }
    };
  }

  if (!isVirtualized) {
    itemProps['data-key'] = key;
  }

  itemPressProps.preventFocusOnPress = shouldUseVirtualFocus;
  let {
    pressProps,
    isPressed
  } = usePress(itemPressProps); // Double clicking with a mouse with selectionBehavior = 'replace' performs an action.

  let onDoubleClick = hasSecondaryAction ? e => {
    if (modality.current === 'mouse') {
      e.stopPropagation();
      e.preventDefault();
      onAction();
    }
  } : undefined; // Long pressing an item with touch when selectionBehavior = 'replace' switches the selection behavior
  // to 'toggle'. This changes the single tap behavior from performing an action (i.e. navigating) to
  // selecting, and may toggle the appearance of a UI affordance like checkboxes on each item.
  // TODO: what about when drag and drop is also enabled??

  let {
    longPressProps
  } = useLongPress({
    isDisabled: !hasSecondaryAction,

    onLongPress(e) {
      if (e.pointerType === 'touch') {
        onSelect(e);
        manager.setSelectionBehavior('toggle');
      }
    }

  }); // Pressing the Enter key with selectionBehavior = 'replace' performs an action (i.e. navigation).

  let onKeyUp = hasSecondaryAction ? e => {
    if (e.key === 'Enter') {
      onAction();
    }
  } : undefined;
  return {
    itemProps: mergeProps(itemProps, allowsSelection || hasPrimaryAction ? pressProps : {}, hasSecondaryAction ? longPressProps : {}, {
      onKeyUp,
      onDoubleClick
    }),
    isPressed
  };
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
export class ListKeyboardDelegate {
  constructor(collection, disabledKeys, ref, collator) {
    this.collection = void 0;
    this.disabledKeys = void 0;
    this.ref = void 0;
    this.collator = void 0;
    this.collection = collection;
    this.disabledKeys = disabledKeys;
    this.ref = ref;
    this.collator = collator;
  }

  getKeyBelow(key) {
    key = this.collection.getKeyAfter(key);

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getKeyAbove(key) {
    key = this.collection.getKeyBefore(key);

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getFirstKey() {
    let key = this.collection.getFirstKey();

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getLastKey() {
    let key = this.collection.getLastKey();

    while (key != null) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getItem(key) {
    return this.ref.current.querySelector("[data-key=\"" + key + "\"]");
  }

  getKeyPageAbove(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);

    while (item && item.offsetTop > pageY) {
      key = this.getKeyAbove(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyPageBelow(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);

    while (item && item.offsetTop < pageY) {
      key = this.getKeyBelow(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyForSearch(search, fromKey) {
    if (!this.collator) {
      return null;
    }

    let collection = this.collection;
    let key = fromKey || this.getFirstKey();

    while (key != null) {
      let item = collection.getItem(key);
      let substring = item.textValue.slice(0, search.length);

      if (item.textValue && this.collator.compare(substring, search) === 0) {
        return key;
      }

      key = this.getKeyBelow(key);
    }

    return null;
  }

}

/**
 * Handles interactions with a selectable list.
 */
export function useSelectableList(props) {
  let {
    selectionManager,
    collection,
    disabledKeys,
    ref,
    keyboardDelegate,
    autoFocus,
    shouldFocusWrap,
    isVirtualized,
    disallowEmptySelection,
    selectOnFocus = false,
    disallowTypeAhead,
    shouldUseVirtualFocus,
    allowsTabNavigation
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]);
  let {
    collectionProps
  } = useSelectableCollection({
    ref,
    selectionManager,
    keyboardDelegate: delegate,
    autoFocus,
    shouldFocusWrap,
    disallowEmptySelection,
    selectOnFocus,
    disallowTypeAhead,
    shouldUseVirtualFocus,
    allowsTabNavigation,
    isVirtualized,
    scrollRef: ref
  });
  return {
    listProps: collectionProps
  };
}
//# sourceMappingURL=module.js.map
