'use strict';

/**
 * The Base64 Converter
 *
 * @class Base64
 * @constructor
 */
var Base64 = function Base64() {
  var inverseDigits = [];
  var i;
  for (i = 0; i < 256; ++i) {
    inverseDigits[i] = 0xff;
  }

  for (i = 0; i < this.BASE64_DIGITS.length; ++i) {
    inverseDigits[this.BASE64_DIGITS.charCodeAt(i)] = i;
  }

  this._inverseData = String.fromCharCode.apply(String, inverseDigits);
};

Base64.prototype.BASE64_DIGITS =
    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
Base64.prototype.STRING_CHUNK_SIZE = 4096;

Base64.prototype._stringFromCharCode = function(data) {
  if (data.length < this.STRING_CHUNK_SIZE) {
    return String.fromCharCode.apply(String, data);
  }

  var ptr = 0;
  var result = [];
  do {
    result.push(String.fromCharCode.apply(
        String, data.slice(ptr, ptr + this.STRING_CHUNK_SIZE)));
    ptr += this.STRING_CHUNK_SIZE;
  } while (ptr < data.length);
  return result.join('');
};

/**
 * Converts a string to a base64 string
 *
 * @param {string} str The string to be encoded.
 * @return {string} Base64 encoded string.
**/
Base64.prototype.encode = function(str) {
  if (typeof str !== 'string') {
    return '';
  }

  // Check if we are in the browser and use the
  // native encoding functions if they exist.
  if (typeof window !== 'undefined') {
    if (typeof window.btoa !== 'undefined') {
      return window.btoa(str);
    }
  }

  var out;
  var i;
  var len;
  var c1;
  var c2;
  var c3;

  len = str.length;
  i = 0;
  out = '';
  while (i < len) {
    c1 = str.charCodeAt(i++) & 0xff;
    if (i === len) {
      out += this.BASE64_DIGITS.charAt(c1 >> 2);
      out += this.BASE64_DIGITS.charAt((c1 & 0x3) << 4);
      out += '==';
      break;
    }
    c2 = str.charCodeAt(i++);
    if (i === len) {
      out += this.BASE64_DIGITS.charAt(c1 >> 2);
      out += this.BASE64_DIGITS.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));
      out += this.BASE64_DIGITS.charAt((c2 & 0xF) << 2);
      out += '=';
      break;
    }
    c3 = str.charCodeAt(i++);
    out += this.BASE64_DIGITS.charAt(c1 >> 2);
    out += this.BASE64_DIGITS.charAt(((c1 & 0x3) << 4) | ((c2 & 0xF0) >> 4));
    out += this.BASE64_DIGITS.charAt(((c2 & 0xF) << 2) | ((c3 & 0xC0) >> 6));
    out += this.BASE64_DIGITS.charAt(c3 & 0x3F);
  }
  return out;
};

/**
 * Decodes a base64 string to a normal string
 *
 * @param {string} str The Base64 string to be decoded.
 * @return {string} The decoded string.
**/
Base64.prototype.decode = function(str) {
  // Check if we are in the browser and use the
  // native decoding functions if they exist.
  if (typeof window !== 'undefined') {
    if (typeof window.atob !== 'undefined') {
      return window.atob(str);
    }
  }

  var ret = [];
  var len = str.length;
  var tmp0;
  var tmp1;
  var j = 0;

  /* eslint no-constant-condition: 0 */
  while (true) {
    do {
      tmp0 = this._inverseData.charCodeAt(str.charCodeAt(j++) & 0xff);
    } while (tmp0 === 0xff && j < len);
    do {
      tmp1 = this._inverseData.charCodeAt(str.charCodeAt(j++) & 0xff);
    } while (tmp1 === 0xff && j < len);
    if (tmp1 === 0xff) {
      break;
    }
    ret.push(((tmp0 << 2) | (tmp1 >> 4)) & 0xff);
    do {
      tmp0 = this._inverseData.charCodeAt(str.charCodeAt(j++) & 0xff);
    } while (tmp0 === 0xff && j < len);
    if (tmp0 === 0xff) {
      break;
    }
    ret.push(((tmp1 << 4) | (tmp0 >> 2)) & 0xff);
    do {
      tmp1 = this._inverseData.charCodeAt(str.charCodeAt(j++) & 0xff);
    } while (tmp1 === 0xff && j < len);
    if (tmp1 === 0xff) {
      break;
    }
    ret.push(((tmp0 << 6) | (tmp1)) & 0xff);
  }

  return this._stringFromCharCode(ret);
};


var base64 = new Base64();


/**
 * Export public interface
 */
module.exports = {
  encode: base64.encode.bind(base64),
  decode: base64.decode.bind(base64)
};
