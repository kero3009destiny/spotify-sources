'use strict';

var Method = require('spotify-transport/types/method');
var Promise = require('spotify-promise-plus');
var consoleLogging = require('spotify-debug-tools/logging');

var consoleLogger = consoleLogging.forTag('Logh.Uploader');

var BATCH_SIZE = 20;
var BIG_BATCH_SIZE = 100;

var AUTHENTICATED_ENDPOINT = '@webgate/gabo-receiver-service/v3/events';
var UNAUTHENTICATED_ENDPOINT =
  '@webgate/gabo-receiver-service/public/v3/events';

/**
 * Create a new Uploader instance.
 * Handles uploading an array of events to the event delivery endpoint.
 *
 * @param {module:spotify-event-sender/types.UploaderConfig} opts The uploader
 *     config.
 */
function Uploader(opts) {
  var options = opts || {};
  this._transport = options.transport;
  this._enableDebugInfo = options.enableDebugInfo || false;
  this._suppressPersist = options.suppressPersist || false;
  this._backoff = false;
}

/**
 * Create an uploader instance.
 *
 * @param {module:spotify-event-sender/types.UploaderConfig} opts The uploader
 *     config.
 * @return {Uploader} An uploader instance.
 */
Uploader.create = function(opts) {
  return new Uploader(opts);
};

/**
 * Upload events to the events delivery endpoint.
 *
 * @param {Array.<Object>} evts The events to be uploaded.
 * @param {?Array.<Object>} nacked The accumulator for non acknowledged events.
 * @return {Promise.<Object>} Will be ressolved with non acknowledged events and
 *     a flag for if backoff has been triggered.
 */
Uploader.prototype.upload = function(evts, nacked) {
  var nack = nacked || [];

  if (!evts.length) {
    return Promise.resolve({
      nack: nack,
      backoff: this._backoff
    });
  }

  var events = evts.slice(0);

  return this._uploadBatch(events.splice(0, BATCH_SIZE))
    .then(function(nackedEvents) {
      // put back nacked events in queue
      nack = nack.concat(nackedEvents);

      // if backoff, put back rest of events in queue
      if (this._backoff) {
        nack = nack.concat(events);
      } else if (events.length) {
        return this.upload(events, nack);
      }

      return {
        nack: nack,
        backoff: this._backoff
      };
    }.bind(this));
};

/**
 * Last effort to upload remaining events, uses BIG_BATCH_SIZE (100) instead of
 *     BATCH_SIZE (20), and does not retry nacked events or failed requests.
 *     Should be used when a client exits abnormally:
 *     For example when `window.onbeforeunload` is triggered.
 *
 * @param {Array.<Object>} events The events to be uploaded.
 * @return {Promise.<boolean>} Will be resolved when the last batch has been
 *     sent.
 */
Uploader.prototype.lastUpload = function(events) {
  if (!events.length) {
    return Promise.resolve(true);
  }

  return this._uploadBatch(events.splice(0, BIG_BATCH_SIZE))
    .then(function() {
      return true;
    });
};

/**
 * Upload one batch of events to the endpoint.
 *
 * @param {Array.<Object>} events The events to be uploaded.
 * @return {Promise.<Array>} All events that could not be acknowledged.
 */
Uploader.prototype._uploadBatch = function(events) {
  var authorize = this._transport.isAuthenticated();
  var webgateEndpoint = authorize ?
    AUTHENTICATED_ENDPOINT :
    UNAUTHENTICATED_ENDPOINT;
  return this._transport.request(webgateEndpoint, {
    method: Method.POST,
    payload: JSON.stringify({
      suppress_persist: this._suppressPersist,
      events: events
    }),
    headers: {
      'content-type': 'application/json'
    },
    responseType: 'json',
    authorize: authorize,
    withResponseHeaders: true
  }).then(function(response) {
    if (response.status !== 200) {
      consoleLogger.warn('Received error status', response);
      // Make user of function backoff
      this._backoff = true;
      return events;
    }

    var body = response.body;
    var headers = response.headers;

    var nackedEvents = [];
    if (body.error && body.error.length) {
      if (this._enableDebugInfo) {
        // See https://ghe.spotify.net/datainfra/gabo-receiver-service/blob/
        // master/receiver-service/src/main/proto/spotify/event/v3/event.proto
        // for explaination of the various "reason" codes
        consoleLogger.info('response errors', events, body.error);
      }
      for (var i = 0, len = body.error.length; i < len; i++) {
        if (body.error[i].transient) {
          // Retry events with transient errors
          nackedEvents.push(events[body.error[i].index]);
        }
      }
    }

    this._backoff = !!(headers && headers.get('backoff') === 'true');

    return nackedEvents;
  }.bind(this));
};

/**
 * Check if backoff has been requested during latest upload.
 *
 * @return {boolean} true if backoff has been requested, else false.
 */
Uploader.prototype.shouldBackoff = function() {
  return this._backoff;
};

module.exports = Uploader;
