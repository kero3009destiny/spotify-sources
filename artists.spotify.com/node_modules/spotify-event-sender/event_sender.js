'use strict';

var SequenceIdGenerator = require('./sequenceid_generator');
var Uploader = require('./uploader');
var Backoff = require('spotify-backoff');
var Event = require('spotify-transport/types').Event;
var contextSdk = require('./contexts/sdk');
var contextTime = require('./contexts/time');
var contextClientId = require('./contexts/clientId');
var consoleLogging = require('spotify-debug-tools/logging');
var Promise = require('spotify-promise-plus');

var consoleLogger = consoleLogging.forTag('EventSender');

var BACKOFF_BASETIME = 200;
var BACKOFF_CEILING = 300000; // 5 minutes
var BACKOFF_MAX_DURATION = 1800000; // 30 minutes

/**
 * Create a new EventSender instance.
 *
 * @param {module:spotify-event-sender/types.EventSenderConfig} opts The logger
 *     options.
 */
function EventSender(opts) {
  var options = opts || {};

  this._transport = options.transport;

  this._upload = this._upload.bind(this);
  this._shouldRetry = this._shouldRetry.bind(this);
  this._uploadWaiting = false;

  this._sequenceIdGenerator = SequenceIdGenerator.create();

  this._uploader = Uploader.create({
    enableDebugInfo: options.enableDebugInfo,
    suppressPersist: options.suppressPersist,
    transport: this._transport
  });

  this._contextCreators = options.context || [];
  for (var i = 0, len = this._contextCreators.length; i < len; i++) {
    if (typeof this._contextCreators[i] !== 'function') {
      throw new Error('The context creator at index ' + i +
        ' is not a function');
    }
  }
  // Add the default context creators
  this._contextCreators.push(contextSdk);
  this._contextCreators.push(contextTime);
  if (options.clientId) {
    this._contextCreators.push(contextClientId(options.clientId));
  }

  this._refreshing = false;

  this._events = [];

  this._backoffBaseTime = options.baseTime || BACKOFF_BASETIME;
  this._backoffCeiling = options.ceiling || BACKOFF_CEILING;
  this._backoffMaxDuration = options.maxDuration || BACKOFF_MAX_DURATION;

  this._transport.on(
    Event.TRANSPORT_BEFORE_ONLINE_DISCONNECT,
    this._onBeforeDisconnect.bind(this)
  );
}

/**
 * Create a logger instance.
 *
 * @param {module:spotify-event-sender/types.EventSenderConfig} options The
 *     logger options.
 * @return {EventSender} A logger instance.
 */
EventSender.create = function(options) {
  return new EventSender(options);
};

/**
 * Handler for Event.TRANSPORT_BEFORE_ONLINE_DISCONNECT, attempts to upload the
 *      (max 100) unsent events.
 *
 * @param {Object} e Event from transport.
 * @param {Function} e.awaitPromise Callback used to attach the final flush
 *     to the list of things that will (in the best case scenario) happen
 *     before the runtime exits.
 */
EventSender.prototype._onBeforeDisconnect = function(e) {
  var promise = this._uploader.lastUpload(this._events.splice(0));
  if (e.data && e.data.awaitPromise) {
    // Transport 6.0
    e.data.awaitPromise(promise);
  } else {
    e.awaitPromise(promise);
  }
};

/**
 * Check if backoff should retry.
 *
 * @return {boolean} true if the request should be retried, else false.
 */
EventSender.prototype._shouldRetry = function() {
  return this._transport.isOnline() && !this._refreshing;
};

/**
 * Start the backoff sequence to upload the events.
 *
 * @return {Promise} Will be fulfilled with the upload response.
 */
EventSender.prototype._initFlush = function() {
  var baseTime = this._backoffBaseTime;
  var backoffInitial = false;
  if (this._uploader.shouldBackoff()) {
    baseTime = this._backoffCeiling;
    backoffInitial = true;
  }

  return Backoff.init(this._upload, {
    algo: 'exp',
    baseTime: baseTime,
    ceiling: this._backoffCeiling,
    maxDuration: this._backoffMaxDuration,
    backoffInitial: backoffInitial,
    retryPredicate: this._shouldRetry
  });
};

/**
 * Wait for connection to become online.
 *
 * @return {Promise} Will be resolved when the connection is online.
 */
EventSender.prototype._waitForConnection = function() {
  return new Promise(function(resolve) {
    this._transport.once(
      Event.TRANSPORT_CONNECTION_ONLINE,
      resolve
    );
  }.bind(this));
};

/**
 * Persist any not yet persisted events to the event delivery service.
 * Call this function before shutting down the application.
 *
 * @return {Promise.<void>} Will be resolved when request was done.
 */
EventSender.prototype.flush = function() {
  // When not connected
  if (!this._transport.isOnline()) {
    if (!this._ongoingUpload) {
      // Fake ongoing upload to be resolvved when there is a connection
      this._ongoingUpload = this._waitForConnection();
    }
  }

  // When another upload is already ongoing, queue the flush
  if (this._ongoingUpload) {
    // but only if there isn't already a queued flush
    if (!this._uploadWaiting) {
      this._uploadWaiting = true;
      this._ongoingUpload = this._ongoingUpload.then(function() {
        this._ongoingUpload = false;
        this._uploadWaiting = false;
        return this.flush();
      }.bind(this));
    }
    return this._ongoingUpload;
  }

  // When there are no events to upload
  if (!this._events.length) {
    return Promise.resolve({
      nack: this._events,
      backoff: this._uploader.shouldBackoff()
    });
  }

  this._ongoingUpload = this._initFlush()
    .then(function(response) {
      this._ongoingUpload = undefined;
      return response;
    }.bind(this)).catch(function() {
      this._ongoingUpload = undefined;

      if (!this._transport.isOnline()) {
        return this.flush();
      }

      if (!this._refreshing) {
        consoleLogger.warn(
          'The events in the queue could not be uploaded. Throwing away ' +
          this._events.length + ' events.'
        );

        this._events = [];
      }

      return {
        nack: this._events,
        backoff: this._uploader.shouldBackoff()
      };
    }.bind(this));

  return this._ongoingUpload;
};

/**
 * Upload all not yet uploaded events to the endpoint.
 *
 * @return {Promise.<Object>} Will be resolved with upload status when upload
 *     has finished.
 */
EventSender.prototype._upload = function() {
  return this._uploader.upload(this._events.splice(0))
    .then(function(response) {
      if (response.nack.length) {
        this._events = response.nack.concat(this._events);
        throw new Error('Backoff requested');
      }

      return response;
    }.bind(this));
};

/**
 * Log an event to the event delivery endpoint.
 * The message needs to be defined in event-definitions
 *
 * @param {module:spotify-event-sender/types.Message} message The message to be
 *     logged.
 * @param {boolean=} flush Set to false to postpone persisting the event.
 *     Default is true.
 */
EventSender.prototype.log = function(message, flush) {
  var event = {
    sequence_id: this._sequenceIdGenerator.getSequenceId(),
    sequence_number: this._sequenceIdGenerator.nextSequenceNumber(message.name),
    event_name: message.name
  };

  event.fragments = {
    message: message.data
  };

  // Attach all contexts
  for (var i = 0, len = this._contextCreators.length; i < len; i++) {
    var context = this._contextCreators[i].call(this);
    event.fragments[context.name] = context.data;
  }

  this._events.push(event);

  if (flush !== false) {
    this.flush();
  }
};

/**
 * Refresh this instance by first making an attempt to flush all not yet flushed
 * events to the endpoint, and then refreshing the access_token. The Sequence Id
 * and the Sequence Numbers will have been renewed in future logging.
 *
 * This function should be called when the user state in the client changes, for
 * example when the user logs in or out, or when there is a new user logged in.
 *
 * @return {Promise.<boolean>} Will be resolved with true when the refresh is
 *     done.
 */
EventSender.prototype.refresh = function() {
  this._sequenceIdGenerator.reset();
  // Flag for refreshing the logger instane to avoid retries to go on "forever"
  // as the token might soon be expired
  this._refreshing = true;

  // Send all events using the (hopefully) cached token.
  return this.flush()
    .then(function() {
      // Refresh the token
      return this._transport.forceTokenRefresh()
        .then(function(response) {
          this._refreshing = false;
          return response;
        }.bind(this));
    }.bind(this))
    .catch(function(error) {
      consoleLogger.warn('Could not flush using cached token', error);
      this._refreshing = false;
      return true;
    }.bind(this));
};

module.exports = EventSender;
