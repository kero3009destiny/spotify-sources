'use strict';

var defaults = require('../types').counterDefaults;

/**
 * Takes a number and returns it with +/-10% jitter.
 *
 * @type {Function}
 * @param {number} n The value to apply jitter to.
 * @return {number}
 */
function jitter(n) {
  var diff = (n / 5);
  return 0 | n - diff / 2 + Math.random() * diff;
}

/**
 * @constructor
 * @param {?module:spotify-backoff/types/counterOptions=} options Settings
 *     for counter instance.
 * @export module:spotify-backoff/counter
 */
function Counter(options) {
  var settings = options || {};

  /**
   * (Short) name of curve to use to calculate the backoff curve.
   *     Currently:
   *
   * @type {string}
   * @protected
   */
  this._curve = settings.curve || settings.algo || defaults.curve;

  /**
   * The minimum/base interval.
   *
   * @type {number}
   * @protected
   */
  this._baseTime = settings.baseTime || defaults.baseTime;

  /**
   * The ceiling property defines a max duration that does not terminate
   *     the backoff.
   *     Once this value is reached the backing off stops but the retrying
   *     continues with this value used as time between calls.
   *
   * @type {number}
   * @protected
   */
  this._ceiling = settings.ceiling || defaults.ceiling;

  /**
   * Flag for determining if the counter should apply some jitter to the
   *     return value in `getTime`.
   *     Defaults to `true`.
   *
   * @type {boolean}
   * @protected
   */
  this._jitter = !(settings.jitter === false);
}

/**
 * Returns the correct time until next tick, depending on chosen curve.
 *
 * @param {number} retries The number representing which order in the series
 *     of retries to calculate the time for.
 * @return {number} Return values are floored with `| 0` - this way is not
 *     only faster than `Math.floor` it also ensures they're not NaN.
 */
Counter.prototype.getTime = function(retries) {
  var time;
  switch (this._curve) {
    case 'static':
      time = 1;
      break;
    case 'logarithmic':
    case 'log':/* deprecated @see{module:spotify-backoff/types/counterOptions}*/
      time = Math.log(retries);
      break;
    case 'exponential':
    case 'exp':/* deprecated @see{module:spotify-backoff/types/counterOptions}*/
      time = Math.pow(Math.E, retries);
      break;
    case 'linear':
    case 'lin':/* deprecated @see{module:spotify-backoff/types/counterOptions}*/
    default:
      time = retries + 1;
      break;
  }
  var ret = time * this._baseTime | 0;
  if (this._ceiling) {
    ret = Math.min(ret, this._ceiling);
  }
  return this._jitter ? jitter(ret) : ret;
};

module.exports = Counter;
