'use strict';

var defaults = require('../types').backoffDefaults;

/**
 * A backoff module that handles retries and backoff with different timings
 *     depending on configuration.
 *     Expects a "thenable" function to retry.
 *
 * Usage:
 *     function getData(url) {
 *       return getRequest(url); // pretend function that returns ajax promise
 *     }
 *
 *     function sucessHandler(data) {
 *       console.log('great sucess!', data);
 *     }
 *
 *     Backoff.init(getData.bind(null, 'https://httpbin.org/get'))
 *       .then(successHandler)
 *       .catch(function() {
 *         console.log('you're out of luck!');
 *       });
 */

var Promise = require('spotify-promise-plus');
var Counter = require('./counter');

var slice = Array.prototype.slice;

/**
 * Backoff, handles backoff retries for async functions.
 *
 * @constructor
 * @export module:spotify-backoff
 * @param {Function} fn Thenable function to use the backoff with.
 * @param {?module:spotify-backoff/backoff-options=} opts Initialization
 *     options, extends/overrides defaults.
 */
function Backoff(fn, opts) {
  var options = opts || {};

  /**
   * Function to retry.
   *     Note that arguments to this function must be bound to it before adding
   *     it to the Backoff instance.
   *
   * @type {Function}
   * @protected
   */
  this._fn = fn;

  /**
   * Promise to resolve/reject when successful/failed.
   *
   * @type {Promise}
   * @protected
   */
  this._resolver = Promise.defer();

  /**
   * Max allowed number of milliseconds for the backoff to run.
   *
   * @type {number}
   * @protected
   */
  this._maxDuration = options.maxDuration || defaults.maxDuration;

  /**
   * Max number of allowed retries, optional (defaults to Infinity).
   *
   * @type {number}
   * @protected
   */
  this._maxRetries = 'maxRetries' in options ?
    options.maxRetries :
    defaults.maxRetries;

  /**
   * Max number of milliseconds for a single retry. If this is exceeded the
   *     backoff terminates, optional (defaults to Infinity).
   *
   * @type {number}
   * @protected
   */
  this._maxTime = options.maxTime || defaults.maxTime;

  /**
   * A predicate that receives an error and returns if it should retry
   *
   * @type {function}
   * @protected
   */
  this._retryPredicate = options.retryPredicate || defaults.retryPredicate;

  /**
   * Epoch timestamp, will be set when the backoff starts.
   *
   * @type {number}
   * @protected
   */
  this._ts = 0;

  /**
   * Number of executed retries.
   *
   * @type {number}
   * @protected
   */
  this._callCount = 0;

  /**
   * True if the first call should not be backed of, so the first call to tick
   *     will be delayed.
   *
   * @type {boolean}
   * @protected
   */
  this._backoffInitial = options.backoffInitial;

  /**
   * Timeout that holds the sleep until next retry.
   *
   * @type {number}
   * @protected
   */
  this._tickInterval = null;

  this._isRunning = false;

  this._counter = new Counter({
    curve: options.curve || options.algo,
    baseTime: options.baseTime,
    ceiling: options.ceiling
  });

  if (this._backoffInitial) {
    this._maxRetries += 1;
  }

  // rebind tick scope to self.
  this._tick = this._tick.bind(this);
}

/**
 * Initializes and starts a new backoff.
 *
 * @param {Function} fn Thenable function to use the backoff with.
 * @param {?module:spotify-backoff/backoff-options=} options Initialization
 *     options.
 * @return {Promise}
 * @static
 */
Backoff.init = function(fn, options) {
  return new Backoff(fn, options).start();
};

/**
 * Returns the resolver promise for a backoff instance.
 *
 * @return {Promise}
 */
Backoff.prototype.getResolver = function() {
  return this._resolver.promise;
};

/**
 * Starts the backoff, returns it's resolver promise.
 *
 * @param {?Function=} fn The function to start retrying.
 * @return {Promise}
 */
Backoff.prototype.start = function(fn) {
  if (!this._fn && fn) {
    this._fn = fn;
  }
  if (!this._isRunning) {
    this._ts = Date.now();
    this._isRunning = true;
    if (this._backoffInitial) {
      this._callCount = 1;
      this._tickInterval = setTimeout(
        this._tick,
        this._counter.getTime(0)
      );
    } else {
      this._tick();
    }
  }
  return this._resolver.promise;
};

/**
 * Stops a backoff instance, and destroys it.
 *
 */
Backoff.prototype.stop = function() {
  clearTimeout(this._tickInterval);
  this._isRunning = false;
  this._destroy();
};

/**
 * Destroys a backoff instance.
 *
 * @protected
 */
Backoff.prototype._destroy = function() {
  this._fn = null;
  this._resolver = null;
};

/**
 * Failure handler, will reset the timeout to the next point in the future.
 *
 * @param {Error} err The error from the failure that might cause a retry.
 * @protected
 */
Backoff.prototype._failure = function(err) {
  if (err && 'retryAfter' in err) {
    this._retryAfter(err);
  } else {
    var time = this._counter.getTime(this._callCount);
    var shouldRetry = this._shouldRetry(time, err);

    if (shouldRetry) {
      this._callCount++;
      this._tickInterval = setTimeout(this._tick, time);
    } else {
      this._resolver.reject(err);
      this._destroy();
    }
  }
};

/**
 * Failure handler for errors with the `retryAfter` property set, will retry
 *     once that ammount of milliseconds have passed.
 *
 * @param {Error} err The error from the failure that caused the retry.
 * @protected
 */
Backoff.prototype._retryAfter = function(err) {
  this._callCount++;
  this._tickInterval = setTimeout(this._tick, err.retryAfter);
};

/**
 * Success handler, resolves the resolver promise and makes the backoff
 *     self-destruct.
 *
 * @protected
 */
Backoff.prototype._success = function() {
  this._resolver.resolve.apply(null, slice.call(arguments));
  this._destroy();
};

/**
 * Test if backoff should retry.
 *
 * @param {number} time The time for the next tick timeout.
 * @param {Error} err The error from the failure that possibly might cause
 *     a retry.
 * @protected
 * @return {boolean}
 */
Backoff.prototype._shouldRetry = function(time, err) {
  var duration = (Date.now() - this._ts) + time;
  return this._callCount < this._maxRetries &&
      time < this._maxTime &&
      duration < this._maxDuration &&
      this._retryPredicate(err);
};

/**
 * Tick, timed-out function that initializes the next retry.
 *
 * @protected
 */
Backoff.prototype._tick = function() {
  this._fn()
    .then(this._success.bind(this))
    .catch(this._failure.bind(this));
};

module.exports = Backoff;
