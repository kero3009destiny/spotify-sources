'use strict';

var inherit = require('spotify-inheritance/inherit');
var extend = require('spotify-inheritance/extend');

var Backoff = require('spotify-backoff');
var BackoffCounter = require('spotify-backoff/lib/counter');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');

var PublicTransport = require('./_internal/public_transport');

var Dealer = require('./_internal/dealer');
var ConnectionObserver = require('./_internal/connection_observer');

var HTTPResponse = require('./_internal/http_response');

var StatusCode = require('./types/status_code');
var StatusFamily = require('./types/status_family');
var Event = require('./types/event');
var Errors = require('./types/errors');
var TransportError = require('./types/transport_error');
var NOT_A_TOKEN = require('./types/not_a_token');

var InternalSocketCode = require('./types/internal_socket_code');

var debugLogger = require('spotify-debug-tools/logging').forTag(
  'transport.transport'
);

/**
 * An expression for matching special URLs.
 *
 * @const
 * @private
 */
var HTTP_SPECIAL_URL_EXP = /^(?:https?:\/\/)?@([^\/]+)\//;

/**
 * An expression to check whether a WebSocket or HTTP URI requires an ending
 * slash.
 *
 * @const
 * @private
 */
var ENDPOINT_REQUIRES_SLASH_EXP = /^(ws|http)s?:\/\/.*[^\/]$/;

/**
 * An expression to check whether if a string is a valid HTTP-date.
 *     accepted format:
 *         Fri, 31 Dec 1999 23:59:59 GMT
 *
 * @const
 * @private
 */
var HTTP_DATE_EXP = /^([a-zA-Z]{3},\ \d{1,2}\ [a-zA-Z]{3}\ (\d{1,2}.){3})/;

/**
 * The default lifetime of an access token, in seconds.
 *
 * Note that the actual default lifetime of the token from Accounts is actually
 * 1 hour (3600 seconds), but we set the default token timeout to 59 minutes to
 * compensate for any transport costs from when the token was retrieved.
 *
 * @const
 * @private
 */
var DEFAULT_TOKEN_TIMEOUT = 3540;

/**
 * Threshold that needs to be reached before a dealer reconnection attempt will
 *     be made.
 *
 * @const
 * @private
 */
var RECONNECT_THRESHOLD = 5000;

/**
 * The default maximum retry value for a request
 *
 * @const
 * @private
 */
var DEFAULT_RETRY_COUNT = 2;

/**
 * A map of the various states that the `Transport` session is currently in.
 *
 * @enum {number}
 * @private
 */
var StateFlag = {
  CONNECTED: 1 << 0,
  AUTHENTICATED: 1 << 2
};

/**
 * The request modes that the `Transport` instance can support.
 *
 * @type {Object.<string, string>}
 * @protected
 */
var SupportedRequestModes = {
  'fetch': true,
  'xhr': true
};

/**
 * The matcher for the client logout message.
 *
 * @type {string}
 * @protected
 */
var LOGOUT_MESSAGE_URI = 'client:logout';

/**
 * A Transport object encapsulates the connection to the WebSocket AP.
 *
 * @constructor
 * @extends {module:spotify-eventemitter}
 * @param {module:spotify-transport/types.TransportConfig} config The config
 *     for this instance of Transport.
 * @exports spotify-transport
 */
function Transport(config) {
  if (!config) {
    throw new TypeError('Argument `config` for Transport cannot be null.');
  }
  if (!config.providers) {
    throw new TypeError(
      'Argument `config.providers` for Transport cannot be null.'
    );
  }
  EventEmitter.call(this);

  /**
   * An object reference to the owner of this transport instance.
   *
   * Note that this should be an object to ensure that the reference is unique.
   *
   * @type {Object}
   * @protected
   */
  this._ownerRef = 'ownerRef' in config ? Object(config.ownerRef) : {};

  /**
   * Provides the token for authentication.
   *
   * @type {module:spotify-transport/types.TokenProvider}
   * @protected
   */
  this._tokenProvider = config.providers.token;

  /**
   * Provides the endpoints for connection.
   *
   * @type {module:spotify-transport/types.EndpointsProvider}
   * @protected
   */
  this._endpointsProvider = config.providers.endpoints;

  /**
   * The requester used for making xhr requests.
   *
   * @type {module:spotify-transport/_internal/http}
   * @protected
   */
  this._HTTP = config.HTTP;

  /**
   * The requester used for making fetch requests.
   *
   * @type {module:spotify-transport/_internal/fetch}
   * @protected
   */
  this._Fetch = config.Fetch;

  /**
   * The requester used for making fetch requests.
   *
   * @type {module:spotify-transport/_internal/fetch}
   * @protected
   */
  /**
   * The websocket implementation class that will be used with Dealer.
   *
   * @type {WebSocket}
   * @protected
   */
  this._WebSocket = config.WebSocket;

  /**
   * The amount of reconnections allowed for the instance.
   *
   * @type {number}
   * @protected
   */
  this._reconnectionRetries = config.reconnectionRetries >= 0 ?
    config.reconnectionRetries :
    3;

  /**
   * The underlying mode to use in the request. Can be 'xhr' or 'fetch'.
   *
   * @type {string}
   * @protected
   */
  this._requestMode = config.requestMode in SupportedRequestModes ?
    config.requestMode :
    'xhr';

  /**
   * A map of response types to force polyfill.
   *
   * @type {Object.<string, boolean>}
   * @protected
   */
  this._forcePolyfillTypes = config.forcePolyfillTypes || {};

  /**
   * A flag indicating whether to logout automatically when we receive a message
   * from the backend telling all devices to logout.
   *
   * @type {boolean}
   * @protected
   */
  this._disableAutoLogout = 'disableAutoLogout' in config ?
    config.disableAutoLogout :
    false;

  // Internal

  /**
   * A boolean flag that indicates whether or not the instance has explicitly
   * been activated (i.e., `connect()` was called).)
   *
   * This is checked in the online-offline observers to check whether or not to
   * reconnect. If this flag is set to `false`, the reconnection logic for
   * `_onOnline` will not get triggered (as that meant that the instance was
   * never connected in the first place).
   *
   * @type {boolean}
   * @protected
   */
  this._activated = false;

  /**
   * The Dealer instance.
   *
   * @type {module:spotify-transport/_internal/dealer}
   * @protected
   */
  this._dealer = null;

  /**
   * The connection observer.
   *
   * @type {module:spotify-transport/_internal/connection_observer}
   * @protected
   */
  this._connectionObserver = null;

  /**
   * A map of the messaging endpoints for this Harmony instance. Populated by
   * the endpoint provider.
   *
   * @type {Object.<string, string>}
   * @protected
   */
  this._endpoints = null;

  /**
   * The last token used for authentication.
   *
   * @type {string}
   * @protected
   */
  this._lastToken = null;

  /**
   * The expiry time of the last token used.
   *
   * @type {number}
   * @protected
   */
  this._lastTokenExpiry = 0;

  /**
   * The promise that was generated by the last `Transport#_refreshToken` call.
   * Used to catch multiple calls to `Transport#_refreshToken()`.
   *
   * @type {Promise.<string>}
   * @protected
   */
  this._refreshTokenPromise = null;

  /**
   * The promise that was generated by the last `Transport#authenticate` call.
   * Used to catch multiple calls to `Transport#authenticate`.
   *
   * @type {boolean}
   * @protected
   */
  this._authenticationPromise = false;

  /**
   * A timeout used for throttling connection retries.
   *
   * @type {number}
   * @protected
   */
  this._reconnectTimeout = null;

  /**
   * A flag that indicated whether we are currently reconnecting.
   *
   * @type {boolean}
   * @protected
   */
  this._isReconnecting = false;

  /**
   * The timestamp of the last successful authentication.
   *
   * @type {number}
   * @protected
   */
  this._initTime = 0;

  /**
   * The timestamp of the last disconnection from dealer.
   *
   * @type {number}
   * @protected
   */
  this._lastDisconnect = 0;

  /**
   * A bitmask of the states where the `Transport` instance currently is.
   *
   * @type {number}
   * @protected
   */
  this._stateMask = 0;

  /**
   * Counter for number of (in succession) "quick disconnects", used to
   *     calculate how long the "next" backoff timeout for trying to
   *     reconnect should be.
   *
   * @type {number}
   * @protected
   */
  this._quickDisconnectCount = 0;

  /**
    * True if transport should "disconnect" when the client window fires the
    *     "beforeunload" event, ie when the browser window is closed.
    *
    * @type {boolean}
    * @protected
    */
  this._disconnectBeforeUnload = config.disconnectBeforeUnload || false;

  this._counter = new BackoffCounter(config.backoffStrategy || {
    algo: 'exp',
    baseTime: 5000,
    ceiling: 15000
  });

  /**
   * A map of listeners for the state-aware events.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._stateAwareListeners = {
    connected: [],
    authenticated: [],
    connection_id: []
  };

  /**
   * The scheduled runners for state-aware events.
   *
   * @type {Object.<string, ?Promise>}
   * @protected
   */
  this._stateAwareRunners = {
    connected: null,
    authenticated: null,
    connection_id: null
  };

  // Rebind
  this._onAuthenticated = this._onAuthenticated.bind(this);
  this._onAuthenticationFailed =
    this._onAuthenticationFailed.bind(this);
  this._parseProvidedToken = this._parseProvidedToken.bind(this);

  this._init();
}
inherit(Transport, EventEmitter);

/**
 * Creates a new `Transport` instance.
 *
 * @param {module:spotify-transport/types.TransportConfig} config The config
 *     for this instance of Transport.
 * @return {module:spotify-transport/transport}
 */
Transport.create = function createTransport(config) {
  return new Transport(config);
};

// Initialization

/**
 * Initialize the Transport instance.
 *
 * @protected
 */
Transport.prototype._init = function() {
  // State-aware listeners
  this.onAddListener(
    Event.TRANSPORT_CONNECTED,
    this._onAddListener.bind(this, 'connected')
  );
  this.onAddListener(
    Event.TRANSPORT_AUTHENTICATED,
    this._onAddListener.bind(this, 'authenticated')
  );
  this.onAddListener(
    Event.TRANSPORT_CONNECTION_ID,
    this._onAddListener.bind(this, 'connection_id')
  );
  this.onRemoveListener(
    Event.TRANSPORT_CONNECTED,
    this._onRemoveListener.bind(this, 'connected')
  );
  this.onRemoveListener(
    Event.TRANSPORT_AUTHENTICATED,
    this._onRemoveListener.bind(this, 'authenticated')
  );
  this.onRemoveListener(
    Event.TRANSPORT_CONNECTION_ID,
    this._onRemoveListener.bind(this, 'connection_id')
  );

  // Verify fetch support
  if (this._requestMode === 'fetch' && !this._Fetch.isSupported()) {
    debugLogger.warn(
      'Default "fetch" request mode unavailable; Fallback to "xhr"'
    );
    this._requestMode = 'xhr';
  }


  var dealer = new Dealer({
    WebSocket: this._WebSocket
  });
  this._dealer = dealer;

  dealer.on(Event.DEALER_DISCONNECTED, this._onDealerDisconnected.bind(this));

  if (!this._disableAutoLogout) {
    this.matchMessages(LOGOUT_MESSAGE_URI, this._onLogout.bind(this));
  }

  this.proxyEmit(
    dealer,
    Event.DEALER_CONNECTION_ID,
    Event.TRANSPORT_CONNECTION_ID
  );
  this.proxyEmitSync(
    dealer,
    Event.DEALER_MESSAGE,
    Event.INTERNAL_DEALER_MESSAGE
  );
  this.proxyEmitSync(
    dealer,
    Event.DEALER_REQUEST,
    Event.INTERNAL_DEALER_REQUEST
  );

  this._connectionObserver = new ConnectionObserver({
    notifyBeforeUnload: this._disconnectBeforeUnload
  });

  this._connectionObserver.on(
    Event.CONNECTION_ONLINE,
    this._onOnline.bind(this)
  );
  this._connectionObserver.on(
    Event.CONNECTION_OFFLINE,
    this._onOffline.bind(this)
  );
  this._connectionObserver.on(
    Event.WINDOW_BEFORE_UNLOAD,
    this.disconnect.bind(this)
  );
};

// Event Emitter Overrides

/**
 * Handles adding state-aware events.
 *
 * @param {string} type The listener type.
 * @param {module:spotify-eventemitter~Event} event The add listener meta-event.
 */
Transport.prototype._onAddListener = function(type, event) {
  if (event.options.ignoreCurrentState) {
    // Do not process state-aware event--it has been explicitly disabled.
    return;
  }
  var eventPromise = null;
  switch (type) {
    case 'connected':
      if (!this.isConnected()) {
        return;
      }
      eventPromise = Promise.resolve(
        EventEmitter.createEvent(Event.TRANSPORT_CONNECTED)
      );
      break;
    case 'authenticated':
      if (!this.isAuthenticated()) {
        return;
      }
      eventPromise = Promise.resolve(
        EventEmitter.createEvent(Event.TRANSPORT_AUTHENTICATED)
      );
      break;
    case 'connection_id':
      if (!this._dealer.hasConnectionId()) {
        return;
      }
      eventPromise = this._dealer.getConnectionInfo()
        .then(function(connectionInfo) {
          return EventEmitter.createEvent(
            Event.TRANSPORT_CONNECTION_ID,
            connectionInfo
          );
        });
      break;
    default:
      return;
  }
  var listener = event.listener;
  this._stateAwareListeners[type].push(listener);
  // Check and schedule if necessary.
  var runners = this._stateAwareRunners;
  if (runners[type]) {
    return;
  }
  runners[type] = eventPromise
    .then(this._runStateAwareQueues.bind(this, type));

  if (event.options.once) {
    // This is a once event listener, so we don't want it to get added as an
    // actual listener since it's already scheduled.
    event.preventDefault();
  }
};

/**
 * Handles removing state-aware events.
 *
 * @param {string} type The listener type.
 * @param {module:spotify-eventemitter~Event} event The remove listener
 *     meta-event.
 */
Transport.prototype._onRemoveListener = function(type, event) {
  if (event.options.ignoreCurrentState) {
    // Do not process state-aware event--it has been explicitly disabled.
    return;
  }
  var listener = event.listener;
  var index = this._stateAwareListeners[type].indexOf(listener);
  if (index === -1) {
    return;
  }
  this._stateAwareListeners[type].splice(index, 1);
};

/**
 * Runs the queue of listeners that were added for state-aware events.
 *
 * @param {string} type The listener type.
 * @param {module:spotify-eventemitter~Event} event The Event object that will
 *     be passed to the listeners that will be executed.
 */
Transport.prototype._runStateAwareQueues = function(type, event) {
  var listeners = this._stateAwareListeners[type].splice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
  }
  this._stateAwareRunners[type] = null;
};

// Event Handlers

/**
 * Handles `Event.DEALER_DISCONNECTED`.
 *
 * @protected
 * @param {module:spotify-eventemitter/types/event} event The disconnected
 *     event.
 */
Transport.prototype._onDealerDisconnected = function(event) {
  var now = Date.now();
  var sessionLength = now - this._lastDisconnect;
  this._disconnect(true);

  if (event.wsCode === InternalSocketCode.CLOSE) {
    // Explicit disconnect, do not try to reconnect.
    this._quickDisconnectCount = 0;
    return;
  }

  if (!this._connectionObserver.isOnline()) {
    // Browser is offline, do not reconnect right now. Will be handled by
    // `_onOnline`.
    return;
  }

  if (sessionLength < RECONNECT_THRESHOLD) {
    if (this._reconnectTimeout) {
      clearTimeout(this._reconnectTimeout);
      this._quickDisconnectCount++;
      this.emit(Event.TRANSPORT_SHORT_SESSION_DISCONNECTED, {
        disconnectCount: this._quickDisconnectCount,
        sessionLength: sessionLength
      });
    }
    this._reconnectTimeout = setTimeout(
      this._tryToReconnect.bind(this),
      this._counter.getTime(this._quickDisconnectCount)
    );
  } else {
    this._quickDisconnectCount = 0;
    this._lastDisconnect = now;
    this._tryToReconnect();
  }
};

/**
 * Called when the backend tells the client to logout.
 *
 * @protected
 */
Transport.prototype._onLogout = function() {
  var handler = function() {
    this._lastToken = null;
    this._lastTokenExpiry = 0;
    this.emit(Event.TRANSPORT_LOGGED_OUT);
  }.bind(this);
  this.disconnect().then(handler, handler);
};

/**
 * Handles the flow after successful authentication.
 *
 * @protected
 * @return {Promise.<boolean>} The value `true`.
 */
Transport.prototype._onAuthenticated = function() {
  clearTimeout(this._reconnectTimeout);
  this._authenticationPromise = null;
  this._stateMask |= StateFlag.AUTHENTICATED;
  this._initTime = Date.now();
  this.emit(Event.TRANSPORT_AUTHENTICATED);
  return Promise.resolve(true);
};

/**
 * Handles the flow when authentication failed.
 *
 * @protected
 * @param {Error} e The error that triggered the authentication failure.
 * @return {Promise.<boolean>} The value `false`.
 */
Transport.prototype._onAuthenticationFailed = function(e) {
  var error = e && e.error ? e.error : e;
  this._authenticationPromise = null;
  this._stateMask &= ~StateFlag.AUTHENTICATED;
  this.emit(Event.TRANSPORT_AUTHENTICATION_FAILED, {
    error: error
  });
  return Promise.reject(error);
};

/**
 * Handles `Event.CONNECT_OFFLINE`.
 *
 * @protected
 */
Transport.prototype._onOffline = function() {
  this.emit(Event.TRANSPORT_CONNECTION_OFFLINE);
  this._disconnect(true);
};

/**
 * Handles `Event.CONNECTION_ONLINE`.
 *
 * @protected
 */
Transport.prototype._onOnline = function() {
  this.emit(Event.TRANSPORT_CONNECTION_ONLINE);
  if (this._activated) {
    this._tryToReconnect();
  }
};

// Reconnection

/**
 * Called when `Transport` detects that it has been disconnected due to a bad
 * network connection.
 *
 * @protected
 */
Transport.prototype._tryToReconnect = function() {
  if (this._isReconnecting) {
    // Already reconnecting, ignore call.
    return;
  }

  this._stateMask = 0;

  Backoff.init(this._createReconnector(), {
    baseTime: 1000,
    maxTime: 15000,
    maxRetries: this._reconnectionRetries
  })
    .catch(function() {
      this._stateMask = 0;
      this._isReconnecting = false;
      this.emit(Event.TRANSPORT_DISCONNECTED);
    }.bind(this));
};

/**
 * Creates a function that will be called to perform the reconnection process
 * for the instance.
 *
 * @protected
 * @return {Function} A reconnection function.
 */
Transport.prototype._createReconnector = function() {
  // This variable is set to true initially to ensure that the first call
  // to authenticate would trigger a token refresh.
  var ignoreCachedToken = true;
  return function() {
    this._isReconnecting = true;
    this.emit(Event.TRANSPORT_RECONNECTING);
    this._disconnect(true);
    return this._connect().then(function() {
      return this._authenticate(ignoreCachedToken)
        .then(function(result) {
          // Authorization was successful, make sure to use the cached token in
          // the next reconnection.
          ignoreCachedToken = false;
          return result;
        }, function(e) {
          // Authorization was not successful, so ignore the token for the next
          // reconnect.
          ignoreCachedToken = true;
          return Promise.reject(e);
        });
    }.bind(this)).then(function() {
      this._isReconnecting = false;
      this.emit(Event.TRANSPORT_RECONNECTED);
      return true;
    }.bind(this));
  }.bind(this);
};

/**
 * Fetches the endpoints and connects the transport instance.
 *
 * @protected
 * @return {Promise.<boolean>} A promise that will be fulfilled to `true` if the
 *     transport session was successfully connected.
 */
Transport.prototype._connect = function() {
  if (!!(this._stateMask & StateFlag.CONNECTED)) {
    return Promise.resolve(false);
  }

  if (this._connectionObserver.isOnline()) {
    return this._performConnect();
  }

  return new Promise(function(resolve, reject) {
    this._connectionObserver.once(Event.CONNECTION_ONLINE, function() {
      this._performConnect().then(resolve, reject);
    }.bind(this));
  }.bind(this));
};

/**
 * Fetches the endpoints and connects the transport instance.
 *
 * @protected
 * @return {Promise.<boolean>} A promise that will be fulfilled to `true` if the
 *     transport session was successfully connected.
 */
Transport.prototype._performConnect = function() {
  return new Promise(function(resolve) {
    resolve(this._endpointsProvider(this.toPublic()));
  }.bind(this))
    .catch(function(maybeError) {
      if (!maybeError || maybeError.code) {
        return Promise.reject(maybeError);
      }
      var error = new TransportError(
        Errors.TRANSPORT_ENDPOINTS_PROVIDER_ERROR,
        maybeError.message || 'Endpoints provider error.'
      );
      error.origin = error;
      return Promise.reject(error);
    })
    .then(this._connectToEndpoints.bind(this))
    .catch(function(e) {
      var error = e && e.error ? e.error : e;
      this.emit(Event.TRANSPORT_CONNECTION_FAILED, {error: error});
      return Promise.reject(error);
    }.bind(this));
};

/**
 * Connects the `Transport` instance to the provided endpoints.
 *
 * @protected
 * @param {module:spotify-transport/types.Endpoints} endpoints The endpoints to
 *    connect to.
 * @return {Promise.<boolean>} A promise that will be resolved when the instance
 *    has successfully connected.
 */
Transport.prototype._connectToEndpoints = function(endpoints) {
  var processedEndpoints = {};

  for (var name in endpoints) {
    if (!endpoints.hasOwnProperty(name) || !endpoints[name]) {
      continue;
    }
    var endpoint = endpoints[name];
    if (ENDPOINT_REQUIRES_SLASH_EXP.test(endpoint)) {
      endpoint = endpoint + '/';
    }
    processedEndpoints[name] = endpoint;
  }

  this._endpoints = processedEndpoints;
  this.emit(Event.TRANSPORT_ENDPOINTS_RESOLVED, {
    endpoints: extend({}, this._endpoints)
  });

  var onConnected = function() {
    this._stateMask |= StateFlag.CONNECTED;
    this.emit(Event.TRANSPORT_CONNECTED);
    return Promise.resolve(true);
  }.bind(this);

  if (!endpoints.dealer) {
    // We do not need to connect to dealer, so we return early.
    return onConnected();
  }
  return this._dealer.connect(processedEndpoints.dealer).then(onConnected);
};

/**
 * Disconnects the `Transport` instance.
 *
 * @protected
 * @param {boolean} noEmit When set to true, the `Event.TRANSPORT_DISCONNECTED`
 *     event will not be emitted as part of this function. This is necessary for
 *     operations where we internally disconnect the `Transport` instance
 *     without having to inform the user of the disconnection (such as when
 *     reconnecting).
 * @return {boolean} True if the disconnection was successful.
 */
Transport.prototype._disconnect = function(noEmit) {
  this._stateMask = 0;
  this._dealer.disconnect();
  if (!noEmit) {
    this.emit(Event.TRANSPORT_DISCONNECTED);
  }
  return true;
};

/**
 * Retrieves an access token.
 *
 * This method calls the provided token provider to retrieve an access token.
 * This token will then be cached and returned for subsequent calls until it
 * expires.
 *
 * Note that you can use the optional `ignoreCached` argument to force the
 * function to retrieve a new token.
 *
 * @protected
 * @param {boolean} ignoreCached Forces the method to retrieve a new token from
 *     the token provider if set to true.
 * @return {Promise.<string>} The new token.
 */
Transport.prototype._refreshToken = function(ignoreCached) {
  if (!this._refreshTokenPromise) {
    if (!ignoreCached && Date.now() < this._lastTokenExpiry) {
      return Promise.resolve(this._lastToken);
    }

    var clearPromise = function() {
      this._refreshTokenPromise = null;
    }.bind(this);

    this._refreshTokenPromise = new Promise(function(resolve) {
      resolve(this._tokenProvider());
    }.bind(this))
      .then(this._parseProvidedToken);
    this._refreshTokenPromise.then(clearPromise, clearPromise);
  }
  return this._refreshTokenPromise;
};

/**
 * Parses the token returned by the `provider.token` function that was passed
 * to the `Transport` instance when it was initialized.
 *
 * @protected
 * @param {string|Array} maybeToken Either a string OAuth token, or an array
 *     containing a string OAuth token and a number signifying the token's
 *     lifetime in seconds.
 * @return {string} The OAuth token.
 * @throws {TypeError} Will throw if it received an empty token (i.e, a falsy
 *     value).
 */
Transport.prototype._parseProvidedToken = function(maybeToken) {
  var token;
  var tokenTTL;
  if (Array.isArray(maybeToken)) {
    // If maybeToken is an array, it's expected to be a pair of
    // [token, timeout].
    token = maybeToken[0];
    tokenTTL = parseInt((maybeToken[1] || DEFAULT_TOKEN_TIMEOUT), 10);
  } else {
    token = maybeToken;
    tokenTTL = DEFAULT_TOKEN_TIMEOUT;
  }

  if (!token) {
    this._lastToken = null;
    this._lastTokenExpiry = 0;
    throw new TransportError(
      Errors.TRANSPORT_INVALID_TOKEN,
      'Token provider returned an invalid token: ' + token
    );
  }

  this._lastToken = token;
  this._lastTokenExpiry = Date.now() + (tokenTTL * 1000);
  this.emit(Event.TRANSPORT_ACCESS_TOKEN, {token: token});
  return token;
};

/**
 * Authenticates the current `Transport` instance with the provided token.
 *
 * @protected
 * @param {string} token The OAuth token that will be used for authentication.
 * @return {Promise.<boolean>} A promise that will be resolved once the
 *     authentication flow has completed.
 */
Transport.prototype._authenticateWithToken = function(token) {
  var endpoints = this._endpoints;

  if (!endpoints.dealer) {
    // No dealer connection, pretend like we're authenticated.
    return Promise.resolve(true);
  }

  return this._dealer.authenticate(token);
};

/**
 * Expands a "special URL" in the form `@<endpoint>` to its full path.
 *
 * @protected
 * @param {string} url The URL to expand.
 * @return {string} The expanded URL string.
 * @throws {TypeError} If the endpoint name is not provided by the endpoints
 *     provider.
 */
Transport.prototype._tryExpandSpecialURL = function(url) {
  var endpoints = this._endpoints;
  return url.replace(HTTP_SPECIAL_URL_EXP, function(match, key) {
    if (!endpoints.hasOwnProperty(key)) {
      throw new TypeError(
        'Cannot replace endpoint @' + key + '; Endpoint undefined.'
      );
    }
    return endpoints[key];
  });
};

/**
 * Takes the arguments to `Transport#request` and processes them
 *
 * @protected
 * @param {string} uri The URI of the request.
 * @param {module:spotify-transport/types.RequestArgs} args The arguments to the
 *     request.
 * @return {Promise.<module:spotify-transport/types/ParsedRequestArgs>} The
 *     parsed request arguments.
 */
Transport.prototype._processRequestArgs = function(uri, args) {
  return new Promise(function(resolve) {
    var url = uri;
    var requestArgs = args || {};
    var retryOptions = {
      algo: 'exp',
      maxRetries: DEFAULT_RETRY_COUNT,
      maxTime: 15000
    };

    if (HTTP_SPECIAL_URL_EXP.test(url)) {
      // This will throw if the special URL is invalid. It should be caught by
      // the promise though.
      url = this._tryExpandSpecialURL(url);
      if (!('authorize' in requestArgs)) {
        requestArgs.authorize = true;
      }
    }

    requestArgs.forcePolyfill =
      requestArgs.responseType in this._forcePolyfillTypes;

    if (!requestArgs.requestMode) {
      requestArgs.requestMode = this._requestMode;
    }

    // Parse retry options
    if ('retry' in requestArgs) {
      extend(retryOptions, requestArgs.retry);
    }

    // Add the connection observer as part of the args.
    requestArgs.connectionObserver = this._connectionObserver;

    if (!('metadata' in requestArgs)) {
      requestArgs.metadata = null;
    }

    resolve({
      url: url,
      args: requestArgs,
      backoffStrategy: retryOptions
    });
  }.bind(this));
};

/**
 * Sets the `Authorization` header in the `RequestArgs` object of the request.
 *
 * @protected
 * @param {module:spotify-transport/types.RequestArgs} requestArgs The arguments
 *     for the request.
 * @param {boolean} ignoreCachedToken When set to true, the function will
 *     request a new token for the header, regardless of whether there is one
 *     cached.
 * @return {Promise.<module:spotify-transport/types.RequestArgs>} The request
 *     arguments with the `header.Authorization` value set.
 */
Transport.prototype._setAuthHeader = function(requestArgs, ignoreCachedToken) {
  if (!requestArgs.authorize) {
    return Promise.resolve(requestArgs);
  }

  var setterFn = function() {
    return this._refreshToken(ignoreCachedToken).then(function(token) {
      if (!requestArgs.headers) {
        requestArgs.headers = {};
      }
      if (token !== NOT_A_TOKEN) {
        requestArgs.headers.Authorization = 'Bearer ' + token;
      }
      return requestArgs;
    });
  }.bind(this);

  if (this._stateMask & StateFlag.AUTHENTICATED) {
    return setterFn();
  }

  // We are not yet authenticated, so wait until we are authenticated.
  return new Promise(function(resolve, reject) {
    this.once('authenticated', function() {
      setterFn().then(resolve, reject);
    });
  }.bind(this));
};

/**
 * Sends the request and retries it until it succeeds or until it runs out of
 * retries.
 *
 * Internally, this method also sets the authorization header when necessary.
 *
 * @protected
 * @param {module:spotify-transport/types/ParsedRequestArgs} parsedArgs The
 *     parsed arguments for this request.
 * @return {Promise.<module:spotify-transport/types/http_response>} A promise
 *     that will be resolved with the HTTPResponse object.
 */
Transport.prototype._sendRetriedRequest = function(parsedArgs) {
  var backoffStrategy = parsedArgs.backoffStrategy;

  // This is a static flag that we will use to check whether we need to update
  // the token. We keep it here so that the `requestFn` closure will have access
  // to it in between invocations.
  var ignoreCachedToken = false;

  // This function will be called in the lifetime of the request to set the
  // request's Authorization header.
  var updateToken = function() {
    return this._setAuthHeader(parsedArgs.args, ignoreCachedToken);
  }.bind(this);

  var connectionObserver = this._connectionObserver;


  // This is the function that we will use together with the Backoff module to
  // retry the request if it fails.
  var requestFn = function() {
    var updateTokenPromise = null;
    if (connectionObserver.isOnline()) {
      updateTokenPromise = updateToken();
    } else {
      updateTokenPromise = new Promise(function(resolve, reject) {
        if (parsedArgs.args.allowOffline) {
          updateToken().then(resolve, reject);
          return;
        }
        connectionObserver.once(Event.CONNECTION_ONLINE, function() {
          updateToken().then(resolve, reject);
        });
      });
    }
    return updateTokenPromise
      .then(function() {
        // Choose a request strategy based on the `requestMode` and based on
        // the availability of `Fetch`.
        var requestPromise;
        if (
          parsedArgs.args.requestMode === 'fetch' &&
          this._Fetch.isSupported()
        ) {
          requestPromise = this._Fetch.request(parsedArgs.url, parsedArgs.args);
        } else {
          requestPromise = this._HTTP.request(parsedArgs.url, parsedArgs.args);
        }
        return requestPromise;
      }.bind(this))
      .then(function(resp) {
        var retryAfterHeader;
        if (resp.headers) {
          retryAfterHeader = resp.headers.get('Retry-After');
        }
        // Check the retry conditions and see whether we need to retry.
        // Rejecting the promise there will trigger `Backoff` to rerun the
        // `requestFn`.
        if (
          resp.status === StatusCode.UNAUTHORIZED &&
          !parsedArgs.args.ignoreUnauthorized
        ) {
          // We need to retry because we got a 401, which means that the token
          // is probably expired. We need to set `ignoreCachedToken` to true so
          // that the next invocation of `requestFn` (and `updateToken`) will
          // trigger a refresh of the token.
          ignoreCachedToken = true;
          return Promise.reject(resp);
        } else if (
          typeof backoffStrategy.condition === 'function' &&
          (backoffStrategy.condition(resp, StatusFamily) || retryAfterHeader)
        ) {
          // This delay can either be an integer representing the number of
          // seconds, or as a datestring.
          // Two examples of its use are:
          //
          //      Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
          //      Retry-After: 120
          //
          //          In the latter example, the delay is 2 minutes.
          var delay = parseInt(retryAfterHeader, 10);
          if (HTTP_DATE_EXP.test(retryAfterHeader)) {
            // treat this as a date string.
            resp.retryAfter = new Date(retryAfterHeader).getTime() - Date.now();
          } else if (delay > 0) {
            // treat this as a delay (in seconds).
            resp.retryAfter = delay * 1000;
          }
          // The user provided retry condition returned true, so we fail and
          // retry the request.
          return Promise.reject(resp);
        }

        // Everything seems to be order, so just return the response.
        return resp;
      });
  }.bind(this);

  return Backoff
    .init(requestFn, backoffStrategy)
    .catch(this._handleRetriedRequestError)
    .then(function(response) {
      response.metadata = parsedArgs.args.metadata;
      if (parsedArgs.args.rejectNotOk && !response.ok) {
        return Promise.reject(response);
      }
      return response;
    });
};

/**
 * Handles a failing promise from  `Transport#_sendRetriedRequest`.
 *
 * @protected
 * @param {module:spotify-transport/types/http_response|Error} maybeError The
 *     object to handle. In most cases, this will actually be an HTTPResponse
 *     for a request that failed, in which case this will not return a
 *     rejection.
 * @return {Promise.<module:spotify-transport/types/http_response>} A promise
 *     that will be returned with the failing HTTPResponse, or rejected with an
 *     error.
 */
Transport.prototype._handleRetriedRequestError = function(maybeError) {
  if (maybeError instanceof HTTPResponse) {
    // The request was successful, but the retry parameters probably didn't
    // clear the response as successful. In which case we should just return
    // the response directly and let the requester handle it.
    return Promise.resolve(maybeError);
  }
  return Promise.reject(maybeError);
};

/**
 * Send a body-less, GET request to a URL.
 *
 * @protected
 * @param {module:spotify-transport/types.HTTPURI} url The URI to request.
 * @return {module:spotify-transport/types.HTTPResponse} The response.
 */
Transport.prototype._sendFireAndForgetRequest = function(url) {
  if (typeof global.fetch === 'function') {
    global.fetch(url, {mode: 'no-cors'}).catch(function() {
      // Ignore any errors related to the request.
    });
  } else if (global.Image) {
    (new global.Image()).src = url;
  } else {
    this.request(url, {
      requestMode: 'xhr',
      method: 'GET',
      authorize: false,
      ignoreResponseBody: true
    });
  }
  return Promise.resolve(new HTTPResponse(url, 0));
};

/**
 * Sends a request.
 *
 * @protected
 * @param {module:spotify-transport/types.HTTPURI} uri The URI to request.
 * @param {module:spotify-transport/types.HTTPArgs} args The arguments for the
 *     request.
 * @return {Promise.<module:spotify-transport/types/http_response>} The response
 *     for the request.
 */
Transport.prototype._sendRequest = function(uri, args) {
  return this._processRequestArgs(uri, args)
    .then(function(parsedArgs) {
      if (parsedArgs.args.forget) {
        // Fire and forget, will return immediately with 0 status.
        return this._sendFireAndForgetRequest(parsedArgs.url);
      }
      return this._sendRetriedRequest(parsedArgs);
    }.bind(this));
};


// Public API

/**
 * Returns the resolved endpoints.
 *
 * If the endpoints have not been resolved yet, it will return an empty map.
 *
 * @return {Object} a map of the resolved endpoints.
 */
Transport.prototype.getEndpoints = function() {
  return extend({}, this._endpoints);
};

/**
 * Returns the time when the last call to `Transport#authenticate` succeeded.
 *
 * @return {number} The timestamp when `Transport#authenticate` succeeded.
 */
Transport.prototype.getInitTime = function() {
  return this._initTime;
};

/**
 * Returns the last generated access token.
 *
 * If there was no access token yet, it will return null.
 *
 * @return {string}
 */
Transport.prototype.getLastToken = function() {
  return this._lastToken;
};

/**
 * Returns the current connection id.
 *
 * @return {Promise.<string>} The promise that will be resolved to the current
 *     connection id.
 */
Transport.prototype.getConnectionId = function() {
  return this._dealer.getConnectionId();
};

/**
 * Returns whether the current transport session is connected.
 *
 * @return {boolean} `true` if the current transport session is connected,
 *     `false` otherwise.
 */
Transport.prototype.isConnected = function() {
  return !!(this._stateMask & StateFlag.CONNECTED);
};

/**
 * Returns whether the current transport session has been authenticated.
 *
 * @return {boolean} `true` if the current transport session is authenticated,
 *     `false` otherwise.
 */
Transport.prototype.isAuthenticated = function() {
  return !!(this._stateMask & StateFlag.AUTHENTICATED);
};

/**
 * Returns whether the navigator is currently online.
 *
 * @return {boolean} Returns `true` if the navigator is online, `false`
 *     otherwise.
 */
Transport.prototype.isOnline = function() {
  return this._connectionObserver.isOnline();
};

/**
 * Forces the current transport session to refresh its token.
 *
 * @return {Promise.<boolean>} True if the token was successfully refreshed.
 */
Transport.prototype.forceTokenRefresh = function() {
  return this._refreshToken(true).then(function() {
    return true;
  });
};

/**
 * Connects the transport session.
 *
 * @return {Promise} A promise that will be fulfilled
 */
Transport.prototype.connect = function() {
  this._activated = true;
  return this._connect();
};

/**
 * Disconnects the transport session.
 *
 * @return {Promise.<boolean>} A promise that will be resolved when
 *     disconnected.
 */
Transport.prototype.disconnect = function() {
  if (!this._activated) {
    return Promise.resolve(false);
  }
  this._activated = false;

  var eventName = this.isConnected() ?
    Event.TRANSPORT_BEFORE_ONLINE_DISCONNECT :
    Event.TRANSPORT_BEFORE_OFFLINE_DISCONNECT;

  var awaiting = [];
  var awaitPromise = function(promise) {
    awaiting.push(promise);
  };

  this.emitSync(eventName, {awaitPromise: awaitPromise});

  return Promise.all(awaiting)
    .then(this._disconnect.bind(this, false));
};

Transport.prototype.forceDisconnect = function() {
  if (!this._activated) {
    return Promise.resolve(false);
  }
  this._activated = false;
  this._disconnect();
  return Promise.resolve(true);
};

/**
 * Authenticates the transport session with an oauth token.
 *
 * @param {boolean} ignoreCachedToken Whether or not to request a new token.
 * @return {Promise} The authentication promise.
 */
Transport.prototype._authenticate = function(ignoreCachedToken) {
  if (!this._authenticationPromise) {
    this._authenticationPromise = Backoff
      .init(function() {
        return this._refreshToken(ignoreCachedToken)
          .catch(function(maybeError) {
            if (!maybeError || maybeError.code) {
              return Promise.reject(maybeError);
            }
            var error = new TransportError(
              Errors.TRANSPORT_TOKEN_PROVIDER_ERROR,
              maybeError.message || 'Token provider error.'
            );
            error.origin = error;
            return Promise.reject(error);
          })
          .then(this._authenticateWithToken.bind(this));
      }.bind(this), {
        algo: 'exp',
        maxRetries: 2,
        baseTime: 500,
        maxTime: 15000
      })
      .then(this._onAuthenticated)
      .catch(this._onAuthenticationFailed);
  }
  return this._authenticationPromise;
};

/**
 * Authenticates the transport session with an oauth token.
 *
 * @return {Promise} The authentication promise.
 */
Transport.prototype.authenticate = function() {
  return this._authenticate(true);
};

/**
 * Sends a request and returns a Promise that will be resolved to an
 * HTTPResponse object.
 *
 * @param {module:spotify-transport/types.HTTPURI} uri The URI to request.
 * @param {module:spotify-transport/types.HTTPArgs} args The arguments for the
 *     request.
 * @return {Promise} A promise that will be resolved to an HTTPResponse object.
 * @see module:spotify-transport/types.HTTPResponse
 */
Transport.prototype.request = function(uri, args) {
  var sendRequest = this._sendRequest.bind(this, uri, args);

  // TODO: Refactor argument handling
  var allowOffline = args && args.allowOffline;
  var shouldWaitForConnection =
      (!allowOffline && !this._connectionObserver.isOnline) ||
      (HTTP_SPECIAL_URL_EXP.test(uri) &&
      !(this._stateMask & StateFlag.CONNECTED));

  if (shouldWaitForConnection) {
    return new Promise(function(resolve, reject) {
      this.once('connected', function() {
        sendRequest().then(resolve, reject);
      });
    }.bind(this));
  }

  return sendRequest();
};

/**
 * Adds a message handler that is called when a message with a matching URI is
 * received from the Dealer service.
 *
 * @param {string|RegExp} matcher A string or regular expression. Every time a
 *     message is received from the Dealer service, it will be checked against
 *     this filter. If the matching is successful, the corresponding handler
 *     function is called.
 * @param {function(module:spotify-transport/types.DealerMessage)} handler A
 *     function that will be called when the instance encounters a matching
 *     message. The handler function will be passed the matching message as an
 *     argument.
 */
Transport.prototype.matchMessages = function(matcher, handler) {
  if (!matcher) {
    throw new TypeError('Dealer message "matcher" cannot be null.');
  }
  if (typeof handler !== 'function') {
    throw new TypeError('Dealer message callback cannot be null.');
  }
  var wrapper = function(e) {
    var msg = e.data;
    if (!msg.uri || !msg.uri.match(matcher)) {
      return;
    }
    handler(msg);
  };
  wrapper.__matchMessagesExp = matcher;
  // Store the wrapper in the function so we can remove it.
  handler.__matchMessagesWrapper = wrapper;
  this.on(Event.INTERNAL_DEALER_MESSAGE, wrapper);
};

/**
 * Removes a message handler.
 *
 * @param {string|RegExp} matcher The matcher of the handler to remove.
 * @param {function(DealerMessage)} handler The handler to remove. This must
 *     correspond to a handler function that was attached using the
 *     `matchMessages` method.
 * @return {boolean} `true` the handler function was successfully removed,
 *     `false` if the handler function does not exist in the internal registry.
 */
Transport.prototype.unmatchMessages = function(matcher, handler) {
  if (typeof handler !== 'function') {
    throw new TypeError('Dealer message callback cannot be null.');
  }
  var wrapper = handler.__matchMessagesWrapper;
  if (wrapper.__matchMessagesExp !== matcher) {
    return false;
  }
  this.removeListener(Event.INTERNAL_DEALER_MESSAGE, wrapper);
  return true;
};

/**
 * Adds a request handler that is called when a request with a matching URI is
 * received from the Dealer service.
 *
 * @param {string|RegExp} matcher A string or regular expression. Every time a
 *     message is received from the Dealer service, it will be checked against
 *     this filter. If the matching is successful, the corresponding handler
 *     function is called.
 * @param {function(module:spotify-transport/types.DealerMessage)} handler A
 *     function that will be called when the instance encounters a matching
 *     message. The handler function will be passed the matching message as an
 *     argument.
 */
Transport.prototype.handlePushRequests = function(matcher, handler) {
  if (!matcher) {
    throw new TypeError('Dealer push request "matcher" cannot be null.');
  }
  if (typeof handler !== 'function') {
    throw new TypeError('Dealer push request callback cannot be null.');
  }
  var wrapper = function(e) {
    var msg = e.data;
    if (!msg.message_ident || !msg.message_ident.match(matcher)) {
      return;
    }
    Promise.resolve(handler(msg)).then(e.reply);
  };
  wrapper.__matchRequestExp = matcher;
  // Store the wrapper in the function so we can remove it.
  handler.__matchRequestWrapper = wrapper;
  this.on(Event.INTERNAL_DEALER_REQUEST, wrapper);
};

/**
 * Removes a request handler.
 *
 * @param {string|RegExp} matcher The matcher of the handler to remove.
 * @param {function(DealerMessage)} handler The handler to remove. This must
 *     correspond to a handler function that was attached using the
 *     `matchMessages` method.
 * @return {boolean} `true` the handler function was successfully removed,
 *     `false` if the handler function does not exist in the internal registry.
 */
Transport.prototype.unhandlePushRequests = function(matcher, handler) {
  if (typeof handler !== 'function') {
    throw new TypeError('Dealer push request callback cannot be null.');
  }
  var wrapper = handler.__matchRequestWrapper;
  if (wrapper.__matchRequestWrapper !== matcher) {
    return false;
  }
  this.removeListener(Event.INTERNAL_DEALER_REQUEST, wrapper);
  return true;
};

/**
 * Returns an instance of PublicTransport that is bound to the current Transport
 * instance.
 *
 * @return {module:spotify-transport/_internal/public_transport} The
 *     PublicTransport instance.
 */
Transport.prototype.toPublic = function() {
  return new PublicTransport(this);
};

/**
 * Returns whether the passed owner reference is the same as the instance's
 * internal owner reference.
 *
 * @param {Object} ref An object reference to compare against the instance's
 *     owner reference.
 * @return {boolean} True if the reference passed is the same as the owner ref.
 */
Transport.prototype.hasOwnerRef = function(ref) {
  return this._ownerRef === ref;
};

module.exports = Transport;
