'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var Event = require('../types/event');
var Errors = require('../types/errors');
var DealerError = require('../lib/dealer_error');

var InternalSocketCode = require('../types/internal_socket_code');

var NOOP = function() {};

/**
 * Used to match the connection id from the Pusher URL returned by dealer.
 *
 * @const
 */
var CONNECTION_ID_EXP = /hm:\/\/pusher\/(?:[^]+)?\/connections\/([^]+)/;

/**
 * The amount of time in between heartbeats.
 *
 * @const
 */
var HEARTBEAT_INTERVAL = 30000;

/**
 * The amount of time to wait before triggering a heartbeat timeout.
 *
 * @const
 */
var HEARTBEAT_TIMEOUT = 10000;

/**
 * Interfaces with the Dealer messaging service.
 *
 * @constructor
 * @param {Object} options The options for this dealer instance.
 * @see https://ghe.spotify.net/messaging/dealer
 */
function Dealer(options) {
  EventEmitter.call(this);
  var _options = options || {};

  /**
   * The websocket implementation class that will be used when instantiating
   *     the dealer socket connection (@see `this._socket`)
   *
   * Defaults to the `WebSocket` class on the global namespace.
   *
   * @type {WebSocket}
   * @protected
   */
  this._WebSocket = options.WebSocket || global.WebSocket;

  /**
   * A reference to the internal WebSocket connection to Dealer.
   *
   * @type {WebSocket}
   * @protected
   */
  this._socket = null;

  /**
   * A deferred that is created in response to a request to ping the service.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._lastPingDeferred = null;

  /**
   * A boolean flag that indicates whether we're waiting for a Connection Id.
   *
   * When set to true, the next "connection id" message will result in a similar
   * event.
   *
   * @type {boolean}
   * @protected
   */
  this._waitingForConnectionId = true;

  /**
   * The string connection id for the Dealer connection.
   *
   * @type {string}
   * @protected
   */
  this._connectionId = null;

  /**
   * The string connection id uri for the Dealer connection.
   *
   * @type {string}
   * @protected
   */
  this._connectionURI = null;

  /**
   * The amount of time before timing out a heartbeat.
   *
   * @type {number}
   * @protected
   */
  this._heartbeatTimeout = _options.heartbeatTimeout || HEARTBEAT_TIMEOUT;
  /**
   * The setTimeout token used for the heartbeat.
   *
   * @type {number}
   * @protected
   */
  this._heartbeatToken = null;

  /**
   * The setTimeout token used for timing-out the heartbeat.
   *
   * @type {number}
   * @protected
   */
  this._heartbeatTimeoutToken = null;

  // Rebind
  this._onHeartbeatSuccess = this._onHeartbeatSuccess.bind(this);
  this._onHeartbeatError = this._onHeartbeatError.bind(this);
}
inherit(Dealer, EventEmitter);

/**
 * Creates a new Dealer instance.
 *
 * @param {Object} options The options for this dealer instance.
 * @return {module:spotify-transport/lib/dealer} The new Dealer instance.
 */
Dealer.create = function(options) {
  return new Dealer(options);
};


Dealer.prototype._onHeartbeatError = function() {
  this._stopHeartbeat();
  if (!this._socket) {
    return;
  }
  this._socket.close(InternalSocketCode.TIMEOUT, 'internal-timeout');
};

Dealer.prototype._onHeartbeatSuccess = function() {
  this._stopHeartbeat();
  this._startHeartbeat();
};

Dealer.prototype._startHeartbeat = function(initial) {
  var heartbeat = function() {
    this.ping().then(this._onHeartbeatSuccess, this._onHeartbeatError);
    this._heartbeatTimeoutToken = setTimeout(
      this._onHeartbeatError,
      this._heartbeatTimeout
    );
  }.bind(this);
  if (initial) {
    heartbeat();
  } else {
    this._heartbeatToken = setTimeout(heartbeat, HEARTBEAT_INTERVAL);
  }
};

Dealer.prototype._stopHeartbeat = function() {
  clearTimeout(this._heartbeatToken);
  clearTimeout(this._heartbeatTimeoutToken);
};

/**
 * Parses a "connection id message" from Dealer.
 *
 * @param {module:spotify-transport/types.DealerMessage} message The message to
 *     parse.
 * @return {boolean} True if the message was successfully parsed, false
 *     otherwise.
 */
Dealer.prototype._prepareConnectionId = function(message) {
  if (!message.uri) {
    return false;
  }
  var matches = message.uri.match(CONNECTION_ID_EXP);
  if (!matches) {
    return false;
  }
  var id;
  if (message.header && message.headers['Spotify-Connection-Id']) {
    // Header in ID is not URI encoded.
    id = message.headers['Spotify-Connection-Id'];
  } else {
    id = decodeURIComponent(matches[1]);
  }
  this._connectionId = id;
  this._connectionURI = message.uri;
  this.emit(Event.DEALER_CONNECTION_ID, {id: id, uri: message.uri});
  return true;
};

Dealer.prototype._reply = function(key, payload) {
  if (!key) {
    throw new TypeError('Invalid key.');
  }
  var socket = this._socket;
  if (!socket || socket.readyState !== 1) {
    return;
  }
  var msg = {
    type: 'reply',
    key: key,
    payload: payload
  };
  socket.send(JSON.stringify(msg));
};

/**
 * Parses the actual message body from the internal WebSocket.
 *
 * @param {string} data A JSON-encoded string that contains the actual message
 *     dat.
 */
Dealer.prototype._parseMessage = function(data) {
  var msg;
  try {
    msg = JSON.parse(data);
  } catch (e) {
    return;
  }
  if (this._waitingForConnectionId && this._prepareConnectionId(msg)) {
    this._waitingForConnectionId = false;
    this._startHeartbeat(true);
  } else if (msg.type === 'pong' && this._lastPingDeferred) {
    this._lastPingDeferred.resolve(true);
    this._lastPingDeferred = null;
  } else if (msg.type === 'message') {
    this.emit(Event.DEALER_MESSAGE, {data: msg});
  } else if (msg.type === 'request') {
    var key = msg.key;
    if (key) {
      this.emit(Event.DEALER_REQUEST, {
        data: msg,
        reply: this._reply.bind(this, key)
      });
    }
  }
};

/**
 * Handles the "open" event from the internal WebSocket.
 *
 * @param {Promise.Deferred} deferred The deferred object that was created as
 *     part of the authentication process.
 */
Dealer.prototype._handleOpen = function(deferred) {
  deferred.resolve(true);
  this._connected = true;
  this.emit(Event.DEALER_AUTHENTICATED);
};

/**
 * Handles a "message" from the internal WebSocket.
 *
 * @param {Object} ev The "message" event.
 */
Dealer.prototype._handleMessage = function(ev) {
  var _this = this;
  var data = ev.data;
  if (global.Blob && data instanceof global.Blob) {
    var fileReader = new global.FileReader();
    fileReader.onloadend = function() {
      _this._parseMessage(this.result);
    };
    fileReader.readAsText(data);
  } else if (global.Buffer &&
             global.ArrayBuffer &&
             data instanceof global.ArrayBuffer) {
    this._parseMessage(new global.Buffer(data).toString('ascii'));
  } else {
    this._parseMessage(data);
  }
};

/**
 * Handles a "close" event from the internal WebSocket.
 *
 * @param {Object} ev The "close" event.
 */
Dealer.prototype._handleClose = function(ev) {
  var wasConnected = this._connected;
  this._connected = false;
  if (!wasConnected) {
    // We had an error with authentication
    var error = new DealerError(
      Errors.DEALER_AUTHENTICATION_FAILED,
      'Dealer connection error',
      ev
    );
    this.emit(Event.DEALER_AUTHENTICATION_FAILED, {error: error});
    return;
  }
  this.emitSync(Event.DEALER_DISCONNECTED, {
    wsCode: ev.code,
    reason: ev.reason
  });
};

/**
 * Handles the "error" event from the internal WebSocket.
 *
 * @param {Promise.Deferred} deferred The deferred object that was created as
 *     part of the authentication process.
 */
Dealer.prototype._handleError = function(deferred) {
  var error = new DealerError(
    Errors.DEALER_CONNECTION_ERROR,
    'Cannot connect to dealer'
  );
  deferred.reject(error);
  this._connected = false;
  this.emit(Event.DEALER_ERROR, {error: error});
};

/**
 * Connects the instance to the Dealer service.
 *
 * @param {string} endpoint The endpoint to connect to.
 * @return {Promise.<boolean>} A promise that will be resolved to true if the
 *     connection was successful.
 */
Dealer.prototype.connect = function(endpoint) {
  // Dealer expects the token to be either part of the UPGRADE request header or
  // as a query-string parameter. Since we cannot set headers in the browser, we
  // use the query-string option. Since the token is unknown at this point, we
  // simply save the endpoint and wait until `authenticate()` is called.
  this._endpoint = endpoint;
  this._waitingForConnectionId = true;
  this.emit(Event.DEALER_CONNECTED);
  return Promise.resolve(true);
};

/**
 * Authenticates the instance to the Dealer service.
 *
 * @param {string} token The OAuth token that identifies the current user.
 * @return {Promise.<boolean>} A promise that will be resolved when the instance
 *     has been properly authenticated.
 */
Dealer.prototype.authenticate = function(token) {
  var deferred = Promise.defer();
  var endpoint = this._endpoint + '?access_token=' + token;
  var socket = this._socket = new this._WebSocket(endpoint);
  socket.onopen = this._handleOpen.bind(this, deferred);
  socket.onclose = this._handleClose.bind(this);
  socket.onerror = this._handleError.bind(this, deferred);
  socket.onmessage = this._handleMessage.bind(this);
  return deferred.promise;
};

/**
 * Disconnects the instance from the Dealer service.
 */
Dealer.prototype.disconnect = function() {
  if (!this._socket) {
    return;
  }
  this._stopHeartbeat();
  this._waitingForConnectionId = true;
  this._connected = false;
  this._socket.close(InternalSocketCode.CLOSE, 'internal-close');
  this._socket.onopen = NOOP;
  this._socket.onerror = NOOP;
  this._socket.onmessage = NOOP;
  this._socket.onclose = NOOP;
  this._socket = null;
  this.emitSync('disconnected', {
    wsCode: InternalSocketCode.CLOSE,
    reason: 'internal-close'
  });
};

/**
 * Sends a ping message to the Dealer instance.
 *
 * @return {Promise.<boolean>} A promise that will be resolved when the Dealer
 *     service returns a "pong" response.
 */
Dealer.prototype.ping = function() {
  if (!this._socket || this._socket.readyState !== 1) {
    return Promise.reject(new DealerError(
      Errors.DEALER_CONNECTION_ERROR,
      'Dealer connection error'
    ));
  }
  this._lastPingDeferred = Promise.defer();
  this._socket.send('{"type":"ping"}');
  return this._lastPingDeferred.promise;
};

/**
 * Returns the Connection ID of the instance.
 *
 * @return {Promise.<string>} A promise that will be resolved with the
 *     instance's connection id.
 */
Dealer.prototype.getConnectionId = function() {
  if (this._waitingForConnectionId) {
    return new Promise(function(resolve) {
      this.once('connection_id', function(e) {
        resolve(e.id);
      });
    }.bind(this));
  }
  return Promise.resolve(this._connectionId);
};

/**
 * Returns an object with the connection id and the connection uri.
 *
 * @return {Promise.<Object>} A promise that will be resolved with the
 *     instance's connection id and connection uri.
 */
Dealer.prototype.getConnectionInfo = function() {
  if (this._waitingForConnectionId) {
    return new Promise(function(resolve) {
      this.once('connection_id', function(e) {
        resolve({
          id: e.id,
          uri: e.uri
        });
      });
    }.bind(this));
  }
  return Promise.resolve({
    id: this._connectionId,
    uri: this._connectionURI
  });
};

/**
 * Returns whether there's a connectionId.
 *
 * @return {boolean} True if the dealer instance has a connection id.
 */
Dealer.prototype.hasConnectionId = function() {
  return !this._waitingForConnectionId && !!this._connectionId;
};

module.exports = Dealer;
