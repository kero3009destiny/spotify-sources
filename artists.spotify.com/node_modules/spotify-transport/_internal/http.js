'use strict';

var Promise = require('spotify-promise-plus');
var HTTPResponse = require('./http_response');
var XHRHeaders = require('./xhr_headers');
var RequestError = require('./request_error');
var StatusCode = require('../types/status_code');
var Errors = require('../types/errors');

var NOOP = function() {};

/**
 * An enum of all the methods that can allow for a payload.
 *
 * @enum {boolean}
 * @private
 */
var AllowsPayload = {
  POST: true,
  PUT: true,
  DELETE: true
};

/**
 * An map of all responseType values that can be polyfilled in case the browser
 * does not support XHR2.
 *
 * @type {Object.<string, boolean>}
 * @private
 */
var PolyfilledResponseTypes = {
  'json': true,
  'text': true,
  'document': true
};

/**
 * A value that is used to check whether the request was cancelled.
 *
 * @type {Object}
 * @private
 */
var SENTINEL = {};

/**
 * A Promise that resolves to the sentinel value.
 *
 * @type {Promise.<Object>}
 * @private
 */
var SENTINEL_PROMISE = Promise.resolve(SENTINEL);

/**
 * Represents an HTTP request.
 *
 * @constructor
 * @param {string} url The URL to request.
 * @param {module:spotify-transport/types.HTTPRequestOptions} optArgs The
 *     optional set of arguments for the request.
 * @exports spotify-transport/lib/http
 */
function HTTP(url, optArgs) {
  var args = optArgs || {};

  /**
   * The URL for the request.
   *
   * @type {string}
   * @protected
   */
  this._url = url;

  /**
   * The method for the request.
   *
   * @type {string}
   * @protected
   */
  this._method = (args.method || 'GET').toUpperCase();

  /**
   * The payload of the request.
   *
   * @type {string}
   * @protected
   */
  this._payload = args.payload || '';

  /**
   * The headers for the request.
   *
   * @type {Object.<string, string>}
   * @protected
   */
  this._headers = args.headers || null;

  /**
   * The response type for the request. Set when available.
   *
   * @type {string}
   * @protected
   */
  this._responseType = args.responseType || '';

  /**
   * A promise that will be used to cancel the request.
   *
   * @type {Promise}
   * @protected
   */
  this._canceller = args.canceller || Promise.defer().promise;

  /**
   * A flag that indicates whether we should parse the response body.
   *
   * @type {boolean}
   * @protected
   */
  this._ignoreResponseBody = args.ignoreResponseBody;

  /**
   * A flag that indicates whether we should parse the response headers.
   *
   * @type {boolean}
   * @protected
   */
  this._parseResponseHeaders = args.parseResponseHeaders;

  /**
   * A flag indicates whether to include credentials with the request.
   *
   * @type {boolean}
   * @protected
   */
  this._withCredentials = args.credentials === 'include';

  /**
   * A flag that indicates whether to use the polyfill response.
   *
   * @type {boolean}
   * @protected
   */
  this._forcePolyfill = args.forcePolyfill;

  /**
   * A flag that indicates whether to generate a timer with details about the
   * request duration.
   *
   * @type {boolean}
   * @protected
   */
  this._timing = args.timing ? {completed: 0} : null;

  /**
   * The timestamp for when the request was sent.
   *
   * @type {number}
   * @protected
   */
  this._requestStartTime = 0;

  /**
   * The XMLHttpRequest instance.
   *
   * @type {XMLHttpRequest}
   * @protected
   */
  this._xhr = new XMLHttpRequest();

  // Rebind events
  this._abort = this._abort.bind(this);
}

/**
 * Sends an HTTP request.
 *
 * @static
 * @param {string} url The URL to request.
 * @param {module:spotify-transport/types.HTTPRequestOptions} optArgs The
 *     optional set of arguments for the request.
 * @return {Promise.<module:spotify-transport/types.HTTPResponse>} A promise
 *     that will be resolved to an HTTPResponse object.
 */
HTTP.request = function(url, optArgs) {
  return new HTTP(url, optArgs).send();
};

HTTP.prototype._abort = function() {
  if (this._xhr) {
    this._xhr.abort();
    this._xhr.onprogress = NOOP;
    this._xhr.onerror = NOOP;
    this._xhr.onreadystatechange = NOOP;
    this._xhr = null;
  }
};

/**
 * Handles the statechange event for the internal request object.
 *
 * @param {string} url The URL of the request.
 * @param {Promise.Deferred} deferred The deferred promise.
 * @param {Object} connObserver An instance of a connection observer.
 * @protected
 */
HTTP.prototype._handleStateChanged = function(url, deferred, connObserver) {
  if (!this._xhr || this._xhr.readyState !== 4) {
    return;
  }

  if (this._timing) {
    this._timing.completed = Date.now() - this._requestStartTime;
  }

  // Clear any event listeners.
  this._xhr.onprogress = NOOP;
  this._xhr.onerror = NOOP;
  this._xhr.onreadystatechange = NOOP;

  Promise.race([this._canceller, SENTINEL_PROMISE]).then(function(sentinel) {
    if (sentinel !== SENTINEL || !this._xhr) {
      // The request was cancelled.
      return;
    }
    var xhr = this._xhr;
    if (!xhr) {
      return;
    }

    var status = xhr.status;

    var response = new HTTPResponse(xhr.responseURL || url, status);
    response.body = null;

    if (connObserver && connObserver.isOnline) {
      response.offline = !connObserver.isOnline();
    }

    if (this._parseResponseHeaders || status > 299) {
      // Parse headers
      response.headers = new XHRHeaders(xhr.getAllResponseHeaders());
    }

    if (
      !this._ignoreResponseBody &&
      status !== StatusCode.NO_CONTENT &&
      response.getStatusFamily() === 2
    ) {
      // Response parsing
      var expectedResponseType = this._responseType;

      if (!this._forcePolyfill &&
        'response' in xhr &&
        expectedResponseType === xhr.responseType) {
        response.body = xhr.response;
      } else if (expectedResponseType === 'document') {
        // Parsed XML.
        response.body = xhr.responseXML;
      } else if (expectedResponseType === 'json') {
        try {
          response.body = JSON.parse(xhr.responseText);
        } catch (e) {
          // Mirror the behaviour of the xhr.response property: if responseType
          // is set to 'json' and the response body is not a valid JSON value,
          // return null.
          response.body = null;
        }
      } else if (
        expectedResponseType === 'text' ||
        expectedResponseType === ''
      ) {
        // Catches responseType === 'text' as well.
        response.body = xhr.responseText;
      }
    }

    response.timing = this._timing;

    deferred.resolve(response);
    this._xhr = null;
  }.bind(this)).catch(function() {
    // console.error(e);
  });
};

/**
 * Sends the request.
 *
 * @return {Promise.<module:spotify-transport/types.HTTPResponse>} A promise
 *     that will be resolved to an HTTPResponse object.
 */
HTTP.prototype.send = function() {
  return Promise.race([
    this._canceller,
    SENTINEL_PROMISE
  ]).then(function(sentinel) {
    var deferred = Promise.defer();
    if (sentinel !== SENTINEL) {
      // The request was cancelled, so we don't proceed.
      return deferred.promise;
    }

    var url = this._url;
    if (!url) {
      deferred.reject(new TypeError('Request URL cannot be blank.'));
      return deferred.promise;
    }

    // Set body
    var sendParams = null;
    var payload = this._payload;
    var method = this._method;

    if (method in AllowsPayload && payload) {
      // The method can accept bodies, so we will send the payload using the
      // send() method.
      sendParams = payload;
    } else if (payload) {
      // The method does not allow a body, so we'll set the payload as a
      // query-string parameter.
      url += '?' + payload;
    }

    var xhr = this._xhr;
    if (!xhr) {
      deferred.reject(new Error('Request has been closed.'));
      return deferred.promise;
    }

    xhr.open(method, url, true);

    // Add event handlers.
    xhr.onprogress = NOOP;
    xhr.onerror = function() {
      deferred.reject(
        new RequestError(
          Errors.HTTP_REQUEST_FAILED,
          'Request cannot be completed.',
          this.status
        )
      );
      this.onerror = NOOP;
    };
    xhr.onreadystatechange = this._handleStateChanged.bind(
      this,
      url,
      deferred
    );

    // Parse the response type. For the most part, we depend on the browser
    // support for the `responseType` property for XHR2. However, we special
    // case the 'json' and the 'document' type, as they can be emulated with the
    // original XHR APIs.
    var responseType = this._responseType;
    if (responseType) {
      if (this._forcePolyfill) {
        if (!(responseType in PolyfilledResponseTypes)) {
          deferred.reject(
            new TypeError('Cannot polyfill responseType "' + responseType + '"')
          );
          return deferred.promise;
        }
      } else {
        if (!('responseType' in xhr) &&
            !(responseType in PolyfilledResponseTypes)) {
          deferred.reject(
            new TypeError('Cannot set responseType: not supported in browser.')
          );
          return deferred.promise;
        }
        xhr.responseType = responseType;
        if (responseType !== this._xhr.responseType &&
            !(responseType in PolyfilledResponseTypes)) {
          deferred.reject(
            new TypeError('Unknown responseType "' + responseType + '".')
          );
          return deferred.promise;
        }
      }
    }

    // Set headers
    var headers = this._headers;
    if (headers) {
      for (var key in headers) {
        if (!headers.hasOwnProperty(key)) {
          continue;
        }
        try {
          xhr.setRequestHeader(key, headers[key]);
        } catch (e) {
          deferred.reject(e);
          return deferred.promise;
        }
      }
    }

    // Send the request.
    try {
      this._requestStartTime = Date.now();
      xhr.send(sendParams);
    } catch (e) {
      deferred.reject(e);
    }

    // We attach the canceller here to ensure that the request was already sent.
    this._canceller.then(this._abort, this._abort);

    return deferred.promise;
  }.bind(this));
};

module.exports = HTTP;
