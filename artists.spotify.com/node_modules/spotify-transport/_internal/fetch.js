'use strict';

var Promise = require('spotify-promise-plus');
var HTTPResponse = require('./http_response');
var FetchHeaders = require('./fetch_headers');
var StatusCode = require('../types/status_code');

/**
 * An enum of all the methods that can allow for a payload.
 *
 * @enum {boolean}
 * @private
 */
var AllowsPayload = {
  POST: true,
  PUT: true,
  DELETE: true
};

/**
 * An map of all responseType values that can be polyfilled in case the browser
 * does not support XHR2.
 *
 * @type {Object.<string, boolean>}
 * @private
 */
var AllowedResponseTypes = {
  'json': true,
  'text': true,
  'arraybuffer': true,
  'blob': true
};


function isSupported() {
  return typeof global.fetch === 'function';
}

function transportFetch(url, optArgs) {
  if (!isSupported()) {
    return Promise.reject(new TypeError('Fetch is not supported'));
  }

  var args = optArgs || {};

  if (!url) {
    return Promise.reject(new TypeError('Request URL cannot be blank.'));
  }
  var _url = url;

  // Set body
  var sendParams = null;
  var payload = args.payload;
  var method = (args.method || 'GET').toUpperCase();

  if (method in AllowsPayload && payload) {
    // The method can accept bodies, so we will send the payload using the
    // send() method.
    sendParams = payload;
  } else if (payload) {
    // The method does not allow a body, so we'll set the payload as a
    // query-string parameter.
    _url += '?' + payload;
  }

  var responseType = args.responseType || 'text';
  if (responseType && !(responseType in AllowedResponseTypes)) {
    return Promise.reject(
      new TypeError('Cannot set responseType: not supported in browser.')
    );
  }

  var ignoreResponseBody = args.ignoreResponseBody;

  var fetchOptions = {
    mode: args.mode || 'cors',
    credentials: args.credentials || 'same-origin',
    redirect: args.redirect || 'follow',
    method: method
  };

  // We add these options separately to the object because MS browsers seem to
  // error out if we give them "empty values".
  if (args.headers) {
    fetchOptions.headers = args.headers;
  }
  if (sendParams) {
    fetchOptions.body = sendParams;
  }

  var startTime = Date.now();

  return global.fetch(_url, fetchOptions)
    .then(function(resp) {
      var bodyPromise;
      if (ignoreResponseBody || resp.status === StatusCode.NO_CONTENT) {
        bodyPromise = null;
      } else if (responseType === 'json') {
        bodyPromise = resp.json().catch(function() {
          // The fetch API will throw an error if the body is not proper JSON.
          // However, to maintain compatibility with the original API, we want
          // to return null on the body if it's not proper JSON.
          return null;
        });
      } else if (responseType === 'arraybuffer') {
        bodyPromise = resp.arrayBuffer();
      } else if (responseType === 'blob') {
        bodyPromise = resp.blob();
      } else {
        bodyPromise = resp.text();
      }

      var responseHeaders = args.parseResponseHeaders || resp.status > 299 ?
        new FetchHeaders(resp.headers) :
        null;

      return Promise.all([
        resp.url,
        resp.status,
        responseHeaders,
        bodyPromise
      ]);
    })
    .then(function(results) {
      // Instead of using `promise.spread, we spread the values here manually
      // to get around an issues on platforms that do not propagate the
      // promise-plus additions to the native prototype.
      var respUrl = results[0];
      var status = results[1];
      var headers = results[2];
      var body = results[3];

      var duration = args.timing ? Date.now() - startTime : null;
      var response = new HTTPResponse(respUrl, status);
      response.body = body;
      response.headers = headers;
      response.timing = args.timing ? {completed: duration} : null;
      return response;
    })
    .catch(function() {
      // Fetch does not provide really good errors..
      var duration = args.timing ? Date.now() - startTime : null;
      var response = new HTTPResponse(_url);
      response.timing = args.timing ? {completed: duration} : null;
      return response;
    })
    .then(function(response) {
      // Set the offline flag if available.
      if (args.connectionObserver) {
        response.offline = !args.connectionObserver.isOnline();
      }
      return response;
    });
}

module.exports = {
  request: transportFetch,
  isSupported: isSupported
};
