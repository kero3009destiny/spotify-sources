'use strict';

var Promise = require('spotify-promise-plus');

var XResolveError = require('../../types/xresolve_error');
var Errors = require('../../types/errors');
var HTTP = require('../../_internal/http');

var RESOLVER_URL = 'https://apresolve.spotify.com/';

var WellKnownMapping = {
  DEALER: 'dealer',
  WEBGATE: 'spclient'
};

var WEB_API = 'https://api.spotify.com/';

function createProvider(mappings) {
  var _mappings = mappings || {};
  var types = {
    dealer: WellKnownMapping.DEALER,
    webgate: WellKnownMapping.WEBGATE
  };
  if (_mappings.dealer) {
    types.dealer = _mappings.dealer;
  }
  if (_mappings.webgate) {
    types.webgate = _mappings.webgate;
  }
  var qs = ['?', 'type=', types.dealer, '&', 'type=', types.webgate].join('');
  return function(transport) {
    var _transport = transport || HTTP;
    return _transport.request(RESOLVER_URL + qs, {
      forcePolyfill: true, // Some browsers can't JSON.
      responseType: 'json',
      retry: {
        maxRetries: 5,
        condition: function(response, StatusFamily) {
          // We have a fairly strict 2xx requirement here, since we want to
          // ensure that we can connect.
          return response.getStatusFamily() !== StatusFamily.SUCCESS;
        }
      }
    }).then(function(response) {
      if (response.status !== 200) {
        return Promise.reject(new XResolveError(
          Errors.XRESOLVE_REQUEST_FAILED_WITH_STATUS,
          'XResolve responded with status ' + response.status,
          response.status
        ));
      }
      var body = response.body;
      if (!body) {
        return Promise.reject(new XResolveError(
          Errors.XRESOLVE_INVALID_RESPONSE,
          'XResolve responded with an empty or invalid body.',
          response.status
        ));
      }
      var result = {
        dealer: body[types.dealer] && body[types.dealer][0],
        webgate: body[types.webgate] && body[types.webgate][0],
        webapi: WEB_API
      };
      if (!result.dealer || !result.webgate) {
        return Promise.reject(new XResolveError(
          Errors.XRESOLVE_INCOMPLETE_RESPONSE,
          'Xresolve responded with incomplete results.',
          response.status
        ));
      }
      return result;
    }).then(function(result) {
      // Ensure that we prefix with protocols.
      result.dealer = 'wss://' + result.dealer.replace(/:443$/, '');
      result.webgate = 'https://' + result.webgate.replace(/:443$/, '');
      return result;
    });
  };
}

module.exports = createProvider;
