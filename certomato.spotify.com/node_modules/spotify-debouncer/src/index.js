'use strict';
/**
 * @module spotify-debouncer
 */

var Promise = require('spotify-promise-plus');

var slice = Array.prototype.slice;

/**
 * @name module:spotify-debounce/debounce-options
 * @typedef {Object}
 * @property {number} threshold The threshold for the debounce.
 * @property {number} timestamp The initial timestamp for calculating the very
 *     first debounce delta time.
 * @property {bool} blockInitial True if the first call in a burst of calls
 *     should not be let through.
 */

/**
 * The default options used when initializing a debouncer. Values overridden if
 *     supplied to the constructor.
 *
 * @type {module:spotify-debounce/debounce-options}
 */
var defaults = {
  threshold: 1000,
  timestamp: 0,
  blockInitial: false
};

/**
 * Debouncer, handles throttling of syncronous and/or asyncronous function
 *     calls.
 *
 * @constructor
 * @export module:spotify-debouncer
 * @param {Function} fn Function to be throttled.
 * @param {object} opts Initialization options, extends/overrides defaults.
 */
function Debouncer(fn, opts) {
  var options = opts || {};

  /**
   * Function to debounce.
   *
   * @type {Function}
   * @protected
   */
  this._fn = fn;

  /**
   * Optional function to be called before cancelling a debounced call. Also
   *     has a setter on the prototype.
   *
   *     Note that this function is not asyncronous it self. The Debouncer
   *     won't care if this returns or not - it will just execute it.
   *
   * @type {Function}
   * @protected
   */
  this._cancelFn = options.cancel || null;

  /**
   * The time it will take (in ms) until the debounced function is executed.
   *
   * @type {number}
   * @protected
   */
  this._threshold = options.threshold || defaults.threshold;

  /**
   * The timestamp used to calculate time since last debounce call.
   *
   * @type {number}
   * @protected
   */
  this._ts = options.initialTimetamp || defaults.timestamp;

  /**
   * True if first call in a series of call should be debounced ie only let the
   *     last call through.
   *     Default behaviour (see default options) is to let the first and last
   *     call through.
   *
   * @type {number}
   * @protected
   */
  this._blockInital = options.blockInitial || defaults.blockInitial;

  /**
   * Timeout that holds the last defferd call, subsequently cleared and
   *     reattached if a new call is made before the last one is executed.
   *
   * @type {number}
   * @protected
   */
  this._deferredTimer = null;

  // rebind public functions.
  this.sync = this.sync.bind(this);
  this.async = this.async.bind(this);
}

/**
 * Executes throttled synchronous call.
 *
 * @param {array<*>} args Function arguments to apply.
 * @protected
 */
Debouncer.prototype._deferFn = function(args) {
  this._fn.apply(this._fn, args);
};

/**
 * Executes throttled asynchronous call.
 *
 * @param {array} args Function arguments to apply.
 * @param {Promise} promise The deferred (already returned) promise to resolve
 *     result into.
 * @protected
 */
Debouncer.prototype._deferPromise = function(args, promise) {
  this._fn.apply(this._fn, args)
    .then(function(data) {
      promise.resolve(data);
    });
};

/**
 * Synchronous debounce function. Function arguments will be picked up and
 *     applied as needed for the debounced function.
 *
 * @public
 */
Debouncer.prototype.sync = function() {
  var args = slice.call(arguments);
  var delta = Date.now() - this._ts;
  this._ts = Date.now();
  if (delta < this._threshold) {
    if (this._cancelFn && this._deferredTimer) {
      this._cancelFn();
    }
    clearTimeout(this._deferredTimer);
    this._deferredTimer = setTimeout(
      this._deferFn.bind(this, args),
      this._threshold
    );
    return;
  }
  if (this._blockInital === true) {
    this.sync.apply(this, args);
    return;
  }
  this._fn.apply(this._fn, args);
};

/**
 * Asynchronous debounce function. Function arguments will be picked up and
 *     applied as needed for the debounced function.
 *
 * @return {Promise}
 * @public
 */
Debouncer.prototype.async = function() {
  var args = slice.call(arguments);
  var delta = Date.now() - this._ts;
  this._ts = Date.now();
  if (delta < this._threshold) {
    if (this._cancelFn && this._deferredTimer) {
      this._cancelFn();
    }
    clearTimeout(this._deferredTimer);
    var d = Promise.defer();
    this._deferredTimer = setTimeout(
      this._deferPromise.bind(this, args, d),
      this._threshold
    );
    return d.promise;
  }
  if (this._blockInital === true) {
    return this.async.apply(this, args);
  }
  return this._fn.apply(this._fn, args);
};

/**
 * Setter for this._cancelFn.
 *
 * @param {Function} fn The function to use when cancelling deferreds.
 * @public
 */
Debouncer.prototype.setCancel = function(fn) {
  this._cancelFn = fn;
};

module.exports = Debouncer;
