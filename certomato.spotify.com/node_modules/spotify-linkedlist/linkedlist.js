'use strict';

var ERROR_NODE_IS_NULL = 'Node is null!';
var ERROR_NODE_IN_LIST = 'Node already exists in another list!';

/**
 * A Linked List implementation.
 *
 * @constructor
 */
function LinkedList() {
  /**
   * An identifier object used to determine that nodes are inside the list.
   *
   * @type {Object}}
   * @protected
   */
  this._id = {};

  /**
   * The length of the list.
   *
   * @type {number}
   */
  this.length = 0;

  /**
   * The first item in the list.
   *
   * @type {module:spotify-linkedlist.Node?}
   */
  this.first = null;

  /**
   * The first item in the list.
   *
   * @type {module:spotify-linkedlist.Node?}
   */
  this.last = null;
}

/**
 * Inserts a node at the end of the list.
 *
 * @param {module:spotify-linkedlist.Node} newNode The node to insert.
 * @return {number} The new length of the list.
 */
LinkedList.prototype.append = function(newNode) {
  if (!newNode) {
    throw new Error(ERROR_NODE_IS_NULL);
  }
  if (newNode.listID) {
    throw new Error(ERROR_NODE_IN_LIST);
  }
  newNode.listID = this._id;
  if (!this.first) {
    this.first = newNode;
    this.last = newNode;
  } else {
    newNode.prev = this.last;
    newNode.next = null;
    this.last.next = newNode;
    this.last = newNode;
  }
  return ++this.length;
};

/**
 * Inserts a node after a particular node in the list.
 *
 * @param {module:spotify-linkedlist.Node} node The reference node.
 * @param {module:spotify-linkedlist.Node} newNode The node to insert after the
 *     reference node.
 */
LinkedList.prototype.insertAfter = function(node, newNode) {
  if (!node || !newNode) {
    throw new Error(ERROR_NODE_IS_NULL);
  }
  if (newNode.listID) {
    throw new Error(ERROR_NODE_IN_LIST);
  }
  newNode.listID = this._id;
  newNode.prev = node;
  newNode.next = node.next;
  node.next.prev = newNode;
  node.next = newNode;
  if (newNode.prev === this.last) {
    this.last = newNode;
  }
  this.length++;
};

/**
 * Removes a node from the list.
 *
 * @param {module:spotify-linkedlist.Node} node The node to remove.
 * @return {boolean} Returns true if the node was successfully removed, false
 *     otherwise.
 */
LinkedList.prototype.remove = function(node) {
  if (!node) {
    throw new Error(ERROR_NODE_IS_NULL);
  }
  if (!this.length || node.listID !== this._id) {
    return false;
  } else if (this.length > 1) {
    if (node.prev) {
      node.prev.next = node.next;
    }
    if (node.next) {
      node.next.prev = node.prev;
    }
    if (node === this.first) {
      this.first = node.next;
    } else if (node === this.last) {
      this.last = node.prev;
    }
  } else {
    this.first = null;
    this.last = null;
  }

  node.listID = null;
  node.prev = null;
  node.next = null;
  this.length--;
  return true;
};

/**
 * A node in a LinkedList.
 *
 * @constructor
 * @param {*} value The value for the node.
 */
LinkedList.Node = function(value) {
  /**
   * The id of the list that this node belongs to.
   *
   * @type {Object?}
   */
  this.listID = null;

  /**
   * The key for this node.
   *
   * Normally unused but required by the LRU cache. This is added to the object
   * in order to optimize for object shape in V8-like engines.
   *
   * @type {string}
   */
  this.key = null;

  /**
   * The node in the list before this particular node.
   *
   * @type {module:spotify-linkedlist.Node}
   */
  this.prev = null;

  /**
   * The node in the list after this particular node.
   *
   * @type {module:spotify-linkedlist.Node}
   */
  this.next = null;

  /**
   * The value contained in the node.
   *
   * @type {*}
   */
  this.value = value || null;
};

module.exports = LinkedList;
