'use strict';

var StatusCode = require('./types/status_code');

/**
 * The amound of time needed before `ServerTime#getApproximate` triggers a
 * refresh of the server time.
 *
 * @const
 * @private
 */
var REFRESH_THRESHOLD = 180000;

/**
 * The endpoint for the server time request.
 *
 * @const
 * @private
 */
var ENDPOINT = '@webgate/melody/v1/time';


var debugLogger = require('spotify-debug-tools/logging').forTag(
  'transport.server_time'
);

/**
 * The ServerTime class can be used to request the current timestamp as known
 * by the Spotify backend.
 *
 * This is useful in instances where multiple clients need to sync time. All
 * operations that deal with synchronization use the server's timestamp, which
 * are all synced across different services.
 *
 * @class
 * @param {module:spotify-transport/lib/transport} transport The transport
 *     instance that the ServerTime instance will use to make requests.
 */
function ServerTime(transport) {
  /**
   * The transport instance.
   *
   * @type {module:spotify-transport/lib/transport}
   * @protected
   */
  this._transport = transport;

  /**
   * The last known server time as a timestamp.
   *
   * @type {number}
   * @protected
   */
  this._serverTime = 0;

  /**
   * The timestamp when the server time was last received.
   *
   * @type {number}
   * @protected
   */
  this._serverTimeFetchedAt = 0;
}

/**
 * Returns an instance of the ServerTime class.
 *
 * @param {module:spotify-transport/lib/transport} transport The transport
 *     instance that the ServerTime instance will use to make requests.
 * @return {module:spotify-transport/lib/server_time}
 */
ServerTime.create = function(transport) {
  return new ServerTime(transport);
};

/**
 * Parses the response of the ServerTime endpoint.
 *
 * @protected
 * @param {number} requestStart A timestamp that indicates when the request for
 *     the server time was made. This is used to calculate the latency that will
 *     be included in the final time value.
 * @param {module:spotify-transport/types/http_response} response The response
 *     for the request to the endpoint.
 * @return {number} The computed server time.
 */
ServerTime.prototype._parseServiceResponse = function(requestStart, response) {
  var requestEnd = Date.now();
  var elapsed = requestEnd - requestStart;
  var time;
  var status = response.status;
  if (status === StatusCode.OK) {
    time = response.body.timestamp;
  } else {
    debugLogger.error(
      'Cannot fetch server time. Service responded with ' + status
    );
    time = requestEnd;
  }
  this._serverTime = time + elapsed;
  this._serverTimeFetchedAt = requestEnd;
  return this._serverTime;
};

/**
 * Returns the current server time.
 *
 * @return {number} The server time.
 */
ServerTime.prototype.get = function() {
  var requestStart = Date.now();
  return this._transport
    .request(ENDPOINT, {responseType: 'json'})
    .then(this._parseServiceResponse.bind(this, requestStart));
};

/**
 * Returns the approximate server time.
 *
 * Unlike `ServerTime#get`, this method is not guaranteed to always request the
 * server time from the backend. Instead, it calculates the last known server
 * time and adds the time elapsed from when that was received up to the current
 * timestamp.
 *
 * @return {number} The server time.
 */
ServerTime.prototype.getApproximate = function() {
  if (!this._serverTime) {
    this.get();
    return Date.now();
  }
  var elapsed = Date.now() - this._serverTimeFetchedAt;
  if (elapsed > REFRESH_THRESHOLD) {
    this.get();
  }
  return this._serverTime + elapsed;
};

module.exports = ServerTime;
