'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');

var StatusCode = require('./types/status_code');
var Event = require('./types/event');

var DEFAULT_PRODUCT_STATE_ENDPOINT = '@webgate/melody';
var USER_UPDATE_EVENT_FILTER = /^wss:\/\/event$/;

function ProductStateObserver(options) {
  EventEmitter.call(this);

  this._transport = options.transport;
  this._endpoint = options.endpoint || DEFAULT_PRODUCT_STATE_ENDPOINT;
  this._currentState = null;
  this._currentConnectionId = null;

  this._handleUserUpdate = this._handleUserUpdate.bind(this);
  this._init();
}
inherit(ProductStateObserver, EventEmitter);

ProductStateObserver.create = function(options) {
  return new ProductStateObserver(options);
};

ProductStateObserver.prototype._init = function() {
  this._transport.on(Event.TRANSPORT_CONNECTION_ID, function(e) {
    this.register(e.id).catch(function() {});
  }.bind(this));
};

ProductStateObserver.prototype._handleUserUpdate = function() {
  // When we get a product state change, we should refresh the user's token.
  this._transport.forceTokenRefresh().catch(function() {
    // NO OP
  });
  this.getCurrentState(true).then(function(productState) {
    this.emit(Event.PRODUCT_STATE_CHANGED, {
      productState: productState
    });
  }.bind(this)).catch(function() {
    // ignore
  });
};

ProductStateObserver.prototype._shouldRetry = function(response, StatusFamily) {
  var statusFamily = response.getStatusFamily();
  return statusFamily === StatusFamily.SERVER_ERROR ||
    statusFamily === StatusFamily.BROWSER_ERROR;
};

ProductStateObserver.prototype._createSubURL = function(connectionId) {
  return '@webapi/v1/me/notifications/user?connection_id=' +
    encodeURIComponent(connectionId);
};

ProductStateObserver.prototype.getCurrentState = function(ignoreCached) {
  if (!ignoreCached && this._currentState) {
    return Promise.resolve(this._currentState);
  }
  return this._transport.request(this._endpoint + '/v1/product_state', {
    method: 'GET',
    responseType: 'json',
    retry: {
      condition: this._shouldRetry
    }
  }).then(function(response) {
    if (response.status !== StatusCode.OK) {
      this._currentState = null;
      return Promise.reject(new Error('Cannot get the user\'s product state.'));
    }
    this._currentState = response.body;
    return response.body;
  }.bind(this));
};

ProductStateObserver.prototype.register = function(connectionId) {
  if (!connectionId) {
    Promise.reject(new TypeError('ConnectionId cannot be null'));
  }
  this._transport.matchMessages(
    USER_UPDATE_EVENT_FILTER,
    this._handleUserUpdate
  );
  return this._transport.request(this._createSubURL(connectionId), {
    method: 'PUT',
    ignoreResponseBody: true,
    ignoreUnauthorized: true,
    retry: {
      condition: this._shouldRetry
    }
  }).then(function(response) {
    if (response.status !== StatusCode.OK) {
      var errorMessage = 'Cannot register for product state updates: ' +
        'service responded with status ' + response.status;
      return Promise.reject(new Error(errorMessage));
    }
    this._connectionId = connectionId;
    return true;
  }.bind(this));
};

ProductStateObserver.prototype.deregister = function() {
  var connectionId = this._connectionId;
  if (!connectionId) {
    return Promise.resolve(false);
  }
  this._transport.unmatchMessages(
    USER_UPDATE_EVENT_FILTER,
    this._handleUserUpdate
  );
  return this._transport.request(this._createSubURL(connectionId), {
    method: 'DELETE',
    ignoreResponseBody: true,
    ignoreUnauthorized: true,
    retry: {
      condition: this._shouldRetry
    }
  }).then(function(response) {
    if (response.status === StatusCode.OK) {
      this._connectionId = null;
      return Promise.resolve(true);
    }
    return Promise.resolve(false);
  }.bind(this));
};

module.exports = ProductStateObserver;
