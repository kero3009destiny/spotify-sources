'use strict';

var Promise = require('spotify-promise-plus');
var StatusCode = require('./types/status_code');

var IntervalTimer = require('./_internal/interval_timer');
var StepTimer = require('./_internal/step_timer');
var LoggingError = require('./_internal/logging_error');
var Errors = require('./types/errors');

var DEFAULT_MELODY_ENDPOINT = 'https://@webgate/melody';

var LogValues = {
  UNKNOWN: 'unknown',
  EMPTY: '',
  ZERO: 0,
  EMPTY_VERSION: '0.0.0'
};

var LogEndpoints = {
  // Logging
  CLIENT_EVENT: {
    url: '/v1/logging/client_event'
  },
  ELAPSED_TIME: {
    url: '/v1/logging/elapsed_time'
  },
  JSSDK_ERROR: {
    url: '/v1/logging/jssdk_error',
    allowUnauthenticated: true
  },
  JSSDK_INTERVAL_TIMER: {
    url: '/v1/logging/jssdk_interval_timer'
  },
  JSSDK_PLAYBACK_STATS: {
    url: '/v1/logging/jssdk_playback_stats',
    allowUnauthenticated: true
  },
  JSSDK_PLAYBACK_START: {
    url: '/v1/logging/jssdk_playback_start'
  },
  JSSDK_STALL: {
    url: '/v1/logging/jssdk_stall',
    allowUnauthenticated: true
  },
  JSSDK_TIMER: {
    url: '/v1/logging/jssdk_timer'
  },
  JSSDK_WARNING: {
    url: '/v1/logging/jssdk_warning',
    allowUnauthenticated: true
  },
  TRACK_STREAM_VERIFICATION: {
    url: '/v1/logging/track_stream_verification'
  },

  // Metrics
  METRICS: {
    url: '/v1/metric'
  }
};

function Logger(options) {
  var _options = options || {};
  if (!options.transport) {
    throw new TypeError('Logger `option.transport` must be a valid transport.');
  }

  /**
   * An instance of PublicTransport that will be used to make the calls to
   * the service.
   *
   * @type {module:spotify-transport}
   * @protected
   */
  this._transport = _options.transport;

  /**
   * The logging service endpoint
   *
   * @type {string}
   * @protected
   */
  this._endpoint = _options.endpoint || DEFAULT_MELODY_ENDPOINT;

  /**
   * The ID for the sdk that will be filled up by promises.
   *
   * @type {string}
   * @protected
   */
  this._sdkId = null;

  /**
   * The ID for the platform that will be filled up by promises.
   *
   * @type {string}
   * @protected
   */
  this._platformId = null;

  /**
   * The version string for the client.
   *
   * @type {string}
   * @protected
   */
  this._clientVersion = null;

  /**
   * A promise that will be fulfilled with the _sdkId value.
   *
   * @type {Promise.<string>}
   * @protected
   */
  this._sdkIdPromise = Promise.resolve(_options.sdkId || 'transport:1.0.0');

  /**
   * A promise that will be fulfilled with the _platformId value.
   *
   * @type {Promise.<string>}
   * @protected
   */
  this._platformPromise = Promise.resolve(
    _options.platform || 'spotify-transport'
  );

  /**
   * A promise that will be fullfilled with the client_version value.
   *
   * @type {Promise.<string>}
   * @protected
   */
  this._clientVersionPromise = Promise.resolve(
    _options.clientVersion || '0.0.0'
  );

  /**
   * Indicates whether certain messages can be logged for unauthenticated
   * sessions.
   *
   * @type {boolean}
   * @protected
   */
  this._allowUnauthenticated = _options.allowUnauthenticated;
}

/**
 * Returns a new Logger Instance.
 *
 * @param {Object} options The Logger options.
 * @return {module:spotify-transport/lib/logger} The logger instance.
 */
Logger.create = function(options) {
  return new Logger(options);
};

/**
 * Returns the ident data for the Logger instance.
 *
 * @return {Promise.<{platform: string, sdk_id: string}>} The ident data.
 * @protected
 */
Logger.prototype._getIdentData = function() {
  if (this._platformId && this._sdkId) {
    return Promise.resolve({
      platform: this._platformId,
      sdk_id: this._sdkId,
      client_version: this._clientVersion
    });
  }
  return Promise.all([
    this._platformPromise,
    this._sdkIdPromise,
    this._clientVersionPromise
  ]).spread(function(platform, sdkId, clientVersion) {
    this._platformId = platform;
    this._sdkId = sdkId;
    this._clientVersion = clientVersion;
    return Promise.resolve({
      platform: platform,
      sdk_id: sdkId,
      client_version: clientVersion
    });
  }.bind(this));
};

/**
 * Decorates the payload to be sent with the platform and sdk_id ids.
 *
 * @param {Object} payload The payload object.
 * @return {Promise.<Object>} The decorated payload.
 */
Logger.prototype._decoratePayload = function(payload) {
  return this._getIdentData().then(function(identData) {
    // Decorate
    payload.sdk_id = identData.sdk_id;
    payload.platform = identData.platform;
    payload.client_version = identData.client_version;
    return payload;
  });
};

/**
 * Sends a log message to the service.
 *
 * @param {module:spotify-transport/lib/logger~LogEndpoints} endpoint The
 *     endpoint for the particular message.
 * @param {Object} payload The payload to send.
 * @return {Promise.<boolean>} True if the log was accepted by the server.
 * @protected
 */
Logger.prototype._sendLog = function(endpoint, payload) {
  var authorize = this._allowUnauthenticated && endpoint.allowUnauthenticated ?
    this._transport.isAuthenticated() :
    true;

  return this._transport.request(this._endpoint + endpoint.url, {
    method: 'POST',
    authorize: authorize,
    payload: JSON.stringify(payload),
    retry: {
      maxRetries: 5,
      condition: function(response) {
        return response.status !== StatusCode.ACCEPTED;
      }
    }
  }).then(function(response) {
    var status = response.status;
    if (status !== StatusCode.ACCEPTED) {
      return Promise.reject(
        new LoggingError(
          Errors.LOGGING_REQUEST_FAILED,
          'Logging service responded with status ' + status,
          status
        )
      );
    }
    return true;
  });
};

/**
 * Logs either a JSSDKError or a JSSDKWarning message, based on the endpoint.
 *
 * @param {string} endpoint The endpoint to log to.
 * @param {Object} data The data to log.
 * @param {string} jsonDataType When set to 'json', the `data.json_data` value
 *     will be passed *as is* to the backend service. When set to 'raw', the
 *     value will be JSON serialized (via `JSON.stringify`) before being set to
 *     the backend. Set to 'raw' by default.
 * @return {Promise.<boolean>} True if the log was accepted by the server.
 * @protected
 */
Logger.prototype._logErrorVariant = function(endpoint, data, jsonDataType) {
  var payload = {
    sdk_id: null,
    platform: null,
    source: data.source || LogValues.UNKNOWN,
    source_version: data.source_version || LogValues.UNKNOWN,
    type: data.type || LogValues.UNKNOWN,
    message: data.message || LogValues.EMPTY,
    stack: JSON.stringify(data.stack || LogValues.EMPTY),
    json_data: jsonDataType === 'json' ?
      data.json_data || '{}' :
      JSON.stringify(data.json_data || {}),
    json_data_version: data.json_data_version || LogValues.EMPTY_VERSION
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, endpoint));
};

Logger.prototype.createStepTimer = function(name) {
  return StepTimer.create(name, this);
};

Logger.prototype.createIntervalTimer = function(name, id) {
  return IntervalTimer.create(name, id, this);
};

/**
 * Logs a ClientEvent message to the backend.
 *
 * Note that this method could only guarantee that the message was sent to the
 * backend, not that it was delivered to the logging service.
 *
 * @param {module:spotify-transport/types.ClientEventData} data The data of the
 *     ClientEvent message.
 * @param {string} jsonDataType When set to 'json', the `data.json_data` value
 *     will be passed *as is* to the backend service. When set to 'raw', the
 *     value will be JSON serialized (via `JSON.stringify`) before being set to
 *     the backend. Set to 'raw' by default.
 * @return {Promise.<boolean>} True if the message was successfully delivered to
 *     the backend, false otherwise.
 */
Logger.prototype.logClientEvent = function(data, jsonDataType) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logClientEvent `data` cannot be null.')
    );
  }
  var payload = {
    sdk_id: null,
    platform: null,
    source: data.source || LogValues.UNKNOWN,
    context: data.context || LogValues.UNKNOWN,
    event: data.event || LogValues.UNKNOWN,
    event_version: data.event_version || LogValues.EMPTY,
    test_version: data.test_version || LogValues.EMPTY,
    source_version: data.source_version || LogValues.UNKNOWN,
    source_vendor: data.source_vendor || LogValues.UNKNOWN,
    json_data: jsonDataType === 'json' ?
      data.json_data || '{}' :
      JSON.stringify(data.json_data || {})
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.CLIENT_EVENT));
};

Logger.prototype.logElapsedTime = function(data) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logElapsedTime `data` cannot be null.')
    );
  }
  var transport = this._transport;
  var payload = {
    sdk_id: null,
    platform: null,
    unique_id: data.unique_id || transport.getInitTime(),
    event: data.event || LogValues.UNKNOWN,
    elapsed_time: data.elapsed_time || LogValues.ZERO
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.ELAPSED_TIME));
};

/**
 * Logs a JSSDKError message.
 *
 * @param {Object} data The data to log.
 * @param {string} jsonDataType When set to 'json', the `data.json_data` value
 *     will be passed *as is* to the backend service. When set to 'raw', the
 *     value will be JSON serialized (via `JSON.stringify`) before being set to
 *     the backend. Set to 'raw' by default.
 * @return {Promise.<boolean>} True if the log was accepted by the server.
 * @protected
 */
Logger.prototype.logJSSDKError = function(data, jsonDataType) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKError `data` cannot be null.')
    );
  }
  return this._logErrorVariant(LogEndpoints.JSSDK_ERROR, data, jsonDataType);
};

/**
 * Logs a JSSDKWarning message.
 *
 * @param {Object} data The data to log.
 * @param {string} jsonDataType When set to 'json', the `data.json_data` value
 *     will be passed *as is* to the backend service. When set to 'raw', the
 *     value will be JSON serialized (via `JSON.stringify`) before being set to
 *     the backend. Set to 'raw' by default.
 * @return {Promise.<boolean>} True if the log was accepted by the server.
 * @protected
 */
Logger.prototype.logJSSDKWarning = function(data, jsonDataType) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKWarning `data` cannot be null.')
    );
  }
  return this._logErrorVariant(LogEndpoints.JSSDK_WARNING, data, jsonDataType);
};

Logger.prototype.logJSSDKPlaybackStats = function(data) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKPlaybackStats `data` cannot be null.')
    );
  }
  var payload = {
    'sdk_id': null,
    'platform': null,
    'play_track': data.play_track,
    'file_id': data.file_id,
    'playback_id': data.playback_id,
    'internal_play_id': data.internal_play_id,
    'memory_cached': data.memory_cached,
    'persistent_cached': data.persistent_cached,
    'audio_format': data.audio_format,
    'video_format': data.video_format,
    'manifest_id': data.manifest_id,
    'protected': data.isProtected,
    'key_system': data.key_system,
    'key_system_impl': data.key_system_impl,
    'urls_json': data.urls_json,
    'start_time': data.start_time,
    'end_time': data.end_time,
    'external_start_time': data.external_start_time,
    'ms_play_latency': data.ms_play_latency,
    'ms_init_latency': data.ms_init_latency,
    'ms_head_latency': data.ms_head_latency,
    'ms_manifest_latency': data.ms_manifest_latency,
    'ms_resolve_latency': data.ms_resolve_latency,
    'ms_license_generation_latency': data.ms_license_generation_latency,
    'ms_license_request_latency': data.ms_license_request_latency,
    'ms_license_session_latency': data.ms_license_session_latency,
    'ms_license_update_latency': data.ms_license_update_latency,
    'ms_played': data.ms_played,
    'ms_nominal_played': data.ms_nominal_played,
    'ms_file_duration': data.ms_file_duration,
    'ms_actual_duration': data.ms_actual_duration,
    'ms_start_position': data.ms_start_position,
    'ms_end_position': data.ms_end_position,
    'ms_seek_rebuffer': data.ms_seek_rebuffer,
    'ms_seek_rebuffer_longest': data.ms_seek_rebuffer_longest,
    'ms_stall_rebuffer': data.ms_stall_rebuffer,
    'ms_stall_rebuffer_longest': data.ms_stall_rebuffer_longest,
    'n_stalls': data.n_stalls,
    'n_seekback': data.n_seekback,
    'n_seekforward': data.n_seekforward,
    'start_bitrate': data.start_bitrate,
    'time_weighted_bitrate': data.time_weighted_bitrate,
    'reason_start': data.reason_start,
    'reason_end': data.reason_end,
    'initially_paused': data.initially_paused,
    'had_error': data.had_error,
    'n_warnings': data.n_warnings,
    'n_navigator_offline': data.n_navigator_offline,
    'session_id': data.sessionId,
    'sequence_id': data.sequenceId
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.JSSDK_PLAYBACK_STATS));
};

Logger.prototype.logJSSDKPlaybackStart = function(data) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKPlaybackStart `data` cannot be null.')
    );
  }
  var payload = {
    sdk_id: null,
    platform: null,
    play_track: data.play_track,
    file_id: data.file_id,
    playback_id: data.playback_id,
    session_id: data.session_id,
    ms_start_position: data.ms_start_position,
    initially_paused: data.initially_paused
  };
  return this._decoratePayload(payload).then(
    this._sendLog.bind(this, LogEndpoints.JSSDK_PLAYBACK_START)
  );
};

Logger.prototype.logJSSDKStall = function(data) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKStall `data` cannot be null.')
    );
  }
  var payload = {
    sdk_id: null,
    platform: null,
    session_id: data.session_id || LogValues.EMPTY,
    playback_id: data.playback_id || LogValues.EMPTY,
    play_track: data.play_track || LogValues.EMPTY,
    file_id: data.file_id || LogValues.EMPTY,
    byte_offset: data.byte_offset || LogValues.ZERO,
    time_offset: data.time_offset || LogValues.ZERO,
    ms_stalled: data.ms_stalled || LogValues.ZERO,
    timed_out: !!data.timed_out
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.JSSDK_STALL));
};

Logger.prototype.logJSSDKTimer = function(data, jsonDataType) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKTimer `data` cannot be null.')
    );
  }
  if (!Array.isArray(data.breakdown)) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKTimer `data.breakdown` must be an array.')
    );
  }

  var payload = {
    sdk_id: null,
    platform: null,
    timer_name: data.timer_name || LogValues.EMPTY,
    ms_duration: data.ms_duration || LogValues.ZERO,
    breakdown: JSON.stringify(data.breakdown),
    breakdown_version: data.breakdown_version || LogValues.EMPTY_VERSION,
    json_data: jsonDataType === 'json' ?
      data.json_data || '{}' :
      JSON.stringify(data.json_data || {}),
    json_data_version: data.json_data_version || LogValues.EMPTY_VERSION
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.JSSDK_TIMER));
};

Logger.prototype.logJSSDKIntervalTimer = function(data) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logJSSDKIntervalTimer `data` cannot be null.')
    );
  }

  var payload = {
    sdk_id: null,
    platform: null,
    timer_name: data.name || LogValues.EMPTY,
    timer_id: data.id || LogValues.EMPTY,
    intervals: data.intervals
  };

  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.JSSDK_INTERVAL_TIMER));
};

Logger.prototype.logTrackStreamVerification = function(data) {
  if (!data) {
    return Promise.reject(
      new TypeError('Logger.logTrackStreamVerification `data` cannot be null.')
    );
  }
  var payload = {
    sdk_id: null,
    platform: null,
    play_track: data.play_track,
    playback_id: data.playback_id,
    ms_played: data.ms_played,
    session_id: data.session_id,
    sequence_id: data.sequence_id,
    next_playback_id: data.next_playback_id
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.TRACK_STREAM_VERIFICATION));
};

Logger.prototype.logMetrics = function(meters, timers) {
  if (!meters && !timers) {
    return Promise.resolve(true);
  }
  var _meters = meters || [];
  var _timers = timers || [];
  if (!_meters.length && !_timers.length) {
    return Promise.resolve(true);
  }
  if (!Array.isArray(_meters) || !Array.isArray(_timers)) {
    return Promise.reject(
      new TypeError(
        'Logger.logMetrics `meters` and `timers` must be null or an array.'
      )
    );
  }

  var i;
  var l;
  // Check meters
  for (i = 0, l = _meters.length; i < l; i++) {
    var meter = _meters[i];
    if (!('what' in meter) || !('result' in meter) || !('reason' in meter)) {
      return Promise.reject(
        new TypeError(
          'Logger.logMetrics: Invalid meter format in `meters` array.'
        )
      );
    }
  }

  // Check timers
  for (i = 0, l = _timers.length; i < l; i++) {
    var timer = _timers[i];
    if (!('what' in timer) || !('duration' in timer)) {
      return Promise.reject(
        new TypeError(
          'Logger.logMetrics: Invalid timer format in `timers` array.'
        )
      );
    }
  }

  var payload = {
    sdk_id: null,
    platform: null,
    meters: _meters,
    timers: _timers
  };
  return this._decoratePayload(payload)
    .then(this._sendLog.bind(this, LogEndpoints.METRICS));
};

module.exports = Logger;
