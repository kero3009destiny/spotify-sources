'use strict';

var debugLogger = require('spotify-debug-tools/logging').forTag(
  'transport.intervaltimer'
);

var hasPerformance =
  typeof global.performance !== 'undefined' &&
  typeof global.performance.now === 'function';

var now = function() {
  return hasPerformance ? performance.now() : Date.now();
};

function IntervalTimer(name, id, logger) {
  this._name = name;

  this._id = id;

  this._logger = logger;

  this._intervals = {};
}

IntervalTimer.prototype.start = function(eventName) {
  if (eventName in this._intervals) {
    debugLogger.warn('Overriding already started interval');
  }
  this._intervals[eventName] = {start: now(), end: null};
};

IntervalTimer.prototype.end = function(eventName) {
  if (eventName in this._intervals && !this._intervals[eventName].end) {
    this._intervals[eventName].end = now();
  } else {
    debugLogger.warn('Tried to end an invalid interval');
  }
};

IntervalTimer.prototype.getIntervals = function() {
  return this._intervals;
};

IntervalTimer.prototype.sendLog = function() {
  var data = {
    name: this._name,
    id: this._id,
    intervals: this._intervals
  };

  var clear = this.clear.bind(this);
  return this._logger.logJSSDKIntervalTimer(data).then(clear, clear);
};

IntervalTimer.prototype.clear = function() {
  this._intervals = {};
  return this;
};

IntervalTimer.create = function(timerName, id, logger) {
  return new IntervalTimer(timerName, id, logger);
};

module.exports = IntervalTimer;
