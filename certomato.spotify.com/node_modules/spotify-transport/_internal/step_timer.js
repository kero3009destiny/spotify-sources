'use strict';

/**
 * The version of the breakdown format used in the log message.
 *
 * @const
 */
var BREAKDOWN_VERSION = '1.0.0';

/**
 * Identifier for the initialization step
 *
 * @const
 */
var INIT = '__init__';

/**
 * A quick check whether the browser supports performance.now().
 *
 * @private
 */
var hasPerformance = typeof global.performance !== 'undefined' &&
  typeof global.performance.now === 'function';


/**
 * Creates StepTimer objects that can be used to measure various stages in an
 * operation.
 *
 * @constructor
 * @param {string} name The name of the timer.
 * @param {module:spotify-transport/lib/logger} logger The logger instance that
 *     can be used to send JSSDKTimer logs to the backend.
 */
function StepTimer(name, logger) {
  /**
   * The name of this logger.
   *
   * @type {string}
   * @protected
   */
  this._name = name;

  /**
   * An instance of the Logger class that will be used to send the logs to the
   * backend.
   *
   * @type {module:spotify-transport/lib/logger}
   * @protected
   */
  this._logger = logger;

  /**
   * An array of steps.
   *
   * @type {Array.<module:spotify-transport/lib/step_timer~Step>}
   * @protected
   */
  this._steps = [];

  this._stepMap = {};

  this._rootStep = null;

  /**
   * The last marked step.
   *
   * @type {module:spotify-transport/lib/step_timer~Step}
   * @protected
   */
  this._lastStep = null;

  this._calculated = null;
}

/**
 * Creates StepTimer objects that can be used to measure various stages in an
 * operation.
 *
 * @param {string} name The name of the timer.
 * @param {module:spotify-transport/lib/logger} logger The logger instance that
 *     can be used to send JSSDKTimer logs to the backend.
 * @return {module:spotify-transport/lib/step_timer} The step timer instance.
 */
StepTimer.create = function(name, logger) {
  return new StepTimer(name, logger);
};

StepTimer.prototype._walkStepTree = function(parent) {
  var breakdown = [];
  var duration = 0;
  var maxElapsed = 0;

  var children = parent.children;

  for (var i = 0; i < children.length; i++) {
    // Visit every child and get their duration (recursively)
    var child = children[i];
    var elapsed = Math.ceil(child.timestamp - parent.timestamp);
    maxElapsed = Math.max(elapsed, maxElapsed);
    breakdown.push({
      name: child.name,
      ms_duration: elapsed,
      parent: parent.name === INIT ? null : parent.name
    });
    var childData = this._walkStepTree(child);
    duration += childData.ms_duration;
    breakdown.push.apply(breakdown, childData.breakdown);
  }

  duration += maxElapsed;

  return {
    ms_duration: duration,
    breakdown: breakdown
  };
};

/**
 * Returns a timestamp.
 *
 * When `performance.now()` is available, it'll use the timestamp from that
 * function. Otherwise, this returns the current date via `Date.now()`
 *
 * @return {number} The current timestamp.
 * @protected
 */
StepTimer.prototype._getTimestamp = function() {
  return hasPerformance ? performance.now() : Date.now();
};

/**
 * Marks the starting step of the operation.
 *
 * This function **must** be called before marking any additional steps.
 *
 * @return {module:spotify-transport/lib/step_timer} Returns the same instance.
 */
StepTimer.prototype.start = function() {
  if (this._lastStep) {
    throw new Error('StepTimer already started.');
  }

  this._rootStep = this._createStep(INIT);

  return this;
};

StepTimer.prototype._createStep = function(name, parent) {
  var step = {
    name: name,
    timestamp: this._getTimestamp(),
    children: []
  };
  this._stepMap[step.name] = step;

  if (parent) {
    parent.children.push(step);
  }

  this._lastStep = step;
  this._calculated = null;

  return step;
};

/**
 * Marks a step in the timer.
 *
 * @param {string} name The name of the step.
 * @return {module:spotify-transport/lib/step_timer} Returns the same instance.
 */
StepTimer.prototype.markStep = function(name) {
  return this.markStepFrom(this._lastStep && this._lastStep.name, name);
};

/**
 * Marks a step in relation to another step in the timer.
 *
 * Steps are usually considered "ordered"; computing the duration of the step
 * requires taking the elapsed time between that particular step and the step
 * before it.
 *
 * This method will explicitly set a "previous step" for the new step being
 * logged. Instead of taking the elapsed time between the new step and the step
 * that was added just before it, steps marked with this method will be measured
 * against any other named step in this timer.
 *
 * @param {string} previousStep A name of a previous step whose timestamp will
 *     be used for measuring. If you provide `null`, the step will be measured
 *     against the time when `start()` was called.
 * @param {string} name The name of this step.
 * @return {module:spotify-transport/lib/step_timer} Returns the same instance.
 */
StepTimer.prototype.markStepFrom = function(previousStep, name) {
  if (!this._lastStep) {
    throw new TypeError('Cannot add step to a non-started StepTimer.');
  }
  if (name in this._stepMap) {
    return this;
  }
  var parentStep = previousStep ? this._stepMap[previousStep] : this._rootStep;
  if (!parentStep) {
    return this;
  }
  this._createStep(name, parentStep);

  return this;
};

/**
 * Calculates the breakdown values for all the steps, and and generates the data
 * that can be used for logging.
 *
 * @return {Object} The calculated data.
 */
StepTimer.prototype.calculate = function() {
  if (this._calculated) {
    return this._calculated;
  }
  var data = this._walkStepTree(this._rootStep);
  var calculated = {
    timer_name: this._name,
    ms_duration: Math.ceil(data.ms_duration),
    breakdown: data.breakdown,
    breakdown_version: BREAKDOWN_VERSION
  };
  this._calculated = calculated;
  return calculated;
};

/**
 * Sends the calculated timer values as a JSSDKTimer log via the provided
 * logger.
 *
 * @param {Object} additionalData The additional logging data, such as
 *     `json_data` and the `json_data_version`.
 * @param {string} jsonDataType If `json_data` is provided via the
 *     additionalData object, this value determines whether that data must be
 *     encoded (by providing a value of 'raw') or sent as is without encoding
 *     (by providing a value of 'json).
 * @return {Promise} Returns a promise.
 */
StepTimer.prototype.sendLog = function(additionalData, jsonDataType) {
  var _additionalData = additionalData || {};
  var data = this.calculate();
  data.json_data = _additionalData.json_data;
  data.json_data_version = _additionalData.json_data_version;
  return this._logger.logJSSDKTimer(data, jsonDataType);
};

module.exports = StepTimer;
