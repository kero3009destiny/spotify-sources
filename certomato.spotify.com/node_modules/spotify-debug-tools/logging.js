'use strict';

var Logger = require('./lib/logger');

var GLOBAL_LOGGER_REGISTRY_KEY = '__dbgLoggerRegistry';

var globalRegistry = global[GLOBAL_LOGGER_REGISTRY_KEY];

if (!globalRegistry) {
  globalRegistry = {map: {}, list: [], loggingPredicate: null};
  if (Object.defineProperty) {
    Object.defineProperty(global, GLOBAL_LOGGER_REGISTRY_KEY, {
      value: globalRegistry
    });
  } else {
    global[GLOBAL_LOGGER_REGISTRY_KEY] = globalRegistry;
  }
}

var loggerMap = globalRegistry.map;
var loggers = globalRegistry.list;

function _checkLog(logObj) {
  if (globalRegistry.loggingPredicate &&
      globalRegistry.loggingPredicate(logObj)) {
    return true;
  }
  return false;
}

var _level = 'log';

module.exports = {

  intercept: function(predicate) {
    if (typeof predicate !== 'function') {
      throw new TypeError('Logging.intercept requires a function predicate.');
    }
    globalRegistry.loggingPredicate = predicate;
  },

  unintercept: function() {
    globalRegistry.loggingPredicate = null;
  },

  list: function(asArray) {
    var keys = Object.keys(loggerMap);
    keys.sort();
    var i;
    var l;
    var key;
    if (asArray) {
      var array = [];
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        if (!loggerMap[key]) {
          continue;
        }
        array.push({
          tag: key,
          description: loggerMap[key].description || 'No description.'
        });
      }
      return array;
    }
    var map = {};
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      if (!loggerMap[key]) {
        continue;
      }
      map[key] = loggerMap[key].description || 'No description';
    }
    return map;
  },

  enable: function(tag) {
    var tags = Array.isArray(tag) ? tag : [tag];
    var tagLen = tags.length;
    while (tagLen--) {
      var tagName = tags[tagLen].toLowerCase();
      var loggerLen = loggers.length;
      while (loggerLen--) {
        var logger = loggers[loggerLen];
        if (logger.matchesTag(tagName)) {
          logger.enable();
        }
      }
    }
  },

  disable: function(tag) {
    var tags = Array.isArray(tag) ? tag : [tag];
    var tagLen = tags.length;
    while (tagLen--) {
      var tagName = tags[tagLen].toLowerCase();
      var loggerLen = loggers.length;
      while (loggerLen--) {
        var logger = loggers[loggerLen];
        if (logger.matchesTag(tagName)) {
          logger.disable();
        }
      }
    }
  },

  setLevel: function(level) {
    _level = level;
    var loggerLen = loggers.length;
    while (loggerLen--) {
      var logger = loggers[loggerLen];
      if (logger) {
        logger.setLevel(level);
      }
    }
  },

  enableAll: function() {
    var l = loggers.length;
    while (l--) {
      if (!loggers[l]) {
        continue;
      }
      loggers[l].enable();
    }
  },

  disableAll: function() {
    var l = loggers.length;
    while (l--) {
      if (!loggers[l]) {
        continue;
      }
      loggers[l].disable();
    }
  },

  forTag: function(tag, optDescription) {
    var tagName;
    var description;
    if (typeof tag === 'string') {
      tagName = tag.toLowerCase();
      description = optDescription;
    } else {
      tagName = tag.tag;
      description = tag.description;
    }
    if (loggerMap.hasOwnProperty(tagName) && loggerMap[tagName]) {
      return loggerMap[tagName];
    }
    var logger = new Logger(tagName, description, _checkLog);
    logger.setLevel(_level);
    loggerMap[tagName] = logger;
    loggers.push(logger);
    return logger;
  },

  remove: function(tag) {
    var tagName = tag.toLowerCase();
    if (!loggerMap.hasOwnProperty(tagName) || !loggerMap[tagName]) {
      return;
    }
    var logger = loggerMap[tagName];
    loggerMap[tagName] = null;
    var index = loggers.indexOf(logger);
    if (index !== -1) {
      loggers.splice(index, 1);
    }
    return;
  }

};
