'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var PlaybackStateObserver = require('./playback_state_observer');

var ErrorSource = require('../../types/error_source');
var Event = require('../../_internal/types/event');
var PlaybackEvent = require('spotify-playback/types/event');
var OperationResult = require('spotify-playback/types/operation_result');

/**
 * The HarmonyStreamer class.
 *
 * @exports module:spotify-stream/stream
 * @constructor
 * @param {Object} options
 * @see {@link module:spotify-stream.create}
 */
function HarmonyStreamer(options) {
  EventEmitter.call(this);

  this._descriptor = options.descriptor;
  this._client = options.client;
  this._listPlayer = options.listPlayer;
  this._tpApiClient = options.tpApiClient;
  this._playerPromise = options.playerPromise;
  this._initialVolume = options.initialVolume;
  this._playbackStateObserver = null;

  this._init();
}
inherit(HarmonyStreamer, EventEmitter);

HarmonyStreamer.prototype._init = function() {
  this._client.on(
    Event.CLIENT_BEFORE_DISCONNECT,
    this._onClientBeforeDisconnect.bind(this)
  );
  this._client.on(
    Event.CLIENT_BEFORE_OFFLINE_DISCONNECT,
    this._onClientBeforeOfflineDisconnect.bind(this)
  );

  var listPlayer = this._listPlayer;
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_BEFORE_VOLUME_CHANGE,
    this._onBeforeVolumeChange.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_CAPPED,
    this._onCapped.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_TRACK_ENDED,
    this._onTrackEnded.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_ERROR,
    this._onError.bind(this, ErrorSource.PLAYBACK)
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_AUTOPLAY_FAILED,
    Event.STREAMER_AUTOPLAY_FAILED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_TRACK_LOADED,
    Event.STREAMER_TRACK_LOADED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_DURATION_CHANGED,
    Event.STREAMER_DURATION_CHANGED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_LOAD_VIDEO,
    Event.STREAMER_LOAD_VIDEO
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_STOPPED_VIDEO,
    Event.STREAMER_STOPPED_VIDEO
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_POSITION_CHANGED,
    Event.STREAMER_POSITION_CHANGED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_PROGRESS,
    Event.STREAMER_PROGRESS
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_BUFFERING_END,
    Event.STREAMER_BUFFERING_END
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_BUFFERING_START,
    Event.STREAMER_BUFFERING_START
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_MAX_LIST_ERRORS_REACHED,
    Event.STREAMER_MAX_LIST_ERRORS_REACHED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_VIDEO_ELEMENT_APPENDED,
    Event.STREAMER_VIDEO_ELEMENT_APPENDED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_VIDEO_ELEMENT_REMOVED,
    Event.STREAMER_VIDEO_ELEMENT_REMOVED
  );
  this.proxyEmit(
    listPlayer,
    PlaybackEvent.LIST_PLAYER_LIST_ENDED,
    Event.STREAMER_CONTEXT_ENDED
  );

  var tpApiClient = this._tpApiClient;
  tpApiClient.on(Event.TP_API_LOGOUT, this._onTPAPILogout.bind(this));
  tpApiClient.on(
    Event.TP_API_ERROR,
    this._onError.bind(this, ErrorSource.TRACK_PLAYBACK)
  );
  this.proxyEmit(
    tpApiClient,
    Event.TP_API_MAX_SUBSCRIPTIONS_REACHED,
    Event.STREAMER_MAX_SUBSCRIPTIONS_REACHED
  );
  this.proxyEmit(
    tpApiClient,
    Event.TP_API_DEREGISTERED,
    Event.STREAMER_DEREGISTERED
  );
  this.proxyEmit(
    tpApiClient,
    Event.TP_API_REGISTERED,
    Event.STREAMER_REGISTERED
  );
  this.proxyEmit(
    tpApiClient,
    Event.TP_API_REGISTRATION_ABORTED,
    Event.STREAMER_REGISTRATION_ABORTED
  );

  this._playbackStateObserver = new PlaybackStateObserver(this._tpApiClient, {
    manifestFormats: this._descriptor.then(function(descriptor) {
      return descriptor.getManifestFormats();
    })
  });
  this.proxyEmit(
    this._playbackStateObserver,
    Event.PLAYBACK_STATE_OBSERVER_STATE_CHANGED,
    Event.STREAMER_STATE_CHANGED
  );

  this._playerPromise.then(function(player) {
    player.setVolume(this._initialVolume);
    this.emit(Event.STREAMER_PLAYER_INITIALIZATION_DONE);
  }.bind(this), function(e) {
    this.emit(Event.STREAMER_PLAYER_INITIALIZATION_FAILED, {
      reason: e.message,
      error: e
    });
  }.bind(this));
};

/**
 * Method for converting an operation result to boolean.
 *
 * @param {Promise.<module:spotify-contextplayer/types/operationresult>} result
 *     The ListPlayer operation result.
 * @return {boolean}
 */
HarmonyStreamer.prototype._assertOperationSuccess = function(result) {
  return result === OperationResult.SUCCESS;
};

HarmonyStreamer.prototype._onTrackEnded = function() {
  // We do not want to forward track data
  this.emit(Event.STREAMER_TRACK_ENDED);
};

HarmonyStreamer.prototype._onClientBeforeDisconnect = function(e) {
  if (e) {
    e.awaitPromise(this.deregister().catch(function() {
      // Ignore any errors from deregistering that might prevent other waiters
      // from disconnecting.
    }));
  }
};

HarmonyStreamer.prototype._onClientBeforeOfflineDisconnect = function(e) {
  if (e) {
    e.awaitPromise(this.pause().catch(function() {
      // Ignore any errors.
    }));
  }
};
HarmonyStreamer.prototype._onBeforeVolumeChange = function(e) {
  var ev = this.emitSync(Event.STREAMER_BEFORE_VOLUME_CHANGE, {
    volume: e.volume
  });

  if (ev.defaultPrevented) {
    e.preventDefault();
  }
};
HarmonyStreamer.prototype._onCapped = function() {
  // We do not want to forward track data
  this.emit(Event.STREAMER_PLAYBACK_CAPPED);
};

HarmonyStreamer.prototype._onError = function(source, e) {
  var error = e.error;
  if (error) {
    if (error.registration && source === ErrorSource.TRACK_PLAYBACK) {
      this.emit(Event.STREAMER_REGISTRATION_ERROR, {
        error: error
      });
    }
  }
  this.emit(Event.STREAMER_ERROR, {
    source: source,
    name: e.name,
    error: error
  });
  this._client.notifyError(source, e.name, e.error);
};

HarmonyStreamer.prototype._onTPAPILogout = function() {
  this._client.disconnect();
  this.emit(Event.STREAMER_LOGGED_OUT);
};

HarmonyStreamer.prototype.register = function() {
  return this._tpApiClient.register();
};

HarmonyStreamer.prototype.deregister = function() {
  return this._tpApiClient.deregister();
};

// Player Controls

/**
 * Resume playback (start playing).
 *
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.resume = function() {
  return this._listPlayer.resume()
    .then(this._assertOperationSuccess);
};

/**
 * Pause playback.
 *
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.pause = function() {
  return this._listPlayer.pause()
    .then(this._assertOperationSuccess);
};

/**
 * Skip to the next track.
 *
 * @param {string} [reason='nextbtn']
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.nextTrack = function(reason) {
  return this._listPlayer.next(reason || 'nextbtn')
    .then(this._assertOperationSuccess);
};

/**
 * Checks if the player can change track.
 *
 * @return {Promise.<boolean>} A promise that will be resolved with a boolean
 *    indicating if the client is allowed to change track
 */
HarmonyStreamer.prototype.canChangeTrack = function() {
  return this._listPlayer.canChangeTrack();
};

/**
 * Skip to the previous track.
 *
 * @param {string} [reason='prevbtn']
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.previousTrack = function(reason) {
  return this._listPlayer.previous(reason || 'prevbtn')
    .then(this._assertOperationSuccess);
};

/**
 * Toggle between play / pause.
 *
 * Will pause if already playing, otherwise start playing.
 *
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.togglePlay = function() {
  return this._listPlayer.togglePlay()
    .then(this._assertOperationSuccess);
};


/**
 * Change the volume of the media element.
 *
 * @param {number} value The new volume, a float betwen 0.0 (silent) and 1.0
 *     (loudest).
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.setVolume = function(value) {
  return this._listPlayer.setVolume(value)
    .then(this._assertOperationSuccess);
};

/**
 * Get the current volume of the media element. 0.0 is silent, 1.0 is loudest.
 *
 * @return {Promise.<number>} A promise that will be resolved with the volume.
 */
HarmonyStreamer.prototype.getVolume = function() {
  return this._listPlayer.getVolume();
};

/**
 * Seek in the buffer.
 *
 * @param {number} value The new position (in milliseconds)
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.seek = function(value) {
  return this._listPlayer.seek(value)
    .then(this._assertOperationSuccess);
};

/**
 * Get the current view of the playback state.
 *
 * @return {Promise.<module:spotify-stream/types.PlaybackState>} A promise that
 *     resolves the current (or future, in case there is no track window yet)
 *     track window.
 */
HarmonyStreamer.prototype.getCurrentState = function() {
  return this._playbackStateObserver.getCurrentState();
};

/**
 * Get the current list of video profiles.
 *
 * @return {Array.<Object>} A promise that resolves a list of the current video
 *     profiles.
 */
HarmonyStreamer.prototype.getVideoProfiles = function() {
  return this._playerPromise.then(function(player) {
    return player.getVideoProfiles();
  });
};

/**
 * Overrides adaptive bitrate management, takes a property representing the
 *     bitrate to use regardless of the current bandwidth.
 *
 * @param {number} value The highest possible bitrate to select.
 * @return {Promise.<boolean>} A promise that will be resolved with the value
 *     `true` if the operation was successful.
 */
HarmonyStreamer.prototype.setPreferredBitrate = function(value) {
  return this._playerPromise.then(function(player) {
    return player.setPreferredBitrate(value)
      .then(this._assertOperationSuccess);
  }.bind(this));
};

module.exports = HarmonyStreamer;
