'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var URI = require('spotify-liburi');
var LRUCache = require('spotify-linkedlist/lrucache');

var debugLogger = require('spotify-debug-tools/logging')
  .forTag('harmony.controller');

var PlayerAPIClientError = require('./connect_service/client_error');

var RepeatMode = require('../../types/repeat_mode');
var Event = require('../../_internal/types/event');
var Errors = require('../../types/errors');

var DEFAULT_WINDOW_LENGTH = 2;

var DEFAULT_CACHE_SIZE = 20;

var TRACKING_INTERVAL = 500;

var EXTRACT_RESTRICTION_NAME = /^disallow_([^]+)_reasons$/;

var EXPOSED_RESTRICTIONS = {
  disallow_pausing_reasons: true,
  disallow_resuming_reasons: true,
  disallow_seeking_reasons: true,
  disallow_peeking_prev_reasons: true,
  disallow_peeking_next_reasons: true,
  disallow_skipping_prev_reasons: true,
  disallow_skipping_next_reasons: true,
  disallow_toggling_repeat_context_reasons: true,
  disallow_toggling_repeat_track_reasons: true,
  disallow_toggling_shuffle_reasons: true
};

var Licenses = {
  PREMIUM: 'premium',
  ON_DEMAND: 'on-demand'
};

function HarmonyController(options) {
  EventEmitter.call(this);

  this._client = options.client;

  this._transport = this._client.getPublicTransport();

  this._serverTime = options.serverTime;

  this._version = options.version;

  this._playerClient = options.playerClient;

  this._decorate = !!options.decorateTrackWindow;

  this._disableProgress = options.disableProgress;

  this._contextPlayerState = null;

  this._suppressed = false;

  this._lastDeviceInfoData = null;

  this._deviceInfo = null;

  this._state = null;

  this._isOrphanedState = false;

  this._progressPosition = 0;

  this._lastProgressTs = 0;

  this._trackingIntervalId = null;

  this._metadataCache = null;

  this._init();
}
inherit(HarmonyController, EventEmitter);

HarmonyController.create = function(options) {
  return new HarmonyController(options);
};

HarmonyController.prototype._init = function() {
  if (this._decorate) {
    this._metadataCache = new LRUCache(DEFAULT_CACHE_SIZE);
  }

  this._client.on(
    Event.CLIENT_BEFORE_DISCONNECT,
    this._onClientBeforeDisconnect.bind(this)
  );

  this.proxyEmit(
    this._playerClient,
    Event.CONNECT_API_MAX_SUBSCRIPTIONS_REACHED,
    Event.CONTROLLER_MAX_SUBSCRIPTIONS_REACHED
  );
  this.proxyEmit(
    this._playerClient,
    Event.CONNECT_API_DEVICES_CHANGED,
    Event.CONTROLLER_DEVICES_CHANGED
  );
  this.proxyEmit(
    this._playerClient,
    Event.CONNECT_API_REGISTERED,
    Event.CONTROLLER_REGISTERED
  );

  this._playerClient.on(
    Event.CONNECT_API_DEVICE_STATE_CHANGED,
    this._onDeviceStateChanged.bind(this)
  );
  this._playerClient.on(
    Event.CONNECT_API_PLAYER_STATE_CHANGED,
    this._onPlayerStateChanged.bind(this)
  );
};

HarmonyController.prototype._onClientBeforeDisconnect = function(e) {
  if (e) {
    e.awaitPromise(this._playerClient.deregister().catch(function() {
      // Ignore any errors from deregistering that might prevent other waiters
      // from disconnecting.
    }));
  }
};

HarmonyController.prototype._onDeviceStateChanged = function(e) {
  this._lastDeviceInfoData = {
    deviceInfo: e.deviceState,
    hasOrphanedState: e.hasOrphanedState
  };
  if (!this._suppressed) {
    this.emit(Event.CONTROLLER_DEVICE_INFO_CHANGED, this._lastDeviceInfoData);
  }
};

/**
 * Starts tracking the state of the player
 *
 * @protected
 * @function
 */
HarmonyController.prototype._startProgressTracking = function() {
  this._stopProgressTracking();
  this._lastProgressTs = Date.now();
  this._onProgressTracking();
  this._trackingIntervalId = setInterval(
    this._onProgressTracking.bind(this),
    TRACKING_INTERVAL
  );
};

/**
 * Stops tracking the state of the player
 *
 * @protected
 */
HarmonyController.prototype._stopProgressTracking = function() {
  if (this._trackingIntervalId) {
    clearInterval(this._trackingIntervalId);
    this._trackingIntervalId = null;
  }
};

/**
 * It tracks the state of the player
 *
 * @protected
 * @function
 */
HarmonyController.prototype._onProgressTracking = function() {
  var now = Date.now();
  this._progressPosition += now - this._lastProgressTs;
  this.emit(Event.CONTROLLER_PROGRESS, {
    position: this._progressPosition,
    timestamp: Date.now()
  });
  this._lastProgressTs = now;
};

HarmonyController.prototype._getLicense = function() {
  return this._client.getProductState().then(function(productState) {
    return productState.ads === '1' ? Licenses.ON_DEMAND : Licenses.PREMIUM;
  }).catch(function() {
    return Licenses.ON_DEMAND;
  });
};

HarmonyController.prototype._generatePlayOptions = function(
  options,
  noOverrides
) {
  return this._getLicense().then(function(license) {
    var preparedOptions = {
      skip_to: undefined,
      seek_to: undefined,
      initially_paused: undefined,
      license: license,
      player_options_override: undefined
    };
    if (
      'index' in options ||
      'trackUID' in options ||
      'trackURI' in options
    ) {
      preparedOptions.skip_to = {
        track_uid: options.trackUID,
        track_index: options.index,
        track_uri: options.trackURI
      };
    }
    if ('initialOffset' in options) {
      preparedOptions.seek_to = options.initialOffset;
    }
    if ('paused' in options) {
      preparedOptions.initially_paused = options.paused;
    }
    if (noOverrides) {
      // We do not want to process other options, so return early.
      return preparedOptions;
    }
    var optionsOverride = preparedOptions.player_options_override = {};
    if ('shuffle' in options) {
      optionsOverride.shuffling_context = options.shuffle;
    }
    if ('repeatMode' in options) {
      switch (options.repeatMode) {
        case RepeatMode.CONTEXT:
          optionsOverride.repeating_context = true;
          optionsOverride.repeating_track = false;
          break;
        case RepeatMode.TRACK:
          optionsOverride.repeating_track = true;
          optionsOverride.repeating_context = false;
          break;
        case RepeatMode.OFF:
          optionsOverride.repeating_track = false;
          optionsOverride.repeating_context = false;
          break;
        default:
        // No-op, use defaults.
          break;
      }
    }
    return preparedOptions;
  });
};

HarmonyController.prototype._setFilterAndSort = function(context, options) {
  if (options.filter) {
    context.metadata['filtering.predicate'] = options.filter;
  }
  if (options.sort) {
    context.metadata['sorting.criteria'] = options.sort;
  }
};

HarmonyController.prototype._generatePlayOrigin = function(options) {
  var originValues = options.playOrigin || {};

  // We need to send feature classes as an array (it's actually a set, but the
  // backend should dedupe it), so we need to ensure that it's an array.
  if (
    originValues.featureClasses &&
    !Array.isArray(originValues.featureClasses)
  ) {
    throw new TypeError(
      'PlayOptions playOrigin.featureClasses must be an array of strings.'
    );
  }

  var playOrigin = {
    feature_identifier: originValues.featureIdentifier || 'harmony',
    feature_version: originValues.featureVersion || this._version,
    feature_classes: originValues.featureClasses,
    view_uri: originValues.viewURI,
    external_referrer: originValues.externalReferrer,
    referrer_identifier: originValues.referrerIdentifier
  };
  return playOrigin;
};

HarmonyController.prototype._parseRestrictions = function(state) {
  var res = {};
  for (var key in state.restrictions) {
    if (state.restrictions.hasOwnProperty(key) && EXPOSED_RESTRICTIONS[key]) {
      res[key] = state.restrictions[key];
    } else if (EXPOSED_RESTRICTIONS[key]) {
      res[key] = [];
    }
  }
  return res;
};

HarmonyController.prototype._parseDisallows = function(state) {
  var res = {};
  var restrictions = state.restrictions;
  for (var key in restrictions) {
    if (restrictions.hasOwnProperty(key) && EXPOSED_RESTRICTIONS[key]) {
      var disallow = !!(restrictions[key] &&
                        restrictions[key].length);
      res[key.replace(EXTRACT_RESTRICTION_NAME, '$1')] = disallow;
    }
  }
  return res;
};

HarmonyController.prototype._onPlayerStateChanged = function(e) {
  this._contextPlayerState = e.playerState;
  this._isOrphanedState = e.orphaned;
  this._parsePlayerState(e.playerState)
    .then(function(state) {
      this._state = state;
      var stateCopy = this._copyState();
      if (!this._suppressed) {
        this.emit(Event.CONTROLLER_STATE_CHANGED, {
          state: stateCopy,
          orphaned: e.orphaned
        });
      }

      // Progress tracking
      if (!this._disableProgress && state) {
        this._progressPosition = state.position;
        if (state.paused) {
          this._stopProgressTracking();
        } else {
          this._startProgressTracking();
        }
      }
    }.bind(this));
};

HarmonyController.prototype._copyState = function() {
  return this._state ? JSON.parse(JSON.stringify(this._state)) : null;
};

HarmonyController.prototype._parsePlayerState = function(state) {
  if (!state) {
    return Promise.resolve(null);
  }
  return this._getTrackWindow(state).then(function(trackWindow) {
    var formatted = {
      context: {
        uri: state.context_uri,
        metadata: state.context_metadata || {}
      },
      timestamp: state.timestamp,
      duration: state.duration ||
        (trackWindow.current_track && trackWindow.current_track.duration_ms) ||
        0,
      position: state.is_paused ?
        state.position_as_of_timestamp :
        this._offsetPosition(state.timestamp, state.position_as_of_timestamp),
      paused: state.is_paused,
      shuffle: state.options && state.options.shuffling_context,
      repeat_mode: this._getStateRepeatMode(state),
      restrictions: this._parseRestrictions(state),
      disallows: this._parseDisallows(state),
      track_window: trackWindow,
      bitrate: null
    };

    return formatted;
  }.bind(this));
};

HarmonyController.prototype._offsetPosition = function(
  timestamp,
  position,
  optNow
) {
  var currentTime = optNow || this._serverTime.getApproximate();
  var offset = currentTime - timestamp;
  var maybePosition = position + offset;
  return maybePosition < 0 ? 0 : maybePosition;
};

HarmonyController.prototype._isRestricted = function(state, restriction) {
  if (!state) {
    return false;
  }
  var restrictionName = 'disallow_' + restriction + '_reasons';
  return state.restrictions &&
    (restrictionName in state.restrictions) &&
    !!(state.restrictions[restrictionName].length);
};

HarmonyController.prototype._getTrackWindow = function(state) {
  var trackWindow = {
    current_track: null,
    next_tracks: [],
    previous_tracks: []
  };
  var map = {};
  var trackList = [];
  if (!state.track) {
    return Promise.resolve(trackWindow);
  }
  // parse current track
  var currentURI = state.track.uri;
  if (!currentURI) {
    return Promise.resolve(trackWindow);
  }
  var uriObj = URI.from(currentURI);
  var maybeLocal = this._parseLocalTrack(uriObj);
  var maybeAd = this._parseAd(uriObj, state.track);
  trackWindow.current_track = maybeLocal || maybeAd || {uri: currentURI};
  if (!maybeLocal && !maybeAd) {
    map[currentURI] = 1;
    trackList.push(currentURI);
  }

  if (!this._isRestricted(state, 'peeking_next')) {
    this._fillWindow(
      trackList,
      trackWindow.next_tracks,
      map,
      state.next_tracks.slice(0, 5)
    );
  }

  if (!this._isRestricted(state, 'peeking_prev')) {
    this._fillWindow(
      trackList,
      trackWindow.previous_tracks,
      map,
      state.prev_tracks.slice(-5),
      true
    );
  }

  return this._decorate ?
    this._decorateMetadata(trackList, trackWindow) :
    Promise.resolve(trackWindow);
};

HarmonyController.prototype._fillWindow = function(list, win, map, tracks, rv) {
  if (rv) {
    tracks.reverse();
  }
  for (var i = 0, l = tracks.length; i < l; i++) {
    var uri = tracks[i].uri;
    var uriObj = URI.from(uri);
    if (
      !uri || uri === 'spotify:delimiter' ||
      (
        uriObj &&
        (uriObj.type === URI.Type.AD || uriObj.type === URI.Type.INTERRUPTION)
      )
    ) {
      // Disallow non-URIs and ads from appearing in the up next queue.
      continue;
    }
    var maybeLocal = this._parseLocalTrack(uriObj);
    var track = maybeLocal || {
      uri: uri
    };
    if (!maybeLocal && !(uri in map)) {
      map[uri] = 1;
      list.push(uri);
    }
    if (rv) {
      win.unshift(track);
    } else {
      win.push(track);
    }
    if (win.length === DEFAULT_WINDOW_LENGTH) {
      break;
    }
  }
};

HarmonyController.prototype._parseLocalTrack = function(uriObj) {
  if (!uriObj || uriObj.type !== URI.Type.LOCAL) {
    return null;
  }
  var track = {
    id: null,
    uri: uriObj.toURI(),
    type: 'local',
    media_type: 'audio',
    name: uriObj.track,
    artists: [{
      uri: URI.localArtistURI(uriObj.artist).toURI(),
      name: uriObj.artist
    }],
    album: {
      uri: URI.localAlbumURI(uriObj.artist, uriObj.album).toURI(),
      name: uriObj.album,
      images: [{url: ''}]
    },
    // Local-track duration is in seconds
    duration_ms: (uriObj.duration * 1000) || 0,
    is_playable: false
  };
  return track;
};

HarmonyController.prototype._parseAd = function(uriObj, item) {
  if (
    !uriObj ||
    (uriObj.type !== URI.Type.AD && uriObj.type !== URI.Type.INTERRUPTION)
  ) {
    return null;
  }
  if (!item || !item.metadata) {
    return null;
  }
  var metadata = item.metadata;
  var track = {
    id: uriObj.id,
    uri: uriObj.toURI(),
    type: uriObj.type,
    media_type: 'audio',
    name: metadata.title,
    artists: [{
      uri: metadata.click_url,
      name: metadata.advertiser
    }],
    album: {
      uri: '',
      name: '',
      images: [{url: metadata.image_url}]
    },
    // duration in ad metadata is reported as a String, so this is needed:
    duration_ms: parseInt(metadata.duration, 10),
    is_playable: false
  };
  return track;
};

HarmonyController.prototype._decorateMetadata = function(list, trackWindow) {
  var cache = this._metadataCache;
  var podcastRequests = [];
  var requestList = [];
  for (var i = 0, l = list.length; i < l; i++) {
    var item = list[i];
    if (cache.get(item)) {
      continue;
    }
    var uri = URI.from(item);
    if (!uri) {
      continue;
    }
    var id = URI.hexToId(uri.id);
    if (uri.type === URI.Type.TRACK) {
      requestList.push(id);
    } else {
      podcastRequests.push(this._requestPodcastData(id, item));
    }
  }
  return Promise.all([
    Promise.all(podcastRequests).then(function(responses) {
      return responses.indexOf(false) === -1;
    }),
    requestList.length ? this._requestTracksData(requestList) : false
  ]).spread(function(podcastResponse, trackResponse) {
    if (!podcastResponse && !trackResponse) {
      return trackWindow;
    }
    return this._performDecoration(trackWindow);
  }.bind(this));
};

HarmonyController.prototype._requestTracksData = function(requestList) {
  var cache = this._metadataCache;

  var url = [
    'https://@webapi/v1/tracks',
    '?ids=', requestList.join(','),
    '&market=from_token'
  ].join('');

  return this._transport.request(url, {
    responseType: 'json'
  })
    .then(function(response) {
      if (response.status !== 200) {
        return false;
      }
      var body = response.body;
      if (!body) {
        return false;
      }
      // prepare map
      var tracks = body.tracks;
      var len = tracks.length;
      while (len--) {
        var track = tracks[len];
        if (!track) {
          continue;
        }
        cache.set(track.uri, track);
        track.media_type = 'audio';
        if (track.linked_from && track.linked_from.uri) {
          cache.set(track.linked_from.uri, track);
        }
      }
      return true;
    });
};

HarmonyController.prototype._requestPodcastData = function(id, uri) {
  var cache = this._metadataCache;
  var url = 'https://@webapi/v1/episodes/' + id;
  return this._transport.request(url, {
    responseType: 'json'
  }).then(function(response) {
    if (response.status !== 200) {
      return false;
    }
    var body = response.body;
    if (!body) {
      return false;
    }
    var track = {
      id: id,
      uri: uri,
      type: 'episode',
      media_type: body.show.media_type,
      name: body.name,
      artists: [{
        uri: body.show.uri,
        name: body.show.publisher
      }],
      album: {
        uri: body.show.uri,
        name: body.show.name,
        images: body.images
      },
      duration_ms: body.duration_ms || 0,
      is_playable: true
    };
    cache.set(uri, track);
    return true;
  }).catch(function() {
    return false;
  });
};

HarmonyController.prototype._performDecoration = function(trackWindow) {
  var cache = this._metadataCache;
  var decoratedWindow = {
    current_track: null,
    next_tracks: [],
    previous_tracks: []
  };
  var len;
  var trackData;
  var sparseTrackData;
  if (trackWindow.current_track) {
    trackData = cache.get(trackWindow.current_track.uri);
    decoratedWindow.current_track = trackData || trackWindow.current_track;
  }
  len = trackWindow.next_tracks.length;
  while (len--) {
    sparseTrackData = trackWindow.next_tracks[len];
    trackData = cache.get(sparseTrackData.uri);
    decoratedWindow.next_tracks[len] = trackData || sparseTrackData;
  }
  len = trackWindow.previous_tracks.length;
  while (len--) {
    sparseTrackData = trackWindow.previous_tracks[len];
    trackData = cache.get(sparseTrackData.uri);
    decoratedWindow.previous_tracks[len] = trackData || sparseTrackData;
  }
  return decoratedWindow;
};

HarmonyController.prototype._getStateRepeatMode = function(state) {
  var options = state.options;
  if (options) {
    if (options.repeating_track) {
      return RepeatMode.TRACK;
    }
    if (options.repeating_context) {
      return RepeatMode.CONTEXT;
    }
  }
  return RepeatMode.OFF;
};

HarmonyController.prototype.getActiveDevice = function() {
  return this._playerClient.getActiveDevice();
};

HarmonyController.prototype.getCurrentState = function(noOrphans) {
  if (noOrphans && this._isOrphanedState) {
    return Promise.resolve(null);
  }
  if (this._state) {
    // Offset the time
    if (!this._state.paused) {
      var now = this._serverTime.getApproximate();
      this._state.position = this._offsetPosition(
        this._state.timestamp,
        this._state.position,
        now
      );
      // As position is updated, the timestamp also needs to be updated
      // so the offset keeps working correctly on following calls on the same
      // state
      this._state.timestamp = now;
    }
  }
  return Promise.resolve(this._copyState());
};

HarmonyController.prototype.getContextPlayerState = function() {
  debugLogger.warn(
    'The `getContextPlayerState()` method is not well supported. ' +
    'Please avoid using it directly.'
  );
  return this._playerClient.getContextPlayerState();
};

HarmonyController.prototype.getDevices = function() {
  return this._playerClient.getDevices();
};

HarmonyController.prototype._play = function(context, deviceId, options) {
  var _options = options || {};
  this._setFilterAndSort(context, _options);
  return this._generatePlayOptions(_options).then(function(preparedOptions) {
    var payload = {
      context: context,
      play_origin: this._generatePlayOrigin(_options),
      options: preparedOptions
    };
    return this._playerClient.play(payload, deviceId);
  }.bind(this));
};

HarmonyController.prototype.playURI = function(uri, deviceId, options) {
  var _options = options || {};
  if (!URI.from(uri)) {
    return Promise.reject(new TypeError('Invalid Spotify URI'));
  }
  var context = {
    uri: uri,
    url: 'context://' + uri,
    metadata: _options.contextMetadata || {}
  };
  return this._play(context, deviceId, _options);
};

HarmonyController.prototype.playTracks = function(uris, deviceId, options) {
  var _options = options || {};
  if (!Array.isArray(uris)) {
    return Promise.reject(new TypeError('Invalid tracks array.'));
  }
  return this._prepareTracks(uris).then(function(tracks) {
    var context = {
      uri: _options.contextURI || 'spotify:app:playerapi-client',
      metadata: _options.contextMetadata || {},
      pages: [{
        tracks: tracks
      }]
    };
    return this._play(context, deviceId, _options);
  }.bind(this));
};

HarmonyController.prototype.updateCurrentContext = function(deviceId, options) {
  return this._playerClient.updateCurrentContext(deviceId, options);
};

HarmonyController.prototype.setQueue = function(
  nextTracks,
  previousTracks,
  deviceId
) {
  if (!Array.isArray(nextTracks)) {
    return Promise.reject(new TypeError('Invalid nextTracks array.'));
  }
  if (!Array.isArray(previousTracks)) {
    return Promise.reject(new TypeError('Invalid previousTracks array.'));
  }
  return Promise.all([
    this._prepareTracks(nextTracks),
    this._prepareTracks(previousTracks)
  ]).spread(function(next, previous) {
    var payload = {
      next_tracks: next.length ? next : undefined,
      prev_tracks: previous.length ? previous : undefined
    };
    return this._playerClient.setQueue(payload, deviceId);
  }.bind(this));
};

HarmonyController.prototype.addToQueue = function(nextTracks, deviceId) {
  if (!Array.isArray(nextTracks)) {
    return Promise.reject(new TypeError('Invalid nextTracks array.'));
  }
  return Promise.all([
    this._prepareTracks(nextTracks, {queued: true}),
    this._playerClient.getContextPlayerState()
  ]).spread(function(next, playerState) {
    if (!playerState) {
      return Promise.reject(new Error('No context to queue.'));
    }
    var currentTracks = playerState.next_tracks.slice(0);
    for (var i = 0, l = currentTracks.length; i < l; i++) {
      var track = currentTracks[i];
      if (track && track.metadata && track.metadata.is_queued === 'true') {
        continue;
      }
      currentTracks.splice.apply(currentTracks, [i, 0].concat(next));
      break;
    }
    var payload = {
      next_tracks: currentTracks,
      prev_tracks: playerState.prev_tracks
    };
    return this._playerClient.setQueue(payload, deviceId);
  }.bind(this));
};

HarmonyController.prototype._prepareTracks = function(maybeTracks, options) {
  var tracks = [];
  var VALID_TRACK_TYPES = [URI.Type.TRACK, URI.Type.EPISODE];

  for (var i = 0, l = maybeTracks.length; i < l; i++) {
    var track = maybeTracks[i];
    if (!track) {
      return Promise.reject(new TypeError('Null value inside track array.'));
    }

    var uri;
    if (typeof track === 'string') {
      uri = URI.from(track);
      track = {
        uri: track
      };
    } else {
      uri = URI.from(track.uri);
    }

    if (VALID_TRACK_TYPES.indexOf(uri.type) === -1) {
      return Promise.reject(new TypeError('Invalid track uri: ' + track.uri));
    }

    if (!track.metadata) {
      track.metadata = {};
    }
    if (options && options.queued) {
      track.metadata.is_queued = 'true';
    }
    tracks.push(track);
  }
  return Promise.resolve(tracks);
};

HarmonyController.prototype.togglePlay = function(deviceId) {
  return this._playerClient.togglePlay(deviceId);
};

HarmonyController.prototype.transfer = function(deviceId, options) {
  return this._generatePlayOptions(options || {}, true)
    .then(function(preparedOptions) {
      return this._playerClient.transfer(deviceId, preparedOptions);
    }.bind(this));
};

HarmonyController.prototype.pause = function(deviceId) {
  return this._playerClient.pause(deviceId);
};

HarmonyController.prototype.resume = function(deviceId) {
  return this._playerClient.resume(deviceId);
};

HarmonyController.prototype.nextTrack = function(deviceId) {
  return this._playerClient.nextTrack(deviceId);
};

HarmonyController.prototype.previousTrack = function(deviceId) {
  return this._playerClient.previousTrack(deviceId);
};

HarmonyController.prototype.seek = function(position, deviceId) {
  return this._playerClient.seek(position, deviceId);
};

HarmonyController.prototype.setShuffle = function(shuffle, deviceId) {
  return this._playerClient.setShuffle(shuffle, deviceId);
};

HarmonyController.prototype.toggleShuffle = function(deviceId) {
  return this._playerClient.toggleShuffle(deviceId);
};

HarmonyController.prototype.setVolume = function(volume, deviceId) {
  return this._playerClient.setVolume(volume, deviceId);
};

HarmonyController.prototype.setRepeatMode = function(repeatMode, deviceId) {
  switch (repeatMode) {
    case RepeatMode.OFF:
      return Promise.all([
        this._playerClient.setRepeatingContext(false, deviceId),
        this._playerClient.setRepeatingTrack(false, deviceId)
      ]).then(function() {
        return true;
      });
    case RepeatMode.CONTEXT:
      return Promise.all([
        this._playerClient.setRepeatingContext(true, deviceId),
        this._playerClient.setRepeatingTrack(false, deviceId)
      ]).then(function() {
        return true;
      });
    case RepeatMode.TRACK:
      return Promise.all([
        this._playerClient.setRepeatingContext(false, deviceId),
        this._playerClient.setRepeatingTrack(true, deviceId)
      ]).then(function() {
        return true;
      });
    default:
      return Promise.reject(new TypeError('Unknown repeat mode.'));
  }
};

HarmonyController.prototype.cycleRepeatMode = function(deviceId) {
  return this.getCurrentState()
    .then(function(state) {
      if (!state) {
        return Promise.reject(
          new PlayerAPIClientError(
            Errors.CONNECTAPI_CLIENT_NO_STATE,
            'Nothing playing'
          )
        );
      }

      var nextRepeatMode = null;
      switch (state.repeat_mode) {
        case RepeatMode.OFF:
          nextRepeatMode = RepeatMode.CONTEXT;
          break;

        case RepeatMode.CONTEXT:
          nextRepeatMode = RepeatMode.TRACK;
          break;

        case RepeatMode.TRACK:
          nextRepeatMode = RepeatMode.OFF;
          break;

        default:
          nextRepeatMode = RepeatMode.OFF;
      }

      return this.setRepeatMode(nextRepeatMode, deviceId);
    }.bind(this));
};

HarmonyController.prototype.register = function() {
  return this._playerClient.register();
};

HarmonyController.prototype.suppressEvents = function() {
  this._suppressed = true;
};

HarmonyController.prototype.unsuppressEvents = function() {
  this._suppressed = false;
  if (this._lastDeviceInfoData) {
    this.emit(Event.CONTROLLER_DEVICE_INFO_CHANGED, this._lastDeviceInfoData);
  }
  if (this._state) {
    this.emit(Event.CONTROLLER_STATE_CHANGED, {
      state: this._state
    });
  }
};

module.exports = HarmonyController;
