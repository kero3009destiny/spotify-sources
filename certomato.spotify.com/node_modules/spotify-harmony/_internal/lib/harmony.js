'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');

var Event = require('../../_internal/types/event');
var PublicEvent = require('../../types/event');
var Errors = require('../../types/errors');
var ErrorSource = require('../../types/error_source');
var HarmonyError = require('./harmony_error');

var delegateAll = require('../helpers/delegate').delegateAll;
var areDeviceListsEqual = require('../helpers/device').areDeviceListsEqual;

var DEFAULT_SEEK_TIME = 15000;

function Harmony(options) {
  EventEmitter.call(this);
  this._client = options.client;
  this._streamer = options.streamer;
  this._controller = options.controller;
  this._hidden = !!options.hidden;
  this._onlyLocalState = options.onlyLocalState;
  this._preferController = this._onlyLocalState ?
    false :
    options.preferControllerState;
  this._claimInactivePlayerStates = options.claimInactivePlayerStates;
  this._disconnectBeforeUnload = options.disconnectBeforeUnload;
  this._enableControllerWithoutStreamer =
    options.enableControllerWithoutStreamer;
  this._hasFakeState = false;
  this._localPlayerEnabled = false;
  this._localPlayback = false;
  this._deferredStreamer = null;
  this._lastDeviceList = [];
  this._init();
}
inherit(Harmony, EventEmitter);

Harmony.create = function(options) {
  return new Harmony(options);
};

delegateAll(Harmony.prototype, {
  // Client
  connect: '_client',
  disconnect: '_client',
  getABBAClient: '_client',
  getClientDescriptor: '_client',
  getProductState: '_client',
  getPublicTransport: '_client',
  getUserInfo: '_client',
  getVersionDescriptor: '_client',
  logAppMetrics: '_client',
  request: '_client',
  setName: '_client',
  setNameTemplate: '_client',
  getContextPlayerState: '_controller',
  updateCurrentContext: '_controller'
});

Harmony.prototype._init = function() {
  this._createStreamerDeferred();

  // Client Events
  var client = this._client;
  client.on(Event.CLIENT_ERROR, this._onError.bind(this));
  this.proxyEmit(
    client,
    Event.CLIENT_AUTHENTICATED,
    PublicEvent.AUTHENTICATED
  );
  this.proxyEmit(
    client,
    Event.CLIENT_AUTHENTICATION_ERROR,
    PublicEvent.AUTHENTICATION_ERROR
  );
  this.proxyEmit(
    client,
    Event.CLIENT_BEFORE_DISCONNECT,
    PublicEvent.BEFORE_DISCONNECT
  );
  this.proxyEmit(
    client,
    Event.CLIENT_CONNECTED,
    PublicEvent.CONNECTED
  );
  this.proxyEmit(
    client,
    Event.CLIENT_CONNECTION_ERROR,
    PublicEvent.CONNECTION_ERROR
  );
  this.proxyEmit(
    client,
    Event.CLIENT_DEVICE_DESCRIPTOR_CHANGED,
    PublicEvent.DEVICE_DESCRIPTOR_CHANGED
  );
  this.proxyEmit(
    client,
    Event.CLIENT_PRODUCT_STATE_CHANGED,
    PublicEvent.PRODUCT_STATE_CHANGED
  );
  this.proxyEmit(
    client,
    Event.CLIENT_RECONNECTED,
    PublicEvent.RECONNECTED
  );
  this.proxyEmit(
    client,
    Event.CLIENT_RECONNECTING,
    PublicEvent.RECONNECTING
  );
  this.proxyEmit(
    client,
    Event.CLIENT_UNRECOVERABLE_FAILURE,
    PublicEvent.UNRECOVERABLE_FAILURE
  );
  this.proxyEmit(
    client,
    Event.CLIENT_LOGGED_OUT,
    PublicEvent.LOGGED_OUT
  );

  // Controller Events
  var controller = this._controller;
  controller.on(
    Event.CONTROLLER_DEVICE_INFO_CHANGED,
    this._onDeviceStateChanged.bind(this)
  );
  controller.on(
    Event.CONTROLLER_DEVICES_CHANGED,
    this._onDevicesChanged.bind(this)
  );
  controller.on(
    Event.CONTROLLER_STATE_CHANGED,
    this._onPlayerStateChanged.bind(this)
  );
  controller.on(
    Event.CONTROLLER_PROGRESS,
    this._onControllerProgress.bind(this)
  );

  this.proxyEmit(
    controller,
    Event.CONTROLLER_MAX_SUBSCRIPTIONS_REACHED,
    PublicEvent.MAX_SUBSCRIPTIONS_REACHED
  );

  this._proxyEmitNoProps(
    controller,
    Event.CONTROLLER_REGISTERED,
    PublicEvent.REMOTE_OBSERVER_ENABLED
  );
  this._proxyEmitNoProps(
    controller,
    Event.CONTROLLER_DEREGISTERED,
    PublicEvent.REMOTE_OBSERVER_DISABLED
  );

  var streamer = this._streamer;
  if (!streamer) {
    // Streamer is disabled.
    this._disableLocalTarget();
    this.on(PublicEvent.AUTHENTICATED, function() {
      this.emit(PublicEvent.LOCAL_PLAYER_DISABLED);
    }.bind(this));
  } else {
    streamer.on(
      Event.STREAMER_BEFORE_VOLUME_CHANGE,
      this._onStreamerBeforeVolumeChange.bind(this)
    );
    streamer.on(
      Event.STREAMER_DEREGISTERED,
      this._onStreamerDeregistered.bind(this)
    );
    streamer.on(
      Event.STREAMER_REGISTERED,
      this._onStreamerRegistered.bind(this)
    );
    streamer.on(
      Event.STREAMER_REGISTRATION_ABORTED,
      this._onStreamerRegistrationAborted.bind(this)
    );
    streamer.on(
      Event.STREAMER_STATE_CHANGED,
      this._onStreamerStateChanged.bind(this)
    );

    this.proxyEmit(
      streamer,
      Event.STREAMER_AUTOPLAY_FAILED,
      PublicEvent.AUTOPLAY_FAILED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_BUFFERING_END,
      PublicEvent.BUFFERING_END
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_BUFFERING_START,
      PublicEvent.BUFFERING_START
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_DURATION_CHANGED,
      PublicEvent.DURATION_CHANGED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_MAX_LIST_ERRORS_REACHED,
      PublicEvent.MAX_LIST_ERRORS_REACHED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_MAX_SUBSCRIPTIONS_REACHED,
      PublicEvent.MAX_SUBSCRIPTIONS_REACHED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_PLAYBACK_CAPPED,
      PublicEvent.PLAYBACK_CAPPED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_PLAYER_INITIALIZATION_DONE,
      PublicEvent.PLAYER_INITIALIZATION_DONE
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_PLAYER_INITIALIZATION_FAILED,
      PublicEvent.PLAYER_INITIALIZATION_FAILED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_PROGRESS,
      PublicEvent.PROGRESS
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_REGISTRATION_ERROR,
      PublicEvent.SERVICE_REGISTRATION_ERROR
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_TRACK_ENDED,
      PublicEvent.TRACK_ENDED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_VIDEO_ELEMENT_APPENDED,
      PublicEvent.VIDEO_ELEMENT_APPENDED
    );
    this.proxyEmit(
      streamer,
      Event.STREAMER_VIDEO_ELEMENT_REMOVED,
      PublicEvent.VIDEO_ELEMENT_REMOVED
    );

    this._proxyEmitNoProps(
      streamer,
      Event.STREAMER_CONTEXT_ENDED,
      PublicEvent.LOCAL_CONTEXT_ENDED
    );
    this._proxyEmitNoProps(
      streamer,
      Event.STREAMER_LOGGED_OUT,
      PublicEvent.LOCAL_PLAYER_LOGGED_OUT
    );
  }

  if (this._disconnectBeforeUnload && global.addEventListener) {
    global.addEventListener(Event.WINDOW_BEFORE_UNLOAD, function() {
      this.disconnect();
    }.bind(this));
  }
};

Harmony.prototype._createStreamerDeferred = function() {
  this._deferredStreamer = Promise.defer();
  this._deferredStreamer.promise.catch(function() {
    // Noop
  });
};

Harmony.prototype._isTargetIdLocal = function(deviceId) {
  if (!deviceId) {
    return Promise.resolve(!!this._localPlayback);
  }
  if (deviceId === '@local') {
    return Promise.resolve(true);
  }
  return this._client.getDeviceDescriptor().then(function(descriptor) {
    return deviceId === descriptor.getId();
  });
};

Harmony.prototype._proxyEmitNoProps = function(emitter, eventA, eventB) {
  emitter.on(eventA, this.emit.bind(this, eventB, null));
};

Harmony.prototype._onStreamerBeforeVolumeChange = function(e) {
  var ev = this.emitSync(PublicEvent.BEFORE_VOLUME_CHANGE, {volume: e.volume});
  if (ev.defaultPrevented) {
    e.preventDefault();
  }
};

Harmony.prototype._onStreamerRegistered = function(e) {
  this._deferredStreamer.resolve(e);
  this._createStreamerDeferred();
  this._deferredStreamer.resolve(e);
  this._localPlayerEnabled = true;
  this._controller.register();
  this.emit(PublicEvent.LOCAL_PLAYER_ENABLED);
};

Harmony.prototype._onStreamerDeregistered = function() {
  this._disableLocalTarget();
  this.emit(PublicEvent.LOCAL_PLAYER_DISABLED);
};

Harmony.prototype._onStreamerRegistrationAborted = function() {
  this._disableLocalTarget();
  if (this._enableControllerWithoutStreamer) {
    this._controller.register();
  }
  this.emit(PublicEvent.LOCAL_PLAYER_DISABLED);
};

Harmony.prototype._disableLocalTarget = function() {
  this._localPlayerEnabled = false;
  var error = new HarmonyError(
    Errors.HARMONY_LOCAL_PLAYER_DISABLED,
    'Cannot perform command; local player is disabled.'
  );
  this._deferredStreamer.reject(error);
  this._createStreamerDeferred();
  this._deferredStreamer.reject(error);
};

Harmony.prototype._onStreamerConnect = function() {
  return this._deferredStreamer.promise;
};

Harmony.prototype._onDeviceStateChanged = function(e) {
  var hadLocalPlayback = !!this._localPlayback;

  var generateLocalDeviceChange = function(overrideActive) {
    this._generateLocalDeviceInfo(overrideActive)
      .then(function(localDeviceInfo) {
        this.emit(PublicEvent.LAST_ACTIVE_DEVICE_INFO_CHANGED, {
          deviceInfo: localDeviceInfo
        });
      }.bind(this));
  }.bind(this);

  if (
    this._localPlayerEnabled &&
    e.hasOrphanedState &&
    this._claimInactivePlayerStates
  ) {
    this._hasFakeState = true;
    generateLocalDeviceChange(true);
    return;
  }

  this._hasFakeState = false;
  this._localPlayback = e.deviceInfo && e.deviceInfo.local;

  if (this._localPlayback) {
    // Ensure that volume is always in-sync
    this._streamer.getVolume().then(function(volume) {
      e.deviceInfo.volume = volume;
      this.emit(PublicEvent.LAST_ACTIVE_DEVICE_INFO_CHANGED, e);
    }.bind(this)).catch(function() {
      // No-op
    });
  } else if (this._onlyLocalState) {
    // Only propagate the change if it somehow affects the local device
    // (i.e.: it holds, obtained or lost playback) and instead of emiting the
    // state of the device whose info has changed, emit the info of the
    // local device
    if (this._localPlayback || hadLocalPlayback) {
      generateLocalDeviceChange();
    }
  } else {
    this.emit(PublicEvent.LAST_ACTIVE_DEVICE_INFO_CHANGED, e);
  }
};

Harmony.prototype._onDevicesChanged = function(e) {
  var previousList = this._lastDeviceList;
  this._parseDeviceList(e).then(function(devices) {
    var hasListeners = this._listenerMap &&
      this._listenerMap[PublicEvent.DEVICES_CHANGED] &&
      this._listenerMap[PublicEvent.DEVICES_CHANGED].length;
    if (!hasListeners || areDeviceListsEqual(previousList, devices)) {
      return;
    }
    this.emit(PublicEvent.DEVICES_CHANGED, {
      devices: devices
    });
  }.bind(this));
};

Harmony.prototype._onError = function(event) {
  var error = event.error;
  if (
    event.source === ErrorSource.PLAYBACK &&
    error &&
    error.unrecoverable
  ) {
    this._disableLocalTarget();
    this._streamer.deregister();
  }
  this.emit(PublicEvent.ERROR, event);
};

Harmony.prototype._onPlayerStateChanged = function(e) {
  if (this._onlyLocalState) {
    return;
  }
  if (this._preferController || !this._localPlayback) {
    var state;
    if (this._localPlayerEnabled && this._claimInactivePlayerStates) {
      state = e.state;
    } else {
      state = e.orphaned ? null : e.state;
    }
    this.emit(PublicEvent.STATE_CHANGED, {
      state: state
    });
  }
};

Harmony.prototype._onControllerProgress = function(e) {
  // Only emit progress if the playback is not local.
  if (this._onlyLocalState) {
    return;
  }
  if (!this._localPlayback) {
    this.emit(PublicEvent.PROGRESS, e);
  }
};

Harmony.prototype._onStreamerStateChanged = function(e) {
  if (this._preferController) {
    return;
  }
  if (this._onlyLocalState) {
    this._triggerLocalStateChanges(e);
  } else if (this._hidden) {
    this._handleHidden(e);
  } else if (this._localPlayback) {
    this.emit(PublicEvent.STATE_CHANGED, e);
  }
};

Harmony.prototype._handleHidden = function(e) {
  if (e.state) {
    this._controller.suppressEvents();
    this._triggerLocalStateChanges(e);
  } else {
    this._controller.unsuppressEvents();
  }
};

Harmony.prototype._parseDeviceList = function(deviceList) {
  var devices = deviceList.devices.slice(0);
  if (!devices.length || !deviceList.localDevice) {
    devices.push(this._generateLocalDeviceInfo(this._hasFakeState));
  } else if (this._hasFakeState && deviceList.localDevice) {
    deviceList.localDevice.is_active = true;
  }
  return Promise.all(devices)
    .then(function(list) {
      this._lastDeviceList = list;
      return list;
    }.bind(this));
};

Harmony.prototype._triggerLocalStateChanges = function(e) {
  this._generateLocalDeviceInfo().then(function(deviceInfo) {
    this._onDeviceStateChanged({deviceInfo: deviceInfo});
  }.bind(this));
  this.emit(PublicEvent.STATE_CHANGED, e);
};

Harmony.prototype.forceDisconnect = function() {
  this._client.forceDisconnect();
  if (this._streamer) {
    this._streamer.pause().catch(function() {
      // No op
    });
  }
  return true;
};

Harmony.prototype.getLastActiveDevice = function() {
  if (this._onlyLocalState || this._hasFakeState) {
    return this._generateLocalDeviceInfo(this._hasFakeState);
  }

  return this._controller.getActiveDevice().then(function(deviceInfo) {
    if (deviceInfo && deviceInfo.local && this._streamer) {
      deviceInfo.hidden = this._hidden;
      return this._streamer.getVolume().then(function(volume) {
        deviceInfo.volume = volume;
        return deviceInfo;
      });
    }

    return deviceInfo;
  }.bind(this));
};

Harmony.prototype.getCurrentState = function() {
  if (
    !this._onlyLocalState &&
    (this._preferController || !this._localPlayback)
  ) {
    var noOrphans = !this._localPlayerEnabled ||
      !this._claimInactivePlayerStates;
    return this._controller.getCurrentState(noOrphans)
      .then(function(state) {
        // This is a special race where the current device was the last playing
        // device known by the Connect API. Since we do not know whether the
        // last Connect API device is the same local device until we query it,
        // the check for `!this._localPlayback` above will always succeed.
        //
        // This leads to a special race condition where the initial call to
        // `getCurrentState` will contain partial metadata from the connect API
        // but any call immediately afterwards will return null (WSDK-105).
        //
        // To fix this, recheck after we have the data redo the request in case.
        if (!this._preferController && this._localPlayback) {
          return this.getCurrentState();
        }
        return state;
      }.bind(this));
  }

  return this._onStreamerConnect().then(
    this._streamer.getCurrentState.bind(this._streamer)
  );
};

Harmony.prototype.togglePlay = function(deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.togglePlay();
    }.bind(this),
    this._controller.togglePlay.bind(this._controller, deviceId)
  );
};

Harmony.prototype.pause = function(deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.pause();
    }.bind(this),
    this._controller.pause.bind(this._controller, deviceId)
  );
};

Harmony.prototype.resume = function(deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.resume();
    }.bind(this),
    this._controller.resume.bind(this._controller, deviceId)
  );
};

/**
 * Plays the context URI (if the current context can be changed).
 *
 * @param {string} uri The context uri
 * @param {?string=} deviceId
 * @param {?Object=} options
 *
 * @return {Promise}
 */
Harmony.prototype.playURI = function(uri, deviceId, options) {
  return this._canStartNewContext(deviceId).then(
    function() {
      return this._controller.playURI(uri, deviceId, options);
    }.bind(this)
  );
};

/**
 * Plays the tracklist with the uris in the passed array (if the current
 * context can be changed).
 *
 * @param {Array<string>} uris
 * @param {?string=} deviceId
 * @param {?Object=} options
 *
 * @return {Promise}
 */
Harmony.prototype.playTracks = function(uris, deviceId, options) {
  return this._canStartNewContext(deviceId).then(
    function() {
      return this._controller.playTracks(uris, deviceId, options);
    }.bind(this)
  );
};

/**
 * Checks whether harmony has any restriction to skip the current track and
 * start a new context
 *
 * @param {?string=} deviceId
 *
 * @return {Promise} A promise resolved in case it can start a new context,
 *                   or rejected in case it can't
 */
Harmony.prototype._canStartNewContext = function(deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.getCurrentState()
        .then(function(state) {
          if (
            state &&
            state.restrictions &&
            state.restrictions.disallow_skipping_next_reasons
          ) {
            var reasons = state.restrictions.disallow_skipping_next_reasons;
            return (reasons.indexOf('ad_disallow') === -1);
          }
          return true;
        });
    }.bind(this),
    function() {
      // If the playback is not local, the controlled player should manage the
      // restrictions.
      return true;
    },
    true // Bypass fake state
  ).then(function(canChangeTrack) {
    return canChangeTrack ?
      true :
      Promise.reject(
        new HarmonyError(
          Errors.HARMONY_OPERATION_FORBIDDEN,
          'Cannot switch to a new context.'
        )
      );
  });
};

Harmony.prototype.nextTrack = function(deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.nextTrack('fwdbtn');
    }.bind(this),
    this._controller.nextTrack.bind(this._controller, deviceId)
  );
};

/**
 * When trying to skip back, checks if it should really skip or just seek to
 * the beginning of the track.
 * The threshold for determining if it should skip or seek is the same as in
 * core: 3 seconds.
 *
 * @param {?string=} deviceId
 *
 * @return {Promise}
 */
Harmony.prototype.smartPreviousTrack = function(deviceId) {
  var SKIP_PREVIOUS_THRESHOLD = 3000;
  return this.getCurrentState().then(
    function(currentState) {
      if (!currentState) {
        return Promise.reject(
          new HarmonyError(
            Errors.HARMONY_NO_TRACKS_LOADED,
            'No current state.'
          )
        );
      }

      var disallows = currentState.disallows || {};
      if (
        disallows.seeking ||
        (
          currentState.position < SKIP_PREVIOUS_THRESHOLD &&
          currentState.track_window &&
          currentState.track_window.previous_tracks &&
          currentState.track_window.previous_tracks.length > 0
        )
      ) {
        return this.previousTrack(deviceId);
      }

      return this.seek(0, deviceId);
    }.bind(this)
  );
};

Harmony.prototype.previousTrack = function(deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.previousTrack('backbtn');
    }.bind(this),
    this._controller.previousTrack.bind(this._controller, deviceId)
  );
};

Harmony.prototype.seek = function(position, deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.seek(position);
    }.bind(this),
    this._controller.seek.bind(this._controller, position, deviceId)
  );
};

Harmony.prototype._movePosition = function(time, deviceId) {
  return this.getCurrentState().then(function(state) {
    if (!state || isNaN(state.position)) {
      return Promise.reject(
        new HarmonyError(
          Errors.HARMONY_OPERATION_FORBIDDEN,
          'Seeking not allowed with invalid track.'
        )
      );
    }
    var _time = time;
    var newPosition = Math.min(
      state.duration,
      Math.max(0, state.position + _time)
    );
    return this.seek(newPosition, deviceId);
  }.bind(this));
};

Harmony.prototype.seekForward = function(time, deviceId) {
  return this._movePosition(time || DEFAULT_SEEK_TIME, deviceId);
};

Harmony.prototype.seekBackward = function(time, deviceId) {
  return this._movePosition((time || DEFAULT_SEEK_TIME) * -1, deviceId);
};

Harmony.prototype.getVolume = function() {
  return this._streamer ? this._streamer.getVolume() : -1;
};

Harmony.prototype.getVideoProfiles = function() {
  return this._streamer.getVideoProfiles();
};

Harmony.prototype.setPreferredBitrate = function(value) {
  return this._streamer.setPreferredBitrate(value);
};

Harmony.prototype.setVolume = function(volume, deviceId) {
  return this._runOnDevice(
    deviceId,
    function() {
      return this._streamer.setVolume(volume);
    }.bind(this),
    this._controller.setVolume.bind(this._controller, volume)
  );
};

/**
 * Checks if the command should be executed locally or remotely and
 * call the proper action
 *
 * @param {string} deviceId
 * @param {Function} localPlaybackAction
 * @param {Function} remotePlaybackAction
 * @param {boolean} bypassFakeState
 *
 * @return {Promise}
 */
Harmony.prototype._runOnDevice = function(
  deviceId,
  localPlaybackAction,
  remotePlaybackAction,
  bypassFakeState
) {
  if (this._hasFakeState && !bypassFakeState) {
    // Claim the state and trigger the remote action instead of local action in
    // This ensures that the state can be negotiated in the backend in case of
    // possible conflicts.
    return this._claimStateAndRun(remotePlaybackAction);
  }
  return this._isTargetIdLocal(deviceId)
    .then(function(isLocal) {
      if (isLocal) {
        return this._onStreamerConnect().then(localPlaybackAction);
      }
      return remotePlaybackAction();
    }.bind(this));
};

/**
 * Transfers the playback locally and triggers an action.
 *
 * @param {Function} action The action to run.
 * @return {Promise} A promise that would be fulfilled by the results of the
 *     action.
 */
Harmony.prototype._claimStateAndRun = function(action) {
  return this._onStreamerConnect()
    .then(function() {
      this._hasFakeState = false;
      return Promise.all([
        this._controller.transfer('@local', {paused: true}),
        // FIXME: In the future, this should be handled in a better way. Right
        // now we're waiting for the local track to load, but this will trigger
        // if any local track is loaded. The assumption right now is that there
        // would be no state in the streamer at this point, so this kinda works.
        new Promise(function(resolve) {
          this._streamer.once(Event.STREAMER_TRACK_LOADED, resolve);
        }.bind(this))
      ]);
    }.bind(this))
    .then(function() {
      return action();
    });
};

/**
 * Creates a DeviceInfo object for the local device.
 *
 * @param {boolean} overrideActive If set to true, it'll set the device as
 *     active.
 * @return {Promise.<module:spotify-harmony/types.DeviceInfo>} The DeviceInfo
 *    for the local device.
 * @protected
 */
Harmony.prototype._generateLocalDeviceInfo = function(overrideActive) {
  var client = this._client;
  var streamer = this._streamer;

  var currentState = null;
  var volume = -1;
  if (this._localPlayerEnabled) {
    currentState = overrideActive ? true : streamer.getCurrentState();
    volume = streamer.getVolume();
  }

  return Promise.all([
    client.getClientDescriptor(),
    client.getSDKId(),
    currentState,
    volume,
    this._hidden
  ]).spread(function(descriptor, version, _currentState, _volume, hidden) {
    return {
      hidden: hidden,
      id: descriptor.id,
      is_active: !!_currentState,
      is_controllable: this._localPlayerEnabled,
      is_observable: !this._localPlayerEnabled ? false : !hidden,
      local: true,
      metadata: descriptor.metadata || {},
      name: descriptor.name,
      type: descriptor.type,
      version: version,
      volume: _volume
    };
  }.bind(this));
};

/**
 * Returns all of the Connect devices currently registered for the user.
 *
 * Note that this function will guarantee at least one device in the array,
 * which is the local device.
 *
 * @return {Promise.<Array.<module:spotify-harmony/types.DeviceInfo>>} A promise
 * that will be resolved with an array of DeviceInfo objects.
 */
Harmony.prototype.getDevices = function() {
  return this._controller.getDevices()
    .then(this._parseDeviceList.bind(this));
};

Harmony.prototype.setQueue = function(nextTracks, previousTracks, deviceId) {
  var operation = this._controller.setQueue.bind(
    this._controller,
    nextTracks,
    previousTracks,
    deviceId
  );
  return this._runOnDevice(deviceId, operation, operation);
};

Harmony.prototype.addToQueue = function(nextTracks, deviceId) {
  var operation = this._controller.addToQueue.bind(
    this._controller,
    nextTracks,
    deviceId
  );
  return this._runOnDevice(deviceId, operation, operation);
};

Harmony.prototype.setShuffle = function(shuffle, deviceId) {
  var operation = this._controller.setShuffle.bind(
    this._controller,
    shuffle,
    deviceId
  );
  return this._runOnDevice(deviceId, operation, operation);
};

Harmony.prototype.toggleShuffle = function(deviceId) {
  var operation = this._controller.toggleShuffle.bind(
    this._controller,
    deviceId
  );
  return this._runOnDevice(deviceId, operation, operation);
};

Harmony.prototype.setRepeatMode = function(repeatMode, deviceId) {
  var operation = this._controller.setRepeatMode.bind(
    this._controller,
    repeatMode,
    deviceId
  );
  return this._runOnDevice(deviceId, operation, operation);
};

Harmony.prototype.cycleRepeatMode = function(deviceId) {
  var operation = this._controller.cycleRepeatMode.bind(
    this._controller,
    deviceId
  );
  return this._runOnDevice(deviceId, operation, operation);
};

Harmony.prototype.transfer = function(deviceId, options) {
  var _deviceId = deviceId || '@local';
  var operation = this._controller.transfer.bind(
    this._controller,
    _deviceId,
    options
  );
  return this._runOnDevice(_deviceId, operation, operation);
};

module.exports = Harmony;
