'use strict';

var inherit = require('spotify-inheritance/inherit');
var Promise = require('spotify-promise-plus');
var EventEmitter = require('spotify-eventemitter');
var ABBAClient = require('spotify-abba-client');
var ProductStateObserver =
  require('spotify-transport/product_state_observer');
var logging = require('spotify-debug-tools/logging');

var DeviceType = require('../../types/device_type');
var DeviceDescriptor = require('./device_descriptor');
var Event = require('./../types/event');
var ErrorSource = require('../../types/error_source');
var TransportEvent = require('spotify-transport/types/event');
var Lifecycle = require('spotify-transport/helpers/lifecycle');
var Logger = require('spotify-transport/logger');
var DeviceId = require('../../utils/device_id');

var interpolateUA = require('../helpers/interpolate_ua');
var capitalize = require('../helpers/capitalize');

var Errors = require('../../types/errors');
var HarmonyError = require('./harmony_error');

var ManifestFormat = require('../types/manifest_format');

var version = require('../../version.json');

var debugLogger = logging.forTag('harmonyclient');

/**
 * Represents a client or device.
 *
 * @constructor
 * @extends module:spotify-eventemitter.EventEmitter
 * @param {module:spotify-harmony/types.HarmonyClientOptions} options The
 *     options for this current client.
 */
function HarmonyClient(options) {
  if (!options.transport) {
    throw new TypeError('Invalid transport instance.');
  }

  this._deviceDescriptor = Promise.resolve();

  this._transport = options.transport;

  this._ownerRef = options.ownerRef;

  this._allowLifecycleManagement = options.allowLifecycleManagement;

  this._abbaClient = null;

  /**
   * A promise that will eventually be resolved to the system information string
   * that will be passed to the AP connection.
   *
   * @type {string}
   * @protected
   */
  this._systemInfo = Promise.defer();

  /**
   * A promise that will eventually be resolved to the user specified version
   * of the client. Used for logging.
   *
   * @type {string}
   * @protected
   */
  this._clientVersion = Promise.defer();

  /**
   * The string SDK version.
   */
  this._sdkVersion = version;

  /**
   * A logger instance.
   */
  this._logger = null;

  // We rebind this so we can use it to forward events from the wrapped
  // subsystems to the users of the API.
  this.emitEvent = this.emitEvent.bind(this);
  this._init(options);
}
inherit(HarmonyClient, EventEmitter);

HarmonyClient.create = function(options) {
  return new HarmonyClient(options);
};

HarmonyClient.of = function(item) {
  return item._client;
};

HarmonyClient.prototype._parseDeviceInfo = function(options, deviceInfo) {
  // Certain capabilities are required by the system in order to work properly.
  var deviceCapabilities = deviceInfo.capabilities || {};
  var capabilities = {
    change_volume: 'change_volume' in deviceCapabilities ?
      deviceCapabilities.change_volume :
      true,
    volume_steps: (
      deviceCapabilities.volume_steps >= 0 &&
      deviceCapabilities.volume_steps < 65535
    )
      ? deviceCapabilities.volume_steps
      : undefined, // Undefined, not sent; defaults to 62
    audio_podcasts: 'audio_podcasts' in deviceCapabilities ?
      deviceCapabilities.audio_podcasts :
      true,
    endsong_snooping: deviceCapabilities.endsong_snooping,
    enable_play_token: true,
    play_token_lost_behavior: options.playTokenLostBehavior || 'pause',
    disable_connect: !!options.hidden,
    video_playback: deviceCapabilities.video_playback,

    // We only define the ads manifest formats here. All other manifest formats
    // are defined by Streamer (see streamer.js)
    manifest_formats: [ManifestFormat.FILE_URLS_MP3]
  };

  if (deviceInfo.nameTemplate) {
    deviceInfo.name = interpolateUA(deviceInfo.nameTemplate);
  }

  var descriptor = DeviceDescriptor.create({
    id: DeviceId.get(deviceInfo.id, deviceInfo.randomizeId),
    model: deviceInfo.model ||
      interpolateUA('harmony-{{name}}.{{version}}-{{platform}}').toLowerCase(),
    name: deviceInfo.name ||
      capitalize(interpolateUA('Spotify ({{name}}/{{platform}})')),
    type: deviceInfo.type || DeviceType.COMPUTER,
    brand: deviceInfo.brand || 'SpotifyHarmonyGeneric',
    platform_identifier: deviceInfo.platform_identifier,
    platform_version: deviceInfo.platform_version,
    metadata: deviceInfo.metadata || {},
    capabilities: capabilities
  });

  this._systemInfo.resolve(descriptor.getPlatformIdentifier());
  this._clientVersion.resolve(descriptor.getPlatformVersion());

  return descriptor;
};

HarmonyClient.prototype._init = function(options) {
  this._initDeviceDescriptor(options);
  this._initTransport();
  this._initLogger();
};

HarmonyClient.prototype._initLogger = function() {
  this._logger = new Logger({
    transport: this._transport,
    sdkId: this.getSDKId(),
    platform: this._systemInfo.promise,
    clientVersion: this._clientVersion.promise
  });
};

HarmonyClient.prototype._initDeviceDescriptor = function(options) {
  this._deviceDescriptor = Promise.resolve(options.descriptor || {})
    .then(this._parseDeviceInfo.bind(this, options))
    .then(function(descriptor) {
      // Attach event forwarder.
      this.proxyEmit(
        descriptor,
        Event.DEVICE_DESCRIPTOR_CHANGED,
        Event.CLIENT_DEVICE_DESCRIPTOR_CHANGED
      );
      return descriptor;
    }.bind(this))
    .catch(function(e) {
      this._onError(ErrorSource.HARMONY, {error: e});
    }.bind(this));
};

HarmonyClient.prototype._initTransport = function() {
  var transport = this._transport;

  transport.on(
    TransportEvent.TRANSPORT_CONNECTED,
    this._onConnected.bind(this)
  );
  transport.on(
    TransportEvent.TRANSPORT_CONNECTION_FAILED,
    this._onConnectionError.bind(this)
  );
  transport.on(
    TransportEvent.TRANSPORT_AUTHENTICATION_FAILED,
    this._onAuthenticationError.bind(this)
  );

  this.proxyEmit(
    transport,
    TransportEvent.TRANSPORT_AUTHENTICATED,
    Event.CLIENT_AUTHENTICATED
  );
  this.proxyEmit(
    transport,
    TransportEvent.TRANSPORT_RECONNECTING,
    Event.CLIENT_RECONNECTING
  );
  this.proxyEmit(
    transport,
    TransportEvent.TRANSPORT_RECONNECTED,
    Event.CLIENT_RECONNECTED
  );
  this.proxyEmit(
    transport,
    TransportEvent.TRANSPORT_LOGGED_OUT,
    Event.CLIENT_LOGGED_OUT
  );
  this.proxyEmitSync(
    transport,
    TransportEvent.TRANSPORT_BEFORE_OFFLINE_DISCONNECT,
    Event.CLIENT_BEFORE_OFFLINE_DISCONNECT
  );
  this.proxyEmitSync(
    transport,
    TransportEvent.TRANSPORT_BEFORE_ONLINE_DISCONNECT,
    Event.CLIENT_BEFORE_DISCONNECT
  );

  transport.on(
    TransportEvent.TRANSPORT_SHORT_SESSION_DISCONNECTED,
    this._onShortSessionDisconnect.bind(this)
  );

  this._transport = transport;

  this._abbaClient = ABBAClient.forSession(transport);

  var productStateObserver = ProductStateObserver.create({
    transport: transport
  });
  productStateObserver.on(
    Event.PRODUCT_STATE_OBSERVER_PRODUCT_STATE_CHANGED,
    this.emitEvent
  );
  this.on(Event.CLIENT_BEFORE_DISCONNECT, function(e) {
    if (e) {
      var promise = productStateObserver.deregister().catch(function() {
        // Ignore any errors from deregistering that might prevent other waiters
        // from disconnecting.
      });
      e.awaitPromise(promise);
    }
  });
  this._productStateObserver = productStateObserver;
};

HarmonyClient.prototype._onError = function(source, e) {
  this.emit(Event.CLIENT_ERROR, {
    source: source,
    name: e.name,
    error: e.error
  });
  if (e.error && !!e.error.unrecoverable) {
    this.emit(Event.CLIENT_UNRECOVERABLE_FAILURE, {
      source: source,
      name: e.name,
      error: e.error
    });
  }
};

HarmonyClient.prototype._onConnected = function() {
  this.emit(Event.CLIENT_CONNECTED);
  var transport = this._transport;
  if (
    transport.hasOwnerRef(this._ownerRef) ||
    this._allowLifecycleManagement
  ) {
    this._transport.authenticate().catch(function() {
      // Event already fired--do not continue.
    });
  }
};

HarmonyClient.prototype._onConnectionError = function(e) {
  var error = e && e.error ? e.error : e;
  this._onError(ErrorSource.TRANSPORT, {error: error});
  this.emit(Event.CLIENT_CONNECTION_ERROR, e);
};

HarmonyClient.prototype._onAuthenticationError = function(e) {
  var error = e && e.error ? e.error : e;
  this._onError(ErrorSource.TRANSPORT, {error: error});
  this.emit(Event.CLIENT_AUTHENTICATION_ERROR, error);
};

HarmonyClient.prototype._onShortSessionDisconnect = function(e) {
  this._logger.logClientEvent({
    source: 'transport',
    source_version: version.tagged,
    source_vendor: 'spotify',
    event: e.type,
    event_version: '1.0.0',
    json_data: {
      disconnectCount: e.disconnectCount,
      sessionLength: e.sessionLength
    }
  }).catch(function(err) {
    debugLogger.warn(e.type + ' Logging Error', err);
  });
};

HarmonyClient.prototype.getVersionDescriptor = function() {
  return this._sdkVersion;
};

HarmonyClient.prototype.getSDKId = function() {
  return 'harmony:' + this._sdkVersion.tagged;
};

HarmonyClient.prototype.getUntaggedSDKId = function() {
  return 'harmony:' + this._sdkVersion.version;
};

HarmonyClient.prototype.getLogger = function() {
  return this._logger;
};

HarmonyClient.prototype.logAppMetrics = function(meters, timers) {
  return this._logger.logMetrics(meters, timers);
};

HarmonyClient.prototype.request = function(url, options) {
  return this._transport.request(url, options);
};

HarmonyClient.prototype.getPublicTransport = function() {
  return this._transport.toPublic();
};

HarmonyClient.prototype.getABBAClient = function() {
  return this._abbaClient;
};

HarmonyClient.prototype.getClientDescriptor = function() {
  return this._deviceDescriptor.then(function(descriptor) {
    return descriptor.toJSON();
  });
};

HarmonyClient.prototype.getDeviceDescriptor = function() {
  return this._deviceDescriptor;
};

HarmonyClient.prototype.getUserInfo = function() {
  return this._transport.request(
    'https://@webapi/v1/me',
    {responseType: 'json'}
  ).then(function(response) {
    var body = response.body;
    if (response.status !== 200) {
      var error = new HarmonyError(
        Errors.USER_INFO_REQUEST_FAILED_WITH_STATUS,
        'User info request failed with status ' + response.status
      );
      error.status = response.status;
      return Promise.reject(error);
    } else if (!body) {
      return Promise.reject(
        new HarmonyError(
          Errors.USER_INFO_REQUEST_EMPTY_RESPONSE,
          'Unexpected empty response.'
        )
      );
    }
    return {
      display_name: body.display_name,
      followers: body.followers,
      id: body.id,
      images: body.images,
      uri: body.uri
    };
  });
};

HarmonyClient.prototype.getProductState = function() {
  return this._productStateObserver.getCurrentState();
};

/**
 * Connect to the backend services.
 *
 * @return {Promise}
 */
HarmonyClient.prototype.connect = function() {
  if (this._allowLifecycleManagement) {
    return this._transport.connect();
  }
  return Lifecycle.connectIfOwned(this._transport, this._ownerRef);
};

/**
 * Disconnect from the backend services.
 *
 * @return {Promise}
 */
HarmonyClient.prototype.disconnect = function() {
  if (this._allowLifecycleManagement) {
    return this._transport.disconnect();
  }
  return Lifecycle.disconnectIfOwned(this._transport, this._ownerRef);
};

/**
 * Disconnects the client immediately, without waiting for the services to clean
 * up or deregister.
 *
 * Used for situations where the device might not have time for a full
 * disconnect.
 *
 * @return {Promise}
 */
HarmonyClient.prototype.forceDisconnect = function() {
  if (this._allowLifecycleManagement) {
    return this._transport.forceDisconnect();
  }
  return Lifecycle.forceDisconnectIfOwned(this._transport, this._ownerRef);
};

HarmonyClient.prototype.setName = function(name) {
  return this._deviceDescriptor.then(function(descriptor) {
    return descriptor.setName(name);
  });
};

HarmonyClient.prototype.setNameTemplate = function(name) {
  return this.setName(interpolateUA(name));
};

HarmonyClient.prototype.setCapability = function(capability, value) {
  return this._deviceDescriptor.then(function(descriptor) {
    return descriptor.setCapability(capability, value);
  });
};

HarmonyClient.prototype.notifyError = function(source, name, error) {
  this._onError(source, {name: name, error: error});
};

module.exports = HarmonyClient;
