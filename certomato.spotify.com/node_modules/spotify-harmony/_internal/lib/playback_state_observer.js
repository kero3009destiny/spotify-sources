'use strict';

var debugLogger = require('spotify-debug-tools/logging')
  .forTag('stream.PlaybackStateObserver');
var Promise = require('spotify-promise-plus');
var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var URI = require('spotify-liburi');

var Event = require('../../_internal/types/event');
var RepeatMode = require('../../types/repeat_mode');

var EXTRACT_RESTRICTION_NAME = /^disallow_([^]+)_reasons$/;

/**
 * The Stream Track Window Observer class.
 *
 * Can be used to get details about the current and upcoming tracks, etc.
 *
 * @exports module:spotify-stream/lib/track_window_observer
 * @class
 * @param {Object} tpApiClient An instance of spotify-tpapi-client
 * @param {Object} [options] Optional options
 * @param {number} [options.numPrevious=2] The number of previous tracks
 *     to observe
 * @param {number} [options.numNext=2] The number of next tracks to
 *     observe
 */
function PlaybackStateObserver(tpApiClient, options) {
  EventEmitter.call(this);
  var opts = options || {};
  this._tpApiClient = tpApiClient;
  this._numPreviousTracks = opts.numPrevious || 2;
  this._numNextTracks = opts.numNextTracks || 2;
  this._state = null;
  this._init();
}
inherit(PlaybackStateObserver, EventEmitter);

PlaybackStateObserver.create = function(tpApiClient, options) {
  return new PlaybackStateObserver(tpApiClient, options);
};


PlaybackStateObserver.prototype._init = function() {
  this._tpApiClient.on(
    Event.TP_API_STATE_CHANGED,
    this._onStateChanged.bind(this)
  );
  this._tpApiClient.on(
    Event.TP_API_STATE_CLEARED,
    this._onStateCleared.bind(this)
  );
};

PlaybackStateObserver.prototype._parseRestrictions = function(
  restrictions,
  paused
) {
  var copy = {};
  for (var key in restrictions) {
    if (
      restrictions.hasOwnProperty(key) &&
      key !== 'disallow_resuming_reasons' &&
      key !== 'disallow_pausing_reasons'
    ) {
      copy[key] = restrictions[key];
    }
  }

  // Since there is no "paused" state, we can get into situations where the
  // backend provided restrictions do not match with the local paused/resume
  // state. We therefore set these locally instead.
  if (paused) {
    copy.disallow_pausing_reasons = ['already_paused'];
  } else {
    copy.disallow_resuming_reasons = ['not_paused'];
  }
  return copy;
};

PlaybackStateObserver.prototype._parseDisallows = function(restrictions) {
  var res = {};
  for (var key in restrictions) {
    if (restrictions.hasOwnProperty(key)) {
      var disallow = !!(restrictions[key] && restrictions[key].length);
      res[key.replace(EXTRACT_RESTRICTION_NAME, '$1')] = disallow;
    }
  }
  return res;
};


PlaybackStateObserver.prototype._onStateChanged = function(e) {
  var position = e.position;
  var knownDuration = e.duration;
  // Timestamp is useful to update/offset position later
  var timestamp = Date.now();
  var paused = e.paused;
  var stateMachine = e.stateMachine;
  var currentIndex = e.stateRef.state_index;
  var states = stateMachine.states;
  var currentState = states[currentIndex];
  var restrictions = this._parseRestrictions(
    currentState.restrictions || {},
    paused
  );
  var disallows = this._parseDisallows(restrictions);

  if (!currentState) {
    debugLogger.warn('_onStateChanged called with no current state', e);
    return;
  }
  var _this = this;
  var mapper = function(duration, state) {
    return _this._getTrackMetadata(stateMachine, state, duration);
  };
  // TODO: It's not necessary to update the track window on each state change.
  var trackWindow = {
    current_track: mapper(knownDuration, currentState),
    next_tracks: this._getNextStates(currentState, states)
      .map(mapper.bind(null, null)),
    previous_tracks: this._getPreviousStates(currentState, states)
      .map(mapper.bind(null, null))
  };

  // If we don't have a known duration, we should default to the metadata
  // duration.
  if (!knownDuration) {
    knownDuration = trackWindow.current_track ?
      trackWindow.current_track.duration_ms :
      0;
  }

  var repeatMode = this._getRepeatSetting(stateMachine);

  var state = {
    context: {
      uri: null,
      metadata: {}
    },
    bitrate: 0, // FIXME: Set to actual file bitrate from player.
    position: position,
    duration: knownDuration,
    paused: paused,
    shuffle: this._getShuffleSetting(stateMachine),
    repeat_mode: repeatMode,
    track_window: trackWindow,
    timestamp: timestamp,
    restrictions: restrictions,
    disallows: disallows
  };
  var stateTrack = stateMachine.tracks[currentState.track];
  if (stateTrack && stateTrack.metadata) {
    if (stateTrack.metadata.context_uri) {
      state.context.uri = stateTrack.metadata.context_uri;
    }
    if (stateTrack.metadata.context_description) {
      state.context.metadata.context_description =
        stateTrack.metadata.context_description;
    }
  }
  this._state = state;
  this.emit(Event.PLAYBACK_STATE_OBSERVER_STATE_CHANGED, {
    state: this._copyState()
  });
};

PlaybackStateObserver.prototype._onStateCleared = function() {
  this._state = null;
  this.emit(Event.PLAYBACK_STATE_OBSERVER_STATE_CHANGED, {state: null});
};


PlaybackStateObserver.prototype._getRepeatSetting = function(stateMachine) {
  var options = stateMachine.attributes.options;
  if (options.repeating_track) {
    return RepeatMode.TRACK;
  }
  if (options.repeating_context) {
    return RepeatMode.CONTEXT;
  }
  return RepeatMode.OFF;
};

PlaybackStateObserver.prototype._getShuffleSetting = function(stateMachine) {
  return stateMachine.attributes.options.shuffling_context;
};

PlaybackStateObserver.prototype._getNextStates = function(state, states) {
  var maxStates = this._numNextTracks;
  var list = [];
  var current = state;
  while (current) {
    if (!('show_next' in current.transitions) ||
        !current.transitions.show_next) {
      break;
    }
    var transitions = current.transitions;
    var nextState = states[transitions.show_next.state_index];
    list.push(nextState);
    current = nextState;
    if (list.length >= maxStates) {
      break;
    }
  }
  return list;
};

PlaybackStateObserver.prototype._getPreviousStates = function(state, states) {
  var maxStates = this._numPreviousTracks;
  var list = [];
  var current = state;
  while (current) {
    if (!('show_prev' in current.transitions) ||
        !current.transitions.show_prev) {
      break;
    }
    var transitions = current.transitions;
    var nextState = states[transitions.show_prev.state_index];
    list.unshift(nextState);
    current = nextState;
    if (list.length >= maxStates) {
      break;
    }
  }
  return list;
};

PlaybackStateObserver.prototype._getTrackMetadata = function(
  stateMachine,
  state,
  duration
) {
  var track = stateMachine.tracks[state.track];
  if (!track && track.metadata) {
    return null;
  }
  var metadata = track.metadata;
  // FIXME: Since we do not know the media formats right now, we only check
  // whether the item has the video manifest format.
  var isVideo = track.manifest && 'manifest_ids_video' in track.manifest;
  // Return a structure similar to what the Web API would return.
  var uri = URI.from(metadata.uri);
  var linkedFromUri = metadata.linked_from_uri ?
    URI.fromString(metadata.linked_from_uri) :
    null;
  return {
    id: uri ? URI.hexToId(uri.id) : null,
    uri: metadata.uri,
    type: uri ? uri.type : null,
    // TODO: this field is to be deprecated in favor of the `linked_from`
    // object below.
    linked_from_uri: metadata.linked_from_uri || null,
    linked_from: {
      uri: metadata.linked_from_uri || null,
      id: linkedFromUri ? URI.hexToId(linkedFromUri.id) : null
    },
    media_type: isVideo ? 'video' : 'audio',
    name: metadata.name,
    duration_ms: duration ? duration : metadata.duration,
    artists: metadata.authors,
    album: {
      uri: metadata.group_uri,
      name: metadata.group_name,
      images: metadata.images
    },
    is_playable: true
  };
};

/**
 * Get the current state of playback.
 *
 * @return {Promise.<module:spotify-stream/types.PlaybackState>} A promise that
 *     resolves the current player state.
 */
PlaybackStateObserver.prototype.getCurrentState = function() {
  if (this._state && !this._state.paused) {
    // Position hasn't been updated since last state_change
    // so update position and timestamp to reflect current status
    var now = Date.now();
    var offsetPosition = this._state.position + (now - this._state.timestamp);
    this._state.position = offsetPosition;
    this._state.timestamp = now;
  }
  return Promise.resolve(this._copyState());
};

PlaybackStateObserver.prototype._copyState = function() {
  return JSON.parse(JSON.stringify(this._state));
};

module.exports = PlaybackStateObserver;
