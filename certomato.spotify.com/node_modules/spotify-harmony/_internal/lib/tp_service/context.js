'use strict';

var Promise = require('spotify-promise-plus');
var resolveManifestFile = require('./resolve_manifest_file');
var TPServiceClientError = require('./client_error');
var Errors = require('../../../types/errors');

/**
 * A representation of the TP-API State Machine as a Context (i.e. SmartList).)
 *
 * @exports module:spotify-tpapi-client/lib/context
 * @constructor
 * @implements {module:spotify-contextplayer/types.ContextList}
 * @param {string} uri The URI of the list.
 * @param {Array.<string>} manifestFormats A list of supported formats.
 */
function TPServiceContext(uri, manifestFormats) {
  /**
   * The owner of the context.
   *
   * @type {string}
   * @protected
   */
  this._uri = uri;

  /**
   * A list of supported manifest formats by the client.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._manifestFormats = manifestFormats;

  /**
   * The id of the current device
   * @type {string}
   * @protected
   */
  this._deviceId = null;

  /**
   * The State Machine object.
   *
   * @type {module:spotify-tpapi-client/types.StateMachine}
   * @protected
   */
  this._stateMachine = null;

  /**
   * The current state from the State Machine
   *
   * @type {module:spotify-tpapi-client/types.State}
   * @protected
   */
  this._currentState = null;

  /**
   * The index of the current state in the state machine.
   *
   * @type {number}
   * @protected
   */
  this._currentStateIndex = null;

  /**
   * The state of whether the current track is paused or playing.
   *
   * Used for reporting.
   *
   * @type {boolean}
   * @protected
   */
  this._pausedState = false;

  /**
   * The initial position of the first track in the context.
   *
   * @type {number}
   * @protected
   */
  this._initialPlaybackPosition = null;
}

TPServiceContext.create = function(uri, manifestFormats) {
  return new TPServiceContext(uri, manifestFormats);
};

/**
 * Sets the internal paused flag of the context.
 *
 * This is used in order to make sure that the state reference generated by
 * the context contains the correct `paused` value.
 *
 * @param {boolean} state The paused state.
 * @protected
 */
TPServiceContext.prototype.setPaused = function(state) {
  this._pausedState = !!state;
};

/**
 * Get the pause state of the current track.
 *
 * @return {boolean} `true` if the current track is paused, otherwise `false`
 */
TPServiceContext.prototype.isPaused = function() {
  return this._currentStateIndex < 0 ?
    this._currentState.transitions.advance.paused :
    this._pausedState;
};

/**
 * Sets the position of the first track that will be loaded from the context.
 *
 * @param {number} value The position value in milliseconds.
 * @protected
 */
TPServiceContext.prototype.setInitialPosition = function(value) {
  this._initialPlaybackPosition = value;
};

/**
 * Sets the current State Machine
 *
 * @param {module:spotify-tpapi-client/types.StateMachine} stateMachine The new
 *     state machine.
 */
TPServiceContext.prototype.setStateMachine = function(stateMachine) {
  this._stateMachine = stateMachine;
};

/**
 * Sets the device id for logging purposes
 *
 * @param {string} deviceId
 */
TPServiceContext.prototype.setDeviceId = function(deviceId) {
  this._deviceId = deviceId;
};

/**
 * Sets the referred state as the starting state for the context.
 *
 * @param {module:spotify-tpapi-client/types.StateRef} stateRef The reference
 *     to the new state.
 */
TPServiceContext.prototype.startAtState = function(stateRef) {
  // We create a fake state so a call to next() will proceed to the actual
  // first state.
  var state = this._stateMachine.states[stateRef.state_index];
  if (!state) {
    throw new TPServiceClientError(
      Errors.TP_MISSING_INITIAL_STATE,
      'Invalid state reference.'
    );
  }
  var transitions = state.transitions;
  this._currentStateIndex = -1;
  this._currentState = {
    decoy: true, // Mark it as a decoy so we can get the paused state.
    paused: !!stateRef.paused,
    track: -1,
    state_id: null,
    transitions: {
      advance: stateRef,
      show_next: transitions.show_next,
      show_prev: transitions.show_prev,
      skip_next: stateRef,
      skip_prev: transitions.skip_prev
    }
  };
};

/**
 * Switches the current state.
 *
 * @param {module:spotify-tpapi-client/types.StateRef} internalStateRef The
 *     reference to the new state.
 */
TPServiceContext.prototype.setCurrentState = function(internalStateRef) {
  var index = internalStateRef.state_index;
  this._currentStateIndex = index;
  this._currentState = this._stateMachine.states[index];
};

/**
 * Returns the state machine.
 *
 * @return {module:spotify-tpapi-client/types.StateMachine}
 */
TPServiceContext.prototype.getStateMachine = function() {
  return this._stateMachine;
};

/**
 * Returns the current internal state reference
 *
 * @return {module:spotify-tpapi-client/types.InternalStateRef}
 */
TPServiceContext.prototype.getInternalStateRef = function() {
  var paused = this._pausedState;
  var stateIndex = this._currentStateIndex;
  if (stateIndex < 0) {
    // Dummy state, we want that next one.
    var ref = this._currentState.transitions.advance;
    stateIndex = ref.state_index;
    paused = ref.paused;
  }
  return {
    paused: paused,
    state_index: stateIndex
  };
};

/**
 * Returns the state reference to the current state.
 *
 * @return {Object} The state reference.
 */
TPServiceContext.prototype.getStateRef = function() {
  var stateMachine = this._stateMachine;
  if (!stateMachine) {
    return null;
  }

  var state;
  var paused;
  if (this._currentStateIndex < 0) {
    // Dummy state, we want that next one.
    var ref = this._currentState.transitions.advance;
    state = stateMachine.states[ref.state_index];
    paused = ref.paused;
  } else {
    state = stateMachine.states[this._currentStateIndex];
    paused = this._pausedState;
  }

  if (!state) {
    // If we don't have a state, just return a null state ref, which is valid.
    return null;
  }

  return {
    state_machine_id: stateMachine.state_machine_id,
    state_id: state.state_id,
    paused: paused
  };
};

/**
 * Returns metadata for the current track.
 *
 * @return {Object} The metadata for the current track.
 */
TPServiceContext.prototype.getCurrentTrack = function() {
  var stateMachine = this._stateMachine;
  if (!stateMachine) {
    return null;
  }
  var state;
  if (this._currentStateIndex < 0) {
    // Dummy state, we want that next one.
    var ref = this._currentState.transitions.advance;
    state = stateMachine.states[ref.state_index];
  } else {
    state = stateMachine.states[this._currentStateIndex];
  }
  return !state ? null : stateMachine.tracks[state.track];
};

/**
* @inheritDoc
*/
TPServiceContext.prototype.startAt = function() {
  // No op: we always set the context index.
  return Promise.resolve(true);
};

/**
 * @inheritDoc
 */
TPServiceContext.prototype.setShuffle = function() {
  // No unshuffling
  return Promise.resolve(true);
};

/**
 * @inheritDoc
 */
TPServiceContext.prototype.setRepeatMode = function() {
  return Promise.resolve(true);
};

/**
* @inheritDoc
*/
TPServiceContext.prototype.next = function(opParams) {
  var currentState = this._currentState;
  var transitions = currentState.transitions;
  var stateRef = null;
  switch (opParams.reason) {
    case 'nextbtn':
    case 'fwdbtn':
      if ('skip_next' in transitions) {
        stateRef = transitions.skip_next;
      }
      break;
    default:
      if ('advance' in transitions) {
        stateRef = transitions.advance;
      }
      break;
  }
  return this._transitionTo(stateRef, opParams, false);
};

/**
 * @inheritDoc
 */
TPServiceContext.prototype.peekNext = function(opParams) {
  var currentState = this._currentState;
  var transitions = currentState.transitions;
  var stateRef = null;
  switch (opParams.reason) {
    case 'nextbtn':
    case 'fwdbtn':
      if ('skip_next' in transitions) {
        stateRef = transitions.skip_next;
      }
      break;
    default:
      if ('advance' in transitions) {
        stateRef = transitions.advance;
      }
      break;
  }
  return this._transitionTo(stateRef, opParams, true);
};

/**
* @inheritDoc
*/
TPServiceContext.prototype.previous = function(opParams) {
  var currentState = this._currentState;
  var transitions = currentState.transitions;
  var stateRef = transitions.skip_prev;
  return this._transitionTo(stateRef, opParams, false);
};

/**
 * Returns whether the current track allows seeking.
 *
 * @return {boolean} True if we can seek for the current track, false otherwise.
 */
TPServiceContext.prototype.allowSeeking = function() {
  return this._currentState && !this._currentState.disallow_seeking;
};

/**
 * Moves the context to a new state, and returns the track information for the
 * new state.
 *
 * @param {Object} stateRef The state reference to the new state.
 * @param {Object} opParams Optional parameteres for the operation.
 * @param {boolean} dryRun If true, it will only return the track information
 *     for the new state without moving the actual reference in the context.
 * @return {Object} The track information for the new state.
 * @protected
 */
TPServiceContext.prototype._transitionTo = function(
  stateRef,
  opParams,
  dryRun
) {
  var reason = opParams.reason;
  var listConstants = opParams.listConstants;
  if (!stateRef || stateRef === null) {
    return Promise.resolve(listConstants.FORBIDDEN);
  }

  var stateMachine = this._stateMachine;
  var states = stateMachine.states;
  var nextState = states[stateRef.state_index];
  if (!nextState) {
    return Promise.resolve(listConstants.NULL_VALUE);
  }

  var item = stateMachine.tracks[nextState.track];
  if (!item || !item.metadata || !item.metadata.uri) {
    return Promise.resolve(listConstants.NULL_VALUE);
  }

  var prevState = this._currentState;
  var paused = prevState.decoy ? !!prevState.paused : stateRef.paused;

  if (!dryRun) {
    this._currentState = nextState;
    this._currentStateIndex = stateRef.state_index;
    this._pausedState = paused;
  }

  var position = 0;
  if (!dryRun && this._initialPlaybackPosition !== null) {
    // The initial position was set externally for the first track. We use that
    // value instead of any position value that might have been set in the state
    // machine.
    position = this._initialPlaybackPosition;
    this._initialPlaybackPosition = null;
  } else if ('initial_playback_position' in nextState) {
    position = nextState.initial_playback_position || 0;
  } else if ('seek_to' in nextState) {
    // Legacy field name. Remove once this is changed in the backend.
    position = nextState.seek_to || 0;
  }

  var file = resolveManifestFile(this._manifestFormats, item);
  if (!file) {
    return Promise.resolve(listConstants.NULL_VALUE);
  }
  var contextURI = this._uri;
  if (item.metadata && item.metadata.context_uri) {
    contextURI = item.metadata.context_uri;
  }

  // Calculate some endsong data.
  var logReason = reason;
  var playedThreshold = item.ms_played_until_update;

  var track = {
    uri: file.uri,
    playableURI: file.uri,

    fileId: file.fileId,
    resolvedURL: file.resolvedURL,

    playable: file.playable,
    isAd: file.isAd,
    format: file.format,
    mediaType: file.mediaType,
    noManifest: file.noManifest,

    options: {
      position: position,
      paused: paused,
      playedThreshold: playedThreshold
    },

    logData: {
      noLog: !!file.noLog,
      noTSV: !!file.noTSV,
      noStats: !!file.noStats,
      deviceId: this._deviceId,
      playbackId: nextState.state_id,
      reason: logReason,
      displayTrack: file.uri,
      playContext: contextURI,
      impressionURL: file.impressionURL,
      impressionURLs: file.impressionURLs,
      format: {
        codec: file.format,
        bitrate: file.bitrate
      },
      uriType: file.uriType
    },
    // Used to compare the track when sending state updates.
    stateId: nextState.state_id
  };
  return Promise.resolve(track);
};

module.exports = TPServiceContext;
