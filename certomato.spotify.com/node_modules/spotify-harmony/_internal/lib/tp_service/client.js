'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var Debouncer = require('spotify-debouncer');
var logging = require('spotify-debug-tools/logging');

var Errors = require('../../../types/errors');
var Event = require('../../../_internal/types/event');
var PlaybackEvent = require('spotify-playback/types/event');
var TPServiceClientError = require('./client_error');

var version = require('../../../version.json');

var debugLogger = logging.forTag('tpapiclient');

// Used by EndSong tests to be able to snoop EndSongs that were generated by
// the backend.
var endSongLogger = logging.forTag('tpapiclient.endsong');

// Used by testing of new EndSong solution. Will replace old logger when
// solution is rolled out.
var endSongsLogger = logging.forTag('tpapiclient.endsongs');

var DEFAULT_STREAM_INTERVAL = 500;
var DEALER_TRACK_PLAYBACK_FILTER = /^hm:\/\/track-playback\/v1/;
var DEALER_PLAY_LOST_TOKEN_FILTER = /^hm:\/\/play-token\/lost/;
var ENDPOINT = 'http://@webgate/track-playback';
var GAIA_VOLUME = 65535;

var AB_SEND_ALL_STATE_UPDATES = 'tps_send_all_state_updates';

/**
 * The checker function that will be used to determine whether the requests to
 * the Track Playback service should be retried in case of failure.
 *
 * @private
 * @param {module:spotify-transport/types/http_response} response The HTTP
 *     response.
 * @param {module:spotify-transport/types/status_family} StatusFamily the status
 *     family enum.
 * @return {boolean} True if the request should be retried, false otherwise.
 */
var maybeRetry = function(response, StatusFamily) {
  var family = response.getStatusFamily();
  return family === StatusFamily.SERVER_ERROR ||
    family === StatusFamily.CONNECTION_ERROR;
};

/**
 * A long backoff strategy for request retries.
 *
 * @const
 * @private
 */
var LONG_BACKOFF = {
  condition: maybeRetry,
  algo: 'exp',
  maxRetries: 8
};

/**
 * A short backoff strategy for request retries.
 *
 * @const
 * @private
 */
var SHORT_BACKOFF = {
  condition: maybeRetry,
  maxRetries: 2
};

function TPServiceClient(options) {
  EventEmitter.call(this);

  /**
   * An instance of PublicTransport.
   *
   * @type {module:spotify-transport/types/public_transport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * A transport logger.
   *
   * @type {module:spotify-transport/lib/logger}
   * @protected
   */
  this._logger = options.logger;

  /**
   * The HTTP endpoint for the Track Playback service.
   *
   * @type {string}
   * @protected
   */
  this._endpoint = options.endpoint || ENDPOINT;

  /**
   * An instance of a playback `ListPlayer` that will be used to play contexts.
   *
   * @type {module:spotify-playback/lib/list_player}
   * @protected
   */
  this._listPlayer = options.listPlayer;

  /**
   * A reference to the `ListPlayer` compatible class that will be used to
   * create context lists for playback.
   *
   * @type {Class}
   * @protected
   */
  this._ListClass = options.ListClass;

  /**
   * An instance of Spotify ABBA Client.
   *
   * @type {module:spotify-abba-client}
   * @protected
   */
  this._abbaClient = options.abbaClient;

  /**
   * The current volume value, represented as a Gaia Volume value.
   *
   * @type {number}
   * @protected
   */
  this._currentGaiaVolume = options.initialVolume * GAIA_VOLUME;

  /**
   * The version of the client.
   *
   * @type {string}
   * @protected
   */
  this._clientVersion = options.clientVersion;

  /**
   * The descriptor for this device.
   *
   * @type {Promise.<module:spotify-harmony/types/descriptor>}
   * @protected
   */
  this._descriptorPromise = Promise.resolve(options.descriptor);

  /**
   * The device id of the current device.
   *
   * @type {string}
   * @protected
   */
  this._deviceId = null;

  /**
   * The device info for registration.
   *
   * @type {Object}
   * @protected
   */
  this._deviceInfo = null;

  /**
   * The  supported file formats for this instance.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._manifestFormats = [];

  /**
   * The Dealer connection id for the current device.
   *
   * @type {string}
   * @protected
   */
  this._connectionId = null;

  /**
   * The sequence id that is used to identify individual messages.
   *
   * @type {number}
   * @protected
   */
  this._sequenceNumber = 0;

  /**
   * The currently playing context.
   *
   * @type {module:spotify-playback/types/context_list}
   * @protected
   */
  this._currentContext = null;

  /**
   * A flag that indicates whether in the process of loading a new track.
   *
   * @type {boolean}
   * @protected
   */
  this._loading = false;

  /**
   * The last payload that was sent as a State Update. Used to compare any
   * other payloads.
   *
   * @type {Object}
   * @protected
   */
  this._lastSentStateUpdatePayload = null;

  /**
   * The total amount of time that the client has been streaming, in
   * milliseconds.
   *
   * @type {number}
   * @protected
   */
  this._totalStreamTime = 0;

  /**
   * A flag that indicates whether we're currently sending a state conflict
   * request.
   *
   * @type {boolean}
   * @protected
   */
  this._isSendingConflict = false;

  /**
   * A list containing any rejected states that need to be sent to the state
   * conflict enpoint.
   *
   * Since the client will only have one state conflict request in-flight at any
   * time, any new conflicts will be put into this queue for sending after the
   * in-flight request has finished.
   *
   * @type {Array.<Object>}
   * @protected
   */
  this._queuedRejectedStates = [];

  /**
   * A flag that indicates whether the client currently has a state update in
   * flight.
   *
   * @type {boolean}
   * @protected
   */
  this._isSendingUpdate = false;

  /**
   * A list of string sources for state updates that need to be sent.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._queueSendUpdate = [];

  /**
   * Used to keep track of the previous track position when the position
   * changes.
   *
   * This is used so that we don't lose track of the previous position in
   * between state changes.
   *
   * @type {number}
   * @protected
   */
  this._previousTrackPosition = undefined;

  /**
   * Keeps track of the current position of the track.
   *
   * @type {number}
   * @protected
   */
  this._currentTrackPosition = undefined;

  /**
   * Keeps track of the current duration of the track.
   *
   * @type {number}
   * @protected
   */
  this._currentTrackDuration = undefined;

  /**
   * A flag indicating whether this instance has successfully registered to
   * the Track Playback service.
   *
   * @type {boolean}
   * @protected
   */
  this._registered = false;

  /**
   * A flag that indicates that we are currently in the process of
   * deregistering.
   *
   * @type {boolean}
   * @protected
   */
  this._isDeregistering = false;

  /**
   * A deferred that will be resolved once the tracking data for the current
   * track has been finalized.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._waitingForTrackingData = null;

  /**
   * The State ID of the last command processed.
   *
   * We use this value to compare the state_id of the list player events (where
   * it is exposed as the playback id). If they match, it means that we have
   * already sent an optimistic state update, and we ignore any state updates
   * that might be sent.
   *
   * @type {string}
   * @protected
   */
  this._lastProcessedStateId = null;

  /**
   * When set to true, the client will ensure that only one state update will
   * be sent at a time, and any queued state updates will be coalesced to only
   * send the last most updated state.
   *
   * When set to false, the client will send each state update regardless of the
   * status of the other ones.
   *
   * As of May 16th, this has been turned off for all users, by default.
   *
   * @type {boolean}
   * @protected
   */
  this._limitStateUpdates = false;

  /**
   * The timestamp of the last state update. Used to space progress-triggered
   * state updates.
   *
   * @type {number}
   * @protected
   */
  this._lastUpdateStateTime = 0;

  /**
   * A debouncer for the volume requests.
   *
   * @type {module:spotify-debouncer}
   * @protected
   */
  this._volumeDebouncer = new Debouncer(this._sendVolume.bind(this), {
    blockInitial: true
  });

  /**
   * A flag that indicates whether the initial update has been sent.
  */
  this._initialUpdateSent = false;

  /**
   * A flag that indicates that the started playing updates has been sent.
   */
  this._startedPlayingUpdateSent = false;

  // Rebind common functions
  this._performCommand = this._performCommand.bind(this);
  this._handleRegisterResponse = this._handleRegisterResponse.bind(this);
  this._handleStateConflictResponse =
    this._handleStateConflictResponse.bind(this);
  this._onBeforeTrackChange = this._onBeforeTrackChange.bind(this);

  this._init();
}
inherit(TPServiceClient, EventEmitter);

TPServiceClient.create = function(options) {
  return new TPServiceClient(options);
};

/**
 * Initializes the client.
 *
 * @protected
 */
TPServiceClient.prototype._init = function() {
  // We start out with a resolved promise in order to ensure that we can
  // deregister successfully if we never played anything.
  this._waitingForTrackingData = Promise.defer();
  this._waitingForTrackingData.resolve(true);

  // Attach event listeners
  this._transport.on(
    this._transport.EVENT_CONNECTION_ID,
    this._onConnectionId.bind(this)
  );

  this._transport.matchMessages(
    DEALER_PLAY_LOST_TOKEN_FILTER,
    this._onPlayTokenLost.bind(this)
  );
  this._transport.matchMessages(
    DEALER_TRACK_PLAYBACK_FILTER,
    this._onTrackPlaybackMessage.bind(this)
  );

  var listPlayer = this._listPlayer;
  listPlayer.on(PlaybackEvent.LIST_PLAYER_CAPPED, this._onCapped.bind(this));
  listPlayer.on(PlaybackEvent.LIST_PLAYER_ERROR_SYNC, this._onError.bind(this));
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_BEFORE_NEXT,
    this._onBeforeTrackChange
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_BEFORE_PREVIOUS,
    this._onBeforeTrackChange
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_BEFORE_PLAYER_LOAD,
    this._onBeforePlayerLoad.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_PLAYER_LOAD,
    this._onTrackLoaded.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_BEFORE_TRACK_LOAD,
    this._onBeforeTrackLoad.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_POSITION_CHANGED,
    this._onPositionChanged.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_DURATION_CHANGED,
    this._onDurationChanged.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_VOLUME_CHANGED,
    this._onVolumeChanged.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_PAUSED,
    this._onPlayPause.bind(this, true)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_PLAYING,
    this._onPlayPause.bind(this, false)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_PLAYED_THRESHOLD_REACHED,
    this._onPlayThresholdReached.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_PROGRESS,
    this._onProgress.bind(this)
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_TRACKING_DATA_CREATED,
    this._onTrackDataEvent.bind(this, 'created')
  );
  listPlayer.on(
    PlaybackEvent.LIST_PLAYER_TRACKING_DATA_FINALIZED,
    this._onTrackDataEvent.bind(this, 'finalized')
  );

  // Ensure that we react to descriptor change events.
  this._descriptorPromise.then(function(descriptor) {
    descriptor.on(Event.DEVICE_DESCRIPTOR_CHANGED, function() {
      this._parseDescriptor(descriptor);
      this._updateDeviceInfo();
    }.bind(this));
  }.bind(this));
};

/**
 * Handles LIST_PLAYER_BEFORE_NEXT/PREVIOUS events.
 *
 * @protected
 */
TPServiceClient.prototype._onBeforeTrackChange = function() {
  if (this._nextFinalizedDataPayload || this._switchingContext) {
    return;
  }

  var stateRef = this._currentContext ?
    this._currentContext.getStateRef() :
    null;
  var payload = this._generateStatePayload(stateRef, 'track_data_finalized');
  // We set the sequence number here already so we can "reserve" it. This
  // ensures that it will appear as an earlier message to the backend.
  this._setSequenceNumber(payload);
  this._nextFinalizedDataPayload = payload;
};

/**
 * Handles LIST_PLAYER_BEFORE_TRACK_LOAD events.
 *
 * @protected
 */
TPServiceClient.prototype._onBeforeTrackLoad = function() {
  this._loading = true;
  this._switchingContext = false;
  return;
};

/**
 * Handles LIST_PLAYER_BEFORE_PLAYER_LOAD events.
 *
 * @param {Object} ev The event object.
 * @protected
 */
TPServiceClient.prototype._onBeforePlayerLoad = function(ev) {
  var context = this._currentContext;
  if (!context) {
    return;
  }
  var currentTrack = context.getCurrentTrack();
  this._currentTrackDuration = currentTrack && currentTrack.metadata ?
    currentTrack.metadata.duration || 0 :
    0;

  var options = ev.options;
  context.setPaused(!options.autoplay);
  this._setCurrentTrackPosition(options ? options.position || 0 : 0);

  // Trigger a state update "optimistically," assuming that the loading of
  // the new track will succeed. We do this to immediately give feedback to
  // observing clients, allowing them to update their UI.
  //
  // Since we didn't actually trigger any playback yet, we'll need to send
  // additional state updates later to correct playback states and to correct
  // and metadata that might not be correct.
  this._updateState('before_track_load');

  this._startedPlayingUpdateSent = false;
  this._initialUpdateSent = false;
};

/**
 * Handles LIST_PLAYER_CAPPED events.
 *
 * @protected
 */
TPServiceClient.prototype._onCapped = function() {
  this._listPlayer.clear('capped');
  this._currentContext = null;
  this._updateState('capped');
  this._setCurrentTrackPosition(undefined);
  this._lastProcessedStateId = null;
  this.emit(Event.TP_API_STATE_CLEARED);
};

/**
 * Handles the CONNECTION_ID event from the transport.
 *
 * @param {spotify-eventemitter/types.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onConnectionId = function(ev) {
  this._connectionId = ev.id;
  if (this._isDeregistering) {
    return;
  }
  this._registered = false;

  // Check the flag for sending all state updates.
  var setLimitStateUpdates = null;
  if (this._abbaClient) {
    setLimitStateUpdates = this._abbaClient.getCell(AB_SEND_ALL_STATE_UPDATES)
      .then(function(cell) {
        if (cell.fromAbba && cell.value !== 'on') {
          this._limitStateUpdates = true;
        }
      }.bind(this))
      .catch(function() {
        return false;
      });
  }

  Promise.all([
    setLimitStateUpdates,
    this._listPlayer.getVolume(),
    this._descriptorPromise.then(this._parseDescriptor.bind(this))
  ])
    .then(
      this.register.bind(this),
      function(error) {
        debugLogger.info('Skipping registration due to error', error);
        this.emit(Event.TP_API_REGISTRATION_ABORTED, {
          reason_error: error
        });
      }.bind(this)
    )
    .catch(function() {
      // Catch any errors related to the actual registration call, but don't
      // act upon it as it will trigger an error anyway.
    });
};

/**
 * Handles LIST_PLAYER_DURATION_CHANGED events.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onDurationChanged = function(ev) {
  // This method previously triggered a state-update, which was done to ensure
  // that observing clients will be able to sync their displays to the actual
  // duration.
  // However, this led to some unexpected behaviour, so the state update has
  // been removed. We can't guarantee that the duration will be synced between
  // clients until the next update after this--which would most likely be when
  // the "played threshold" has been reached.
  this._currentTrackDuration = ev.duration;
  this._emitStateChanged();
};

/**
 * Handles LIST_PLAYER_ERROR events.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onError = function(ev) {
  if (!('position' in ev)) {
    return;
  }
  this._setCurrentTrackPosition(ev.position);
  this._updateState('error');
};

/**
 * Sets the paused state of the current context.
 *
 * @param {boolean} paused The paused state value.
 * @param {module:spotify-eventemitter.Event} ev The paused event.
 * @protected
 */
TPServiceClient.prototype._onPlayPause = function(paused, ev) {
  var context = this._currentContext;
  if (!context) {
    return;
  }
  context.setPaused(paused);
  if ('position' in ev) {
    this._setAllTrackPositions(ev.position);
  }
  if (ev.track && this._shouldSendUpdateForEvent(ev.track.stateId)) {
    this._updateState(paused ? 'pause' : 'resume');
  } else {
    this._lastProcessedStateId = null;
    this._emitStateChanged();
  }
};

/**
 * Handles a LIST_PLAYER_PLAYED_THRESHOLD_REACHED event.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onPlayThresholdReached = function(ev) {
  this._initialUpdateSent = true;
  this._setAllTrackPositions(ev.position);
  this._updateState('played_threshold_reached');
};

/**
 * Handles a play token lost message from the backend.
 *
 * @protected
 */
TPServiceClient.prototype._onPlayTokenLost = function() {
  this._listPlayer.pause().catch(function() {
    // Catch NO-LIST errors
  });
};

/**
 * Handles LIST_PLAYER_POSITION_CHANGED events.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onPositionChanged = function(ev) {
  if (this._loading) {
    // We can get this event while another track is loading (from the previously
    // playing track). When this flag is true, we will ignore this event.
    return;
  }
  this._setCurrentTrackPosition(ev.position);
  if (ev.track && this._shouldSendUpdateForEvent(ev.track.stateId)) {
    this._updateState('position_changed');
  } else {
    this._lastProcessedStateId = null;
    this._emitStateChanged();
  }
};

/**
 * Handles LIST_PLAYER_PROGRESS events.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onProgress = function(ev) {
  if (this._loading || !this._currentContext) {
    return;
  }
  this._setAllTrackPositions(ev.position);

  if (!this._startedPlayingUpdateSent && ev.played > 1000) {
    this._startedPlayingUpdateSent = true;
    this._updateState('started_playing');
  }

  var logData = ev.logData;
  if (!logData) {
    return;
  }

  // Track the stream time
  if (!logData.noLog) {
    this._totalStreamTime += ev.interval || DEFAULT_STREAM_INTERVAL;
  }

  var currentTrack = this._currentContext.getCurrentTrack();
  var playingUpdateInterval = currentTrack.ms_playing_update_interval;

  if (
    this._initialUpdateSent &&
    playingUpdateInterval > 0 &&
    (Date.now() - this._lastUpdateStateTime) > playingUpdateInterval
  ) {
    this._updateState('progress');
  }
};

/**
 * Handles tracking data events from the ListPlayer.
 *
 * @param {string} type The type of the tracking data.
 * @param {module:spotify-eventemitter.Event} e The event.
 * @protected
 */
TPServiceClient.prototype._onTrackDataEvent = function(type, e) {
  switch (type) {
    case 'created':
      this._waitingForTrackingData = Promise.defer();
      break;
    case 'finalized':
      var payload = this._nextFinalizedDataPayload;
      if (payload) {
        payload.playback_stats = e.playbackStats;
        this._updateState('track_data_finalized', payload);
      }
      this._nextFinalizedDataPayload = null;
      this._waitingForTrackingData.resolve(true);
      break;
    default:
      return;
  }
};

/**
 * Handles LIST_PLAYER_TRACK_LOADED events.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onTrackLoaded = function(ev) {
  this._loading = false;
  var context = this._currentContext;
  if (!context) {
    return;
  }
  context.setPaused(!ev.autoplay);
  this._setCurrentTrackPosition(ev.position || 0);
};

/**
 * Handles a message from the Track Playback service.
 *
 * @param {module:spotify-transport/types.DealerMessage} msg The dealer message.
 * @protected
 */
TPServiceClient.prototype._onTrackPlaybackMessage = function(msg) {
  var payloads = msg.payloads;
  if (!Array.isArray(payloads) || !payloads.length) {
    return;
  }
  this._performCommand(payloads[0]);
};

/**
 * Handles LIST_PLAYER_VOLUME_CHANGED events.
 *
 * @param {module:spotify-eventemitter.Event} ev The event.
 * @protected
 */
TPServiceClient.prototype._onVolumeChanged = function(ev) {
  this._currentGaiaVolume = ev.volume * GAIA_VOLUME;
  var commandId = ev.command_id || '';
  var payload = {
    seq_num: null,
    volume: this._currentGaiaVolume,
    command_id: commandId
  };
  // Use the volume debouncer instead of calling the method directly.
  this._volumeDebouncer.async(payload);
};


/**
 * Clears the session-specific data.
 *
 * @protected
 */
TPServiceClient.prototype._clearSessionData = function() {
  this._connectionId = null;
  this._sequenceNumber = 0;
  this._currentContext = null;
  this._lastSentStateUpdatePayload = null;
  this._totalStreamTime = 0;
  this._isSendingConflict = false;
  this._isSendingUpdate = false;
  this._queueSendUpdate = [];
  this._previousTrackPosition = undefined;
  this._currentTrackPosition = undefined;
  this._currentTrackDuration = undefined;
  this._lastProcessedStateId = null;
  this.emit(Event.TP_API_STATE_CLEARED);
};

/**
 * Creates a state reference object from an internal state reference.
 *
 * @param {module:spotify-harmony/_internal/types.StateMachine} stateMachine The
 *     state machine that will be used to create the reference.
 * @param {module:spotify-harmony/_internal/types.InternalStateRef}
 *     internalStateRef The internal state reference.
 * @return {module:spotify-harmony/_internal/types.StateRef} The created state
 *     reference.
 * @protected
 */
TPServiceClient.prototype._createStateRef = function(
  stateMachine,
  internalStateRef
) {
  if (!internalStateRef) {
    // A null internal state reference should always return a null state
    // reference.
    return null;
  }

  var state = stateMachine.states[internalStateRef.state_index];
  if (!state) {
    throw new TPServiceClientError(
      Errors.TP_CANNOT_CREATE_STATE_REF,
      'Invalid state reference.'
    );
  }

  return {
    state_machine_id: stateMachine.state_machine_id,
    state_id: state.state_id,
    paused: internalStateRef.paused
  };
};

/**
 * Sends a deregistration request to the Track Playback Service.
 *
 * @param {Object} lastPlayerState The ListPlayer state prior to deregistration.
 * @return {Promise.<boolean>} True if the deregistration request was
 *     successfully sent, false otherwise.
 * @protected
 */
TPServiceClient.prototype._deregisterFromService = function(lastPlayerState) {
  var stateRef = null;

  var currentContext = this._currentContext;
  if (currentContext) {
    if (lastPlayerState) {
      currentContext.setPaused(!lastPlayerState.playing);
      this._setAllTrackPositions(lastPlayerState.position);
    }
    stateRef = currentContext.getStateRef();
  }

  var payload = this._generateStatePayload(stateRef, 'deregister');
  this._setSequenceNumber(payload);

  var endpoint = this._endpoint + '/v1/devices/' + this._deviceId;
  return this._transport.request(endpoint, {
    authorize: true,
    method: 'DELETE',
    payload: JSON.stringify(payload),
    responseType: 'json',
    retry: SHORT_BACKOFF
  })
    .then(function(response) {
      if (response.status !== 200 && response.status !== 204) {
        // Since we "technically failed", we should reset the value of this flag
        // so we can retry.
        this._registered = true;
        return false;
      }

      // Check the response body and log any EndSongs that might have been sent
      // back.
      var body = response.body;
      if (body) {
        if (body.endsong) {
          endSongLogger.log(body.endsong);
        }
        if (body.endsongs) {
          endSongsLogger.log(body.endsongs);
        }
      }

      // Successfully deregistered.
      this._clearSessionData();
      this.emit(Event.TP_API_DEREGISTERED);
      return true;
    }.bind(this));
};

/**
 * Emits an error event.
 *
 * @param {Error} error The error object.
 * @param {Object} jsonData Additional data for the error as JSON.
 * @protected
 */
TPServiceClient.prototype._emitError = function(error, jsonData) {
  // Log the error
  this._logger.logJSSDKError({
    source: 'tpapi-client',
    version: version.tagged,
    type: error.code,
    message: error && error.message,
    stack: error && error.stack,
    json_data: jsonData,
    json_data_version: '1.0.0'
  }).catch(function(e) {
    debugLogger.error('Track-Playback Logging Error', e);
  });

  // Emit the error
  this.emit(Event.TP_API_ERROR, {
    error: error,
    data: jsonData
  });
};

/**
 * Emits a `state_changed` event.
 *
 * @protected
 */
TPServiceClient.prototype._emitStateChanged = function() {
  var context = this._currentContext;
  if (!context) {
    return;
  }
  this.emit(Event.TP_API_STATE_CHANGED, {
    stateMachine: context.getStateMachine(),
    stateRef: context.getInternalStateRef(),
    position: this._currentTrackPosition || 0,
    duration: this._currentTrackDuration || 0,
    paused: context.isPaused()
  });
};

/**
 * Creates a state payload that can be sent for any backend requests that need
 * the current device state.
 *
 * @param {Object} stateRef The StateRef object for the payload.
 * @param {string} src An optional reason for the payload generation.
 * @return {Object} The generated payload.
 * @protected
 */
TPServiceClient.prototype._generateStatePayload = function(stateRef, src) {
  // Note: values are set to "undefined" by default in some cases so the
  // corresponding keys are removed during JSON.stringify serialization.
  return {
    seq_num: undefined,
    seq_nums: undefined,
    state_ref: stateRef,
    sub_state: {
      playback_speed: stateRef && !stateRef.paused ? 1 : 0,
      position: this._currentTrackPosition,
      duration: this._currentTrackDuration || undefined,
      stream_time: this._totalStreamTime
    },
    previous_position: this._previousTrackPosition,

    // Leave this undefined as it will be ffilled by the TRACK_DATA_FINALIZED
    // event.
    playback_stats: undefined,

    // Placeholder for state conflict payloads.
    rejected_state_refs: undefined,

    // This is an unused field that we set in order to debug where the state
    // update is coming from.
    debug_source: src
  };
};

/**
 * Parses the result of a registration request to the Track Playback service.
 *
 * @param {module:spotify-transport/types/http_response} response The response
 *     to parse.
 * @return {Promise.<Object>} The body of the response.
 */
TPServiceClient.prototype._handleRegisterResponse = function(response) {
  var error;

  if (response.status === 429) {
    // This case happens when a particular client creates too many connections
    // for a single user.
    error = new TPServiceClientError(
      Errors.TP_MAX_SUBSCRIPTIONS_REACHED,
      'Max connections reached'
    ).fatal();
    error.maxedSubscriptions = true;
    error.status = response.status;

    this.emit(Event.TP_API_MAX_SUBSCRIPTIONS_REACHED, {
      error: error
    });
    return Promise.reject(error);
  }

  if (
    response.status === 403 &&
    response.body &&
    response.body.error_type === 'PREMIUM_REQUIRED'
  ) {
    // For non-whitelisted clients, registering to the Track Playback service
    // with a non-premium user will result in an error.
    error = new TPServiceClientError(
      Errors.TP_REGISTRATION_FAILED_NON_PREMIUM,
      'Cannot register to Track Playback with non-premium user.'
    ).fatal();
  } else if (response.status !== 200) {
    // We expect that a successful response will always have 200. If not, then
    // it's probably an error.
    error = new TPServiceClientError(
      Errors.TP_REGISTRATION_FAILED_WITH_STATUS,
      'track-playback service responded with status ' + response.status +
      ' when registering device'
    ).fatal();
  } else if (!response.body) {
    // We always expect a response body if the registration was successful.
    error = new TPServiceClientError(
      Errors.TP_NO_RESPONSE_BODY,
      'Unexpected empty response body from registration request.'
    ).fatal();
  }

  if (error) {
    error.status = response.status;
    return Promise.reject(error);
  }

  // All initial checks passed, set local flags from the response.
  var initialState = response.body;
  // Logging values
  if (initialState.endsong) {
    endSongLogger.log(initialState.endsong);
  }
  if (initialState.endsongs) {
    endSongsLogger.log(initialState.endsongs);
  }

  this._sequenceNumber = initialState.initial_seq_num;

  this._registered = true;
  this.emit(Event.TP_API_REGISTERED, {deviceId: this._deviceId});
  return true;
};

/**
 * Parses the response from the state conflict request, processesing any
 * commands that might have been included.
 *
 * @param {module:spotify-transport/types/http_response} response The HTTP
 *     response to parse.
 * @protected
 */
TPServiceClient.prototype._handleStateConflictResponse = function(response) {
  if (response.status >= 200 && response.status < 300) {
    // Successful response
    var body = response.body;
    if (!body || !body.commands || !body.commands.length) {
      return;
    }

    var commands = body.commands;
    for (var i = 0, l = commands.length; i < l; i++) {
      this._performCommand(commands[i]);
    }
  } else {
    var error = new TPServiceClientError(
      Errors.TP_CONFLICT_REQUEST_FAILED_WITH_STATUS,
      'Track-Playback service responded with ' + response.status
    );
    error.status = response.status;
    this._emitError(error);
  }
};

/**
 * Handles the response to a state update request.
 *
 * @param {Object} sentStateRef The state reference that was sent for the
 *     request. Used for comparison after the response has been received to see
 *     whether the new state is still valid.
 * @param {module:spotify-transport/types/http_response} response The HTTP
 *     response for the state update request.
 * @return  {Promise.<Object>} The body of the response.
 * @protected
 */
TPServiceClient.prototype._handleStateUpdateResponse = function(
  sentStateRef,
  response
) {
  var error;
  if (response.status !== 200) {
    error = new TPServiceClientError(
      Errors.TP_PARSE_STATE_UPDATE_FAILED_WITH_STATUS,
      'Service responded with status ' + response.status
    );
    error.status = response.status;
    return Promise.reject(error);
  }
  if (!response.body) {
    error = new TPServiceClientError(
      Errors.TP_UPDATE_REQUEST_EMPTY_RESPONSE,
      'Unexpected empty response body from state update request.'
    );
    error.status = response.status;
    return Promise.reject(error);
  }

  //  Success, continue with parsing the response.

  var command = response.body;

  // Log any endsongs from the response.
  if (command.endsong) {
    endSongLogger.log(command.endsong);
  }
  if (command.endsongs) {
    endSongsLogger.log(command.endsongs);
  }

  var context = this._currentContext;
  if (!context) {
    // Nothing is playing, so there's no state to update.
    return Promise.resolve();
  }

  var newStateMachine = command.state_machine;
  var updatedInternalStateRef = command.updated_state_ref;
  if (!this._isCurrentStateRef(sentStateRef)) {
    // The updated state is no longer valid. We therefore ignore the new state
    // from the response.
    return Promise.resolve();
  }

  // Replace our current state with the updated state from the backend.
  context.setStateMachine(newStateMachine);
  context.setCurrentState(updatedInternalStateRef);

  this._emitStateChanged();

  return Promise.resolve();
};

/**
 * Checks whether the provided state reference is the same as the currently
 * known state reference.
 *
 * @param {module:spotify-harmony/_internal/types.StateRef} stateRef The state
 *     refence to compare with the current state reference.
 * @return {boolean} True if the provided state reference is the same as the
 *     current state reference, false otherwise.
 * @protected
 */
TPServiceClient.prototype._isCurrentStateRef = function(stateRef) {
  var currentStateRef = this._currentContext ?
    this._currentContext.getStateRef() :
    null;

  if (!currentStateRef && !stateRef) {
    return true;
  } else if (!currentStateRef || !stateRef) {
    return false;
  }

  return currentStateRef.state_machine_id === stateRef.state_machine_id &&
    currentStateRef.state_id === stateRef.state_id &&
    currentStateRef.paused === stateRef.paused;
};

/**
 * Logs an unsent state update request to the backend.
 *
 * @param {Object} payload The payload that was not sent.
 * @protected
 */
TPServiceClient.prototype._logUnsentStateUpdate = function(payload) {
  debugLogger.info('Unsent state update.', payload);
  this._logger.logClientEvent({
    source: 'tpapi-client',
    source_version: version.tagged,
    source_vendor: 'spotify',
    event: 'unsent-state-update',
    event_version: '1.0.0',
    json_data: payload
  }).catch(function(e) {
    debugLogger.error('Track-Playback Logging Error', e);
  });
};

/**
 * Stops playback and deregisters the client.
 *
 * @protected
 */
TPServiceClient.prototype._logout = function() {
  this._listPlayer.pause().catch(function() {
    // Sometimes we will have no list, but we still want to pause, so we
    // so we add a catch block to prevent the error from bubbling into the
    // console.
  });
  this.emit(Event.TP_API_STATE_CLEARED);
  this.deregister().then(function(success) {
    this._currentContext = null;
    this._setCurrentTrackPosition(undefined);
    if (success) {
      this.emit(Event.TP_API_LOGOUT);
    }
  }.bind(this));
};

/**
 * Parses a device descriptor and sets internal flags.
 *
 * @param {module:spotify-harmony/lib/device_descriptor} descriptor The device
 *     descriptor to parse.
 * @return {boolean} Returns true.
 */
TPServiceClient.prototype._parseDescriptor = function(descriptor) {
  this._deviceId = descriptor.getId();
  this._deviceInfo = descriptor.toTrackPlaybackJSON();
  this._manifestFormats = descriptor.getManifestFormats();
  return true;
};

/*
 * Parses and runs a command from the Track Playback service.
 *
 * @param {Object} command The command to perform.
 * @protected
 */
TPServiceClient.prototype._performCommand = function(command) {
  switch (command.type) {
    case 'set_volume':
      this._setVolume(command);
      break;
    case 'log_out':
      this._logout();
      break;
    case 'replace_state':
      this._replaceState(command);
      break;
    case 'ping':
      this._updateState('ping');
      break;
    default:
      var error = new TPServiceClientError(
        Errors.TP_UNKNOWN_COMMAND,
        'Received unknown command.'
      );
      this._emitError(error, {command: command});
  }
};

/**
 * Rejects a state by sending a state conflict request.
 *
 * @param {Object?} rejectedState The state that was rejected. If not-provided
 *     it will trigger sending any queued rejected states.
 */
TPServiceClient.prototype._rejectState = function(rejectedState) {
  var queuedRejectedStates = this._queuedRejectedStates;

  // We add the state to the queue already, even though we might send it
  // immediately. This simplifies the code to always send the queue, rather
  // than to recreate the queue every time.
  if (typeof rejectedState !== 'undefined') {
    queuedRejectedStates.push(rejectedState);
  }

  if (
    !this._registered ||
    this._isSendingConflict ||
    !queuedRejectedStates.length
  ) {
    // If we are not registered, or if we have a state conflict in-flight or
    // if there's nothing to send, return early.
    return;
  }

  this._isSendingConflict = true;

  // Get all conflicts to be sent from the queue, removing them from the array
  // (thereby emptying the queue again).
  var rejectedStates = queuedRejectedStates.splice(0, 5);

  var stateRef = this._currentContext ?
    this._currentContext.getStateRef() :
    null;
  var payload = this._generateStatePayload(stateRef);
  payload.rejected_state_refs = rejectedStates;

  this._setSequenceNumbers(payload, rejectedStates.length);

  // Called after the request to reset the state conflict sending flags.
  var resetConflictFlags = function() {
    this._isSendingConflict = false;
    this._rejectState();
  }.bind(this);

  var endpoint = this._endpoint +
    '/v1/devices/' +
    this._deviceId +
    '/state_conflict';

  this._transport.request(endpoint, {
    authorize: true,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    responseType: 'json',
    payload: JSON.stringify(payload),
    retry: SHORT_BACKOFF
  })
    .then(this._handleStateConflictResponse)
    .then(resetConflictFlags, resetConflictFlags);
};

/**
 * Replaces the currently known state with a state given by a command.
 *
 * @param {Object} command The command that contains the new state.
 * @protected
 */
TPServiceClient.prototype._replaceState = function(command) {
  var listPlayer = this._listPlayer;

  var cmdStateMachine = command.state_machine;
  var cmdInternalStateRef = command.state_ref;
  var newStateRef = this._createStateRef(cmdStateMachine, cmdInternalStateRef);

  if (!this._isCurrentStateRef(command.prev_state_ref)) {
    // The backend thinks that the client is in a different state. This can
    // happen the client's state changes before it's successfully notified the
    // backend about the new state.
    //
    // This case is called a "state conflict" and the client needs to send this
    // conflicting state to the backend so that it can reapply any operations
    // to the new state.
    this._rejectState(newStateRef);
    return;
  }

  if (!cmdInternalStateRef) {
    // When we get a null state, it means that we should clear the context.
    listPlayer.pause().catch(function() {
      // Sometimes we will have no list, but we still want to pause, so we
      // so we add a catch block to prevent the error from bubbling into the
      // console.
    });
    listPlayer.clear('remote');
    this._currentContext = null;
    this._updateState('state_clear');
    this._setAllTrackPositions(undefined);
    this._lastProcessedStateId = null;
    this.emit(Event.TP_API_STATE_CLEARED);

    // We set this as true to suppress any position-related events that will
    // happen in response to clearing the track.
    this._loading = true;
    return;
  }

  var currentStateRef = this._currentContext ?
    this._currentContext.getStateRef() :
    null;

  if (currentStateRef && currentStateRef.state_id === newStateRef.state_id) {
    // Same state ids means that this is a track operation, so we don't need to
    // create a new context.
    var currentContext = this._currentContext;
    currentContext.setStateMachine(cmdStateMachine);
    currentContext.setCurrentState(cmdInternalStateRef);

    // Flag to determine whether there's an operation from this state machine
    // that will trigger a state update.
    var willUpdate = false;

    // If the current paused state is not the same as the old paused state, it
    // will most likely trigger an event, so we set this here.
    if (currentContext.isPaused() !== cmdInternalStateRef.paused) {
      willUpdate = true;
    }

    if (cmdInternalStateRef.paused) {
      currentContext.setPaused(true);
      listPlayer.pause();
    } else {
      currentContext.setPaused(false);
      listPlayer.resume();
    }

    var seekPosition = parseInt(command.seek_to, 10);
    if (currentContext.allowSeeking() && !isNaN(seekPosition)) {
      listPlayer.seek(seekPosition);
      // Assume that we'll have a successful seek.
      this._setCurrentTrackPosition(seekPosition);
      willUpdate = true;
    }

    if (willUpdate) {
      // There will be a separate state update from one of the above operations,
      // so just wait for that instead of doing a separate one right now.
      // However, we should emit a state change since that's not automatically
      // handled for us anymore.
      this._emitStateChanged();
    } else {
      // Set this to null to allow for the next updates to all propagate.
      this._lastProcessedStateId = null;
      this._updateState('modify_current_state');
    }
  } else {
    this._lastProcessedStateId = newStateRef.state_id;

    // Replacing the context will stop the current track
    if (this._currentContext) {
      this._onBeforeTrackChange();
    }

    // The id of the command's state is not the same as the current state id
    // that we have. This means that we will have to create a new context and
    // load it for playback.
    var newContext = this._ListClass.create(
      'spotify:app:jsspeaker',
      this._manifestFormats
    );
    newContext.setStateMachine(cmdStateMachine);
    newContext.startAtState(cmdInternalStateRef);
    newContext.setDeviceId(this._deviceId);
    this._currentContext = newContext;

    // We need to set the initial position of the first track to be played in
    // the context. While individual states may contain their starting position,
    // this field from the command overrides any position that might be defined
    // in the state.
    var seekTo = command.seek_to || 0;
    newContext.setInitialPosition(seekTo);

    // For reporting the track duration, we start out with the duration that's
    // provided by the metadata in the State Machine. This might or might not be
    // equal to the actual value of the track duration (differences between
    // different formats or encodings), so this is expected to be corrected
    // later when we get the duration_changed event.
    // var track = newContext.getCurrentTrack();
    // this._currentTrackDuration = track ? track.metadata.duration : 0;

    this._loading = true;
    this._switchingContext = true;
    listPlayer.play(newContext, {reason: 'remote'});
  }
};

/**
 * Sends a devices request to the Track Playback API.
 *
 * @param {string} method The HTTP verb to use for the request.
 * @param {Object} payload The payload to send.
 * @return {module:spotify-transport/types/http_response} The response for the
 *     request.
 * @protected
 */
TPServiceClient.prototype._sendDevicesRequest = function(
  method,
  payload
) {
  var endpoint = this._endpoint + '/v1/devices';
  if (method === 'PUT') {
    endpoint += '/' + this._deviceId;
  }
  return this._transport.request(endpoint, {
    authorize: true,
    method: method || 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    responseType: 'json',
    payload: JSON.stringify(payload),
    retry: LONG_BACKOFF
  });
};

/**
 * Sends a volume request to the Track Playback service to denote a change in
 * the local volume.
 *
 * @param {Object} payload The JSON payload for the reequest.
 * @return {Promise.<module:spotify-transport/types.HTTPResponse>} The response.
 */
TPServiceClient.prototype._sendVolume = function(payload) {
  var endpoint = this._endpoint + '/v1/devices/' + this._deviceId + '/volume';
  this._setSequenceNumber(payload);
  return this._transport.request(endpoint, {
    authorize: true,
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    payload: JSON.stringify(payload)
  });
};

/**
 * Sets the current and the previous position of the track to the provided
 * value.
 *
 * @param {number} position The positionin milliseconds.
 * @protected
 */
TPServiceClient.prototype._setAllTrackPositions = function(position) {
  this._previousTrackPosition = position;
  this._currentTrackPosition = position;
};

/**
 * Set the current position of the track.
 *
 * @param {number} position The positionin milliseconds.
 * @protected
 */
TPServiceClient.prototype._setCurrentTrackPosition = function(position) {
  this._previousTrackPosition = this._currentTrackPosition;
  this._currentTrackPosition = position;
};

/**
 * Sets the sequence number of a request payload.
 *
 * @param {Object} payload The payload.
 * @return {Object} The payload with the `seq_num` property set.
 * @protected
 */
TPServiceClient.prototype._setSequenceNumber = function(payload) {
  if (payload.seq_num === undefined) {
    payload.seq_num = ++this._sequenceNumber;
  }
  return payload;
};

/**
 * Sets the seq_nums property of an object payload to a set of sequence numbers.
 *
 * @param {Object} payload The payload.
 * @param {number} count The number of sequence numbers to add.
 * @return {Object} The payload with the `seq_nums` property set to an array
 *     containing a number of sequence numbers equal to `count`.
 * @protected
 */
TPServiceClient.prototype._setSequenceNumbers = function(payload, count) {
  payload.seq_nums = [];
  for (var i = 0; i < count; i++) {
    payload.seq_nums.push(++this._sequenceNumber);
  }
  return payload;
};

/**
 * Parses a set_volume command.
 *
 * @param {Object} command The command to process.
 * @protected
 */
TPServiceClient.prototype._setVolume = function(command) {
  var volume = command.volume / GAIA_VOLUME;
  this._listPlayer.setVolume(volume, command.command_id);
};

/**
 * Checks whether we should send a state update for a particular state id.
 *
 * @param {string} stateId The state id to check.
 * @return {boolean} True if we should send a state update, false otherwise.
 */
TPServiceClient.prototype._shouldSendUpdateForEvent = function(stateId) {
  return !!(stateId && stateId !== this._lastProcessedStateId);
};

/**
 * Sends an updated device info to the backend.
 *
 * @protected
 */
TPServiceClient.prototype._updateDeviceInfo = function() {
  if (!this._registered) {
    return;
  }
  this._sendDevicesRequest('PUT', this._deviceInfo)
    .then(function(response) {
      if (response.status === 204) {
        this.emit(Event.TP_API_REGISTRATION_UPDATED);
      }
    }.bind(this));
};

/**
 * Sends an update of the current state to the backend.
 *
 * @param {string} source A string that indicates the reason for the update.
 * @param {Object} overridePayload An object that will be used as a payload
 *     instead of a generated one.
 * @protected
 */
TPServiceClient.prototype._updateState = function(source, overridePayload) {
  if (!this._registered) {
    return;
  }

  var stateRef;
  var payload;
  if (overridePayload) {
    stateRef = overridePayload.state_ref;
    payload = overridePayload;
  } else {
    stateRef = this._currentContext ?
      this._currentContext.getStateRef() :
      null;
    payload = this._generateStatePayload(stateRef, source);
  }

  if (!this._wasStatePayloadSentRecently(payload)) {
    // We've already sent this payload recently, so we don't resend a duplicate.
    debugLogger.info('State update ignored (duplicate).', payload);
    return;
  }

  // Emit a state change prior to sending so that local observers can update the
  // UI.
  this._emitStateChanged();

  if (this._isSendingUpdate && this._limitStateUpdates) {
    // If _limitStateUpdates is true, we want to ensure that we only have one
    // state update in flight at any given time. We would therefore queue any
    // state update operations for later.
    this._logUnsentStateUpdate(payload);
    this._queueSendUpdate.push(source);
    return;
  }

  this._isSendingUpdate = true;
  this._queueSendUpdate = [];
  this._setSequenceNumber(payload);
  this._lastSentStateUpdatePayload = payload;

  // Called after the request to reset the flags.
  var resetStateUpdateFlags = function() {
    this._isSendingUpdate = false;
    if (this._queueSendUpdate.length) {
      this._updateState(this._queueSendUpdate.join(','));
    }
    debugLogger.info('State update sent.', source, payload);
  }.bind(this);

  var endpoint = this._endpoint + '/v1/devices/' + this._deviceId + '/state';

  this._lastUpdateStateTime = Date.now();

  this._transport.request(endpoint, {
    authorize: true,
    method: 'PUT',
    headers: {
      'Content-Type': 'application/json'
    },
    responseType: 'json',
    payload: JSON.stringify(payload),
    retry: LONG_BACKOFF
  })
    .then(this._handleStateUpdateResponse.bind(this, stateRef))
    .then(
      resetStateUpdateFlags,
      function(error) {
        this._emitError(error);
        resetStateUpdateFlags();
      }.bind(this)
    );
};

/**
 * Compares a state update payload to the last sent payload to see if they are
 * the same.
 *
 * @param {Object} payload The payload to compare.
 * @return {boolean} True if the payload is the same as the last sent payload,
 *     false otherwise.
 * @protected
 */
TPServiceClient.prototype._wasStatePayloadSentRecently = function(payload) {
  var lastPayload = this._lastSentStateUpdatePayload;
  if (!lastPayload || !lastPayload.state_ref || !payload.state_ref) {
    // Null state
    return true;
  }

  // Compare state-ref
  var pStateRef = payload.state_ref;
  var lStateRef = lastPayload.state_ref;
  if (
    pStateRef.paused !== lStateRef.paused ||
    pStateRef.state_id !== lStateRef.state_id ||
    pStateRef.state_machine_id !== lStateRef.state_machine_id
  ) {
    return true;
  }

  // Compare sub state
  var pSubState = payload.sub_state;
  var lSubState = lastPayload.sub_state;
  if (
    pSubState.playback_speed !== lSubState.playback_speed ||
    pSubState.position !== lSubState.position ||
    pSubState.duration !== lSubState.duration
  ) {
    return true;
  }

  // Compare previous positions
  if (payload.previous_position !== lastPayload.previous_position) {
    return true;
  }

  return false;
};

/**
 * Deregisters the client from the Track Playback service.
 *
 * @return {Promise.<boolean>} True if the device was successfully deregistered,
 *     false otherwise.
 */
TPServiceClient.prototype.deregister = function() {
  if (!this._registered) {
    return Promise.resolve(false);
  }
  this._isDeregistering = true;
  // We optimistically set ourselves as deregistered to prevent any other
  // request from being sent.
  this._registered = false;

  // we should update some internal variables before we send the deregister
  // request.
  return this._listPlayer.getPlayerState()
    .then(function(playerState) {
      return Promise.all([
        this._deregisterFromService(playerState),
        this._waitingForTrackingData.promise,
        this._listPlayer.stop().catch(function() { /* noop */ })
      ]).spread(function(response) {
        this._isDeregistering = false;
        return response;
      }.bind(this));
    }.bind(this), function() {
      this._isDeregistering = false;
      // Most likely a NO_TRACK_PLAYER error, which we can ignore.
      this._registered = true;
      return false;
    }.bind(this));
};

/**
 * Registers the client as a new device to the Track Playback service.
 *
 * @return {Promise.<boolean>} True if the device was successfully registered,
 *     false otherwise.
 */
TPServiceClient.prototype.register = function() {
  if (this._registered) {
    return Promise.resolve(false);
  }
  var prevState = null;

  var context = this._currentContext;
  if (context) {
    // If there's a context, we need to set the `previous_session_state` value
    // to the current state. This is the case when we're reregistering after a
    // temporary disconnection.
    prevState = this._generateStatePayload(context.getStateRef(), 'register');
    this._setSequenceNumber(prevState);
  }

  return this._sendDevicesRequest('POST', {
    device: this._deviceInfo,
    connection_id: this._connectionId,
    client_version: this._clientVersion,
    previous_session_state: prevState,
    volume: this._currentGaiaVolume
  })
    .then(this._handleRegisterResponse)
    .catch(function(e) {
      if (e && !e.maxedSubscriptions) {
        e.registration = true;
        this._emitError(e);
      }
      return false;
    }.bind(this));
};

module.exports = TPServiceClient;
