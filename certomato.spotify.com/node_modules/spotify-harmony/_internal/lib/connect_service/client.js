'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var URI = require('spotify-liburi');

var Event = require('../../types/event');
var Errors = require('../../../types/errors');
var PlayerAPIClientError = require('./client_error');

var areDevicesEqual = require('../../helpers/device').areDevicesEqual;

/**
 * The default endpoint for the Connect State service.
 *
 * @const {string}
 * @private
 */
var ENDPOINT = 'https://@webgate/connect-state';

/**
 * A regular expression filter used to match messages from dealer.
 *
 * @const {RegExp}
 * @private
 */
var URI_FILTER = /connect-state\/v1\/cluster$/;

/**
 * A special Device ID value used to denote the current device.
 *
 * @const {string}
 * @private
 */
var LOCAL_DEVICE_ID = '@local';

/**
 * Prefix for the observer device id.
 *
 * @const {string}
 * @private
 */
var OBSERVER_PREFIX = 'hobs_';

/**
 * A regular expression used to extract the first 40 characters of the device
 * id
 *
 * @const {RegExp}
 * @private
 */
var DEVICE_ID_TRUNCATOR = /^([a-zA-Z0-9_%:-]{1,40}).*$/;

/**
 * The maximum volume value in the Connect protocol.
 *
 * To simplify the volume controls, we translate this value from 0 to 1.
 *
 * @const {number}
 * @private
 */
var GAIA_VOLUME = 65535.0;

function currentTrackIsAd(playerState) {
  if (!playerState.track) {
    return false;
  }
  var maybeURI = URI.from(playerState.track.uri || {type: 'ad'});
  return maybeURI.type === URI.Type.AD ||
    maybeURI.type === URI.Type.INTERRUPTION;
}

/**
 * Represents an API interface to a Player API compatible service.
 *
 * @constructor
 * @param {module:spotify-playerapi-client/types.PlayerAPIClientOptions} options
 *     The options for the instance.
 */
function PlayerAPIClient(options) {
  EventEmitter.call(this);

  /**
   * The device descriptor
   *
   * @type {module:spotify-playerapi-client/types.DeviceDescriptor}
   * @protected
   */
  this._descriptor = options.descriptor;

  /**
   * The Spotify Transport instance, used to make requests to the
   * WebGate.
   *
   * @type {module:spotify-transport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * The Player API Service endpoint to use.
   *
   * @type {string}
   * @protected
   */
  this._endpoint = options.endpoint || ENDPOINT;

  /**
   * When set to true, the client will automatically register once it receives
   * a connection id.
   *
   * @type {boolean}
   * @protected
   */
  this._autoregister = 'autoregister' in options ? options.autoregister : true;

  /**
   * The connection id
   *
   * @type {module:spotify-transport/types.ConnectionId}
   * @protected
   */
  this._connectionId = null;

  /**
   * The local device id.
   *
   * @type {string}
   * @protected
   */
  this._localDeviceId = null;

  /**
   * The local device id for the observer (i.e., this instance).
   *
   * Since we cannot have the same device id for two different devices, and
   * since the observer is technically a different device, we need a to append
   * a short string to the end of the local device id to show that this is the
   * observer device.
   *
   * @type {string}
   * @protected
   */
  this._localObserverDeviceId = null;

  /**
   * A reference to the last device that was part of a state-changed event.
   *
   * @type {module:spotify-playerapi-client/types.DeviceState}
   * @protected
   */
  this._lastActiveDevice = null;

  /**
   * A reference to the last player state received.
   *
   * @type {module:spotify-playerapi-client/types.ContextPlayerState}
   * @protected
   */
  this._lastKnownPlayerState = null;

  /**
   * A cache of the last known list of devices.
   *
   * @type {Array.<DeviceInfo>}
   * @protected
   */
  this._lastKnownDevices = [];

  /**
   * A reference to the local device.
   *
   * @type {DeviceInfo}
   * @protected
   */
  this._localDevice = null;

  /**
   * A flag that indicates whether the initial state has been fetched.
   *
   * @type {boolean}
   * @protected
   */
  this._fetchedInitialState = false;

  /**
   * A map of requests that are awaiting acknowledgement from the service.
   *
   * @type {Object.<string, Promise.Deferred}
   * @protected
   */
  this._awaitingAcknowledgment = {};

  /**
   * A promise that will be resolved once the device descriptor has been
   * correctly parsed.
   *
   * @type {Promise.<boolean>}
   * @protected
   */
  this._descriptorPromise = null;

  /**
   * An array of objects containing "acknowledgements" from the service that
   * are received while requests are in flight.
   *
   * Since the service can acknowledge a command using an `ack_id` even before
   * the request for a command has finished, we create request-specific maps for
   * all the commands acknowledged during the roundtrip of the request.
   *
   * Once the response of the command request is received, we can compare the
   * ack_id (if any) to any acknowledged commands while the request is in
   * flight.
   *
   * @type {Array.<Object.<string, number>>}
   * @protected
   */
  this._acknowledgementMaps = [];

  /**
   * The timestamp of the last processed cluster data.
   *
   * @type {number}
   * @protected
   */
  this._lastProcessedTimestamp = 0;

  /**
   * A setTimeout token that will be used to throttle any requests for
   * processing the cluster.
   *
   * @type {number}
   * @protected
   */
  this._clusterProcessingToken = 0;

  // Bindings
  this._awaitResponseWithAck = this._awaitResponseWithAck.bind(this);

  this._init();
}
inherit(PlayerAPIClient, EventEmitter);

/**
 * Creates a new instance of the PlayerAPIClient.
 *
 * @param {module:spotify-playerapi-client/types.PlayerAPIClientOptions} options
 *     The options for the instance.
 * @return {module:spotify-playerapi-client} The PlayerAPI client.
 */
PlayerAPIClient.create = function(options) {
  return new PlayerAPIClient(options);
};

/**
 * Initializes the PlayerAPIClient instance.
 *
 * @protected
 */
PlayerAPIClient.prototype._init = function() {
  this._transport.on(
    this._transport.EVENT_CONNECTION_ID,
    this._onConnectionId.bind(this)
  );

  this._transport.matchMessages(
    URI_FILTER,
    this._onClusterMessage.bind(this)
  );

  this._descriptorPromise = Promise.resolve(this._descriptor)
    .then(function(descriptor) {
      this._localDeviceId = descriptor.id;

      // Truncated to 40-chars
      this._localObserverDeviceId = (OBSERVER_PREFIX + this._localDeviceId)
        .replace(DEVICE_ID_TRUNCATOR, '$1');
      return true;
    }.bind(this));
};

/**
 * Handles the 'connection_id' event from the transport.
 *
 * @param {Object} e The event object.
 * @protected
 */
PlayerAPIClient.prototype._onConnectionId = function(e) {
  this._connectionId = e.id;
  if (this._autoregister) {
    this.register();
  }
};

/**
 * Handles a cluster message from dealer.
 *
 * @param {Object} msg The message from Dealer.
 * @protected
 */
PlayerAPIClient.prototype._onClusterMessage = function(msg) {
  var payload = msg.payloads[0];
  if (!payload) {
    return;
  }
  if (payload.ack_id) {
    var id = payload.ack_id;
    var waiting = this._awaitingAcknowledgment[id];
    if (waiting) {
      // We know that there's a corresponding command awaiting an
      // acknowledgement, so we just resolve the promise.
      waiting.resolve(true);
    } else {
      // There's nothing waiting, but the requests in-flight might not know
      // their ack_ids yet, so we go through their maps and set the ack ids
      // as acknowledged. That way when they're done, they can resolve their
      // promises immediately.
      var acknowledgementMaps = this._acknowledgementMaps;
      for (var i = 0, l = acknowledgementMaps.length; i < l; i++) {
        acknowledgementMaps[i][id] = 1;
      }
    }
  }
  this._parseCluster(payload.cluster);
};

/**
 * Builds an endpoint for a particular request.
 *
 * @param {string} version The version of the API to use.
 * @param {string} command The command for the request.
 * @param {string} deviceId The target device id of the request.
 * @return {string} The generated endpoint.
 * @protected
 */
PlayerAPIClient.prototype._makeEndpoint = function(version, command, deviceId) {
  return this._descriptorPromise.then(function() {
    var localId = this._localDeviceId;
    var targetId = deviceId;
    if (!targetId) {
      // If no device id is provided, default to the last active one, if present
      // or to the local device.
      targetId = this._lastActiveDevice ?
        this._lastActiveDevice.id :
        this._localDeviceId;
    }
    // If endpoint Id is '@local', default to localDeviceId.
    if (targetId === LOCAL_DEVICE_ID) {
      targetId = localId;
    }

    return [
      this._endpoint,
      version,
      command,
      'from',
      localId,
      'to',
      targetId
    ].join('/');
  }.bind(this));
};

/**
 * Sends a player command to the service.
 *
 * @param {string} endpoint The command endpoint name.
 * @param {string} deviceId The target device id.
 * @param {Object?} payload The optional payload for the command.
 * @return {Promise.<boolean>} A promise that will be resolved with a boolean
 *     value indicating whether the command was successfully triggered.
 */
PlayerAPIClient.prototype._sendPlayerCommand = function(
  endpoint,
  deviceId,
  payload
) {
  var _payload = payload || {};
  _payload.endpoint = endpoint;
  return this._makeEndpoint('v1', 'player/command', deviceId)
    .then(
      function(url) {
        return this._sendRequest('POST', url, {command: _payload});
      }.bind(this)
    )
    .then(this._awaitResponseWithAck);
};

/**
 * Sends a connect command to the service.
 *
 * @param {string} endpoint The command endpoint name.
 * @param {string} deviceId The target device id.
 * @param {Object?} payload The optional payload for the command.
 * @return {Promise.<boolean>} A promise that will be resolved with a boolean
 *     value indicating whether the command was successfully triggered.
 */
PlayerAPIClient.prototype._sendConnectCommand = function(
  endpoint,
  deviceId,
  payload
) {
  var method = endpoint === 'volume' ? 'PUT' : 'POST';
  return this._makeEndpoint('v1', 'connect/' + endpoint, deviceId)
    .then(
      function(url) {
        return this._sendRequest(method, url, payload || {});
      }.bind(this)
    )
    .then(this._awaitResponseWithAck);
};

/**
 * Sends a request to the Connect Controller service.
 *
 * @param {string} method The method of the request.
 * @param {string} url The URL path.
 * @param {Object} payload The payload to send for the request.
 * @return {Promise.<HTTPResponse>} The response for the request.
 * @protected
 */
PlayerAPIClient.prototype._sendRequest = function(method, url, payload) {
  // When we start a request, we create an object that will serve as a map of
  // all of the commands acknowledged via state updates while the request is in
  // flight. This solves the racy behaviour where a command might be
  // acknowledged before we actually know the ID of the command (which we get
  // as a response to the command).
  var acknowledgementMaps = this._acknowledgementMaps;
  var map = {};
  acknowledgementMaps.push(map);

  var removeMap = function() {
    var index = acknowledgementMaps.indexOf(map);
    if (index !== -1) {
      acknowledgementMaps.splice(index, 1);
    }
  };

  return this._transport
    .request(url, {
      method: method,
      payload: payload ? JSON.stringify(payload) : undefined,
      responseType: 'json',
      retry: {
        condition: function(response, StatusFamily) {
          var family = response.getStatusFamily();
          return family === StatusFamily.SERVER_ERROR ||
            family === StatusFamily.CONNECTION_ERROR;
        }
      }
    })
    .then(
      function(response) {
        // Append the acknowledged command as part of the response,
        // and then remove it from the array.
        response.map = map;
        removeMap();
        return response;
      },
      function(e) {
        removeMap();
        return Promise.reject(e);
      }
    );
};

/**
 * Parses the response of the request and makes it wait if necessary.
 *
 * @param {module:spotify-transport/types.Response} response The response to
 *     parse.
 * @return {Promise.<boolean>} The promise.
 * @protected
 */
PlayerAPIClient.prototype._awaitResponseWithAck = function(response) {
  if (response.status === 404) {
    return Promise.reject(
      new PlayerAPIClientError(
        Errors.CONNECTAPI_CLIENT_NO_DEVICE,
        'No such device.'
      )
    );
  } else if (response.status === 200 && response.body && response.body.ack_id) {
    var id = response.body.ack_id;
    if (response.map && response.map[id]) {
      return Promise.resolve(true);
    }
    var deferred = Promise.defer();
    this._awaitingAcknowledgment[id] = deferred;
    return deferred.promise;
  }
  return Promise.resolve(response.status === 200);
};

/**
 * Parses a Connect State Cluster object.
 *
 * @param {Object} cluster The Cluster object from the Connect State service.
 * @protected
 */
PlayerAPIClient.prototype._parseCluster = function(cluster) {
  if (!cluster) {
    return;
  }

  var clusterTimestamp = parseInt(cluster.timestamp, 10);
  if (this._lastProcessedTimestamp > clusterTimestamp) {
    // Stale data, do not process.
    return;
  }

  this._lastProcessedTimestamp = clusterTimestamp;
  this._parseClusterDevices(cluster);
  this._parseClusterPlayerState(cluster);
};

/**
 * Parses the devices map from a Cluster object.
 *
 * @param {Object} cluster The Cluster object from the Connect State service.
 * @protected
 */
PlayerAPIClient.prototype._parseClusterDevices = function(cluster) {
  var prevActiveDevice = this._lastActiveDevice;
  // var prevDeviceList = this._lastKnownDevices;

  // Reset
  this._lastActiveDevice = null;
  this._lastKnownDevices = [];
  this._localDevice = null;

  var deviceIds = [];
  for (var deviceId in cluster.devices) {
    if (cluster.devices.hasOwnProperty(deviceId)) {
      deviceIds.push(deviceId);
    }
  }

  // Note that we sort the device ids in order to prepare for a possible future
  // change where we will compare each device id before emitting the devices
  // list change event.
  deviceIds.sort();

  if (deviceIds.length) {
    var activeDeviceId = cluster.active_device_id;
    for (var i = 0, l = deviceIds.length; i < l; i++) {
      var device = cluster.devices[deviceIds[i]];
      var formattedDevice = this._formatClusterDevice(device, activeDeviceId);
      this._lastKnownDevices.push(formattedDevice);
      if (formattedDevice.is_active) {
        this._lastActiveDevice = formattedDevice;
      }
      if (formattedDevice.local) {
        this._localDevice = formattedDevice;
      }
    }
  }

  if (
    !this._fetchedInitialState ||
    !areDevicesEqual(this._lastActiveDevice, prevActiveDevice)
  ) {
    var playerState = cluster.player_state;
    var hasNonAdPlayerState = playerState &&
      playerState.track &&
      !currentTrackIsAd(playerState);

    this.emit(Event.CONNECT_API_DEVICE_STATE_CHANGED, {
      deviceState: this._lastActiveDevice,
      hasOrphanedState: !this._lastActiveDevice && hasNonAdPlayerState,
      disappeared: !!prevActiveDevice && !this._lastActiveDevice
    });
  }

  this.emit(Event.CONNECT_API_DEVICES_CHANGED, {
    devices: this._lastKnownDevices,
    localDevice: this._localDevice
  });
};

/**
 * Formats an individual DeviceInfo object from the cluster into a DeviceInfo
 * object for Harmony.
 *
 * @param {Object} device The Cluster DeviceInfo object.
 * @param {string} activeDeviceId The device id of the active device according
 *     to the Cluster.
 * @return {module:spotify-harmony/_internal/types.DeviceInfo} The formatted
 *     DeviceInfo object.
 * @protected
 */
PlayerAPIClient.prototype._formatClusterDevice = function(
  device,
  activeDeviceId
) {
  var deviceMetadata = {};
  // Parse device metadata
  if (device && Array.isArray(device.metadata)) {
    for (var i = 0, l = device.metadata.length; i < l; i++) {
      var metadata = device.metadata[i];
      deviceMetadata[metadata.type] = metadata.metadata;
    }
  }

  var capabilities = device.capabilities || {};

  var deviceInfo = {
    hidden: false,
    id: device.device_id,
    is_active: device.device_id === activeDeviceId,
    is_controllable: !!capabilities.is_controllable,
    is_observable: !!capabilities.is_observable,
    local: device.device_id === this._localDeviceId,
    metadata: deviceMetadata,
    name: device.name,
    type: (device.device_type || 'unknown').toLowerCase(),
    version: device.device_software_version,
    volume: capabilities.disable_volume ? -1 : device.volume / GAIA_VOLUME
  };

  return deviceInfo;
};

/**
 * Parses the player_state from a Cluster object.
 *
 * @param {Object} cluster The Cluster object from the Connect State service.
 * @protected
 */
PlayerAPIClient.prototype._parseClusterPlayerState = function(cluster) {
  this._lastKnownPlayerState = null;

  var activeDeviceId = cluster.active_device_id;
  var activeDevice = activeDeviceId && cluster.devices[activeDeviceId];

  var playerState = cluster.player_state;
  if (
    playerState &&
    playerState.track
  ) {
    if (
      activeDevice &&
      activeDevice.capabilities &&
      !activeDevice.capabilities.is_observable
    ) {
      playerState = null;
    } else {
      // Due to protobuf-to-json translation, some of the fields are encoded as
      // strings instead of numbers. We therefore need to cast them before hand.

      // If there is no active device, we should mark the player state as not
      // playing.
      if (!activeDevice) {
        playerState.is_paused = true;
        if (playerState.restrictions) {
          delete playerState.restrictions.disallow_resuming_reasons;
          playerState.restrictions.disallow_pausing_reasons = [
            'already_paused'
          ];
        }
      }

      playerState.duration = parseInt(playerState.duration, 10);
      playerState.position = parseInt(playerState.position, 10);
      playerState.position_as_of_timestamp = parseInt(
        playerState.position_as_of_timestamp,
        10
      );
      playerState.timestamp = parseInt(playerState.timestamp, 10);
      playerState.next_tracks = playerState.next_tracks || [];
      playerState.prev_tracks = playerState.prev_tracks || [];
    }

    this._lastKnownPlayerState = playerState;
  }

  var isOrphaned = !activeDevice && !!this._lastKnownPlayerState;
  if (
    isOrphaned &&
    playerState &&
    currentTrackIsAd(playerState)
  ) {
    // We want to ignore orphaned ads states.
    this._lastKnownPlayerState = null;
    isOrphaned = false;
  }

  this.emit(Event.CONNECT_API_PLAYER_STATE_CHANGED, {
    playerState: this._lastKnownPlayerState,
    orphaned: isOrphaned
  });
};

/**
 * Registers the PlayerAPIClient to the service in order to get state updates.
 *
 * @return {Promise.<boolean>} A promise that will be resolved when the client
 *     registeres successfully.
 * @protected
 */
PlayerAPIClient.prototype._register = function() {
  this._fetchedInitialState = false;
  var uri = this._endpoint + '/v1/devices/' + this._localObserverDeviceId;
  var payload = {
    member_type: 'CONNECT_STATE',
    device: {
      device_info: {
        capabilities: {
          can_be_player: false,
          hidden: true
        }
      }
    }
  };
  return this._transport.request(uri, {
    method: 'PUT',
    headers: {
      'X-Spotify-Connection-Id': this._connectionId,
      'Accept': 'application/json'
    },
    payload: JSON.stringify(payload),
    responseType: 'json'
  })
    .then(function(response) {
      if (response.status === 429) {
        this.emit(Event.CONNECT_API_MAX_SUBSCRIPTIONS_REACHED, {
          error: new PlayerAPIClientError(
            Errors.CONNECTAPI_MAX_SUBSCRIPTIONS_REACHED,
            'Max connections reached'
          )
        });
      } else if (response.status === 200) {
        this.emit(Event.CONNECT_API_REGISTERED);
        if (response.body) {
          this._parseCluster(response.body);
          this._fetchedInitialState = true;
        }
      }
    }.bind(this));
};

/**
 * Registers the PlayerAPIClient to the service in order to get state updates.
 *
 * @return {Promise.<boolean>} A promise that will be resolved when the client
 *     registeres successfully.
 */
PlayerAPIClient.prototype.register = function() {
  if (!this._connectionId) {
    return Promise.reject(
      new PlayerAPIClientError(
        Errors.CONNECTAPI_CLIENT_NO_CONNECTION_ID,
        'Cannot register: no connection id.'
      )
    );
  }
  return this._descriptorPromise.then(this._register.bind(this));
};

/**
 * Deregisters the client from the service.
 *
 * @return {Promise.<boolean>} A promise that will be resolved once the client
 *     has successfully deregistered.
 */
PlayerAPIClient.prototype.deregister = function() {
  var uri = this._endpoint + '/v1/devices/' + this._localObserverDeviceId;
  return this._transport.request(uri, {
    method: 'DELETE',
    responseType: 'json'
  })
    .then(function(response) {
      if (response.status === 200) {
        this.emit(Event.CONNECT_API_DEREGISTERED);
      }
    }.bind(this));
};

/**
 * Returns a list of devices for the current user.
 *
 * @return {Promise.<Array.<module:spotify-playerapi-client/types.DeviceState>>}
 *     The formatted list of devices.
 */
PlayerAPIClient.prototype.getDevices = function() {
  if (!this._fetchedInitialState) {
    return new Promise(function(resolve) {
      this.once(Event.CONNECT_API_DEVICE_STATE_CHANGED, function() {
        resolve({
          devices: this._lastKnownDevices,
          localDevice: this._localDevice
        });
      });
    }.bind(this));
  }
  return Promise.resolve({
    devices: this._lastKnownDevices,
    localDevice: this._localDevice
  });
};

/**
 * Returns the DeviceState for the last active device.
 *
 * @return {Promise.<module:spotify-playerapi-client/types.DeviceState>} The
 *     last active device.
 */
PlayerAPIClient.prototype.getActiveDevice = function() {
  if (!this._fetchedInitialState) {
    return new Promise(function(resolve) {
      this.once(Event.CONNECT_API_DEVICE_STATE_CHANGED, function(e) {
        resolve(e.deviceState);
      });
    }.bind(this));
  }
  return Promise.resolve(this._lastActiveDevice);
};

/**
 * Returns the last ContextPlayerState.
 *
 * @return {Promise.<module:spotify-playerapi-client/types.ContextPlayerState>}
 *     The last ContextPlayerState.
 */
PlayerAPIClient.prototype.getContextPlayerState = function() {
  if (!this._fetchedInitialState) {
    return new Promise(function(resolve) {
      this.once(Event.CONNECT_API_PLAYER_STATE_CHANGED, function(e) {
        resolve(e.playerState);
      });
    }.bind(this));
  }
  return Promise.resolve(this._lastKnownPlayerState);
};

/**
 * Plays a ContextDescriptor
 *
 * @param {module:spotify-playerapi-client/types.ContextDescriptor} descriptor
 *     The descriptor to play.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.play = function(descriptor, deviceId) {
  if (!descriptor) {
    return Promise.reject(
      new PlayerAPIClientError(
        Errors.CONNECTAPI_CLIENT_INVALID_ARGUMENTS,
        'Descriptor is required for play commands'
      )
    );
  }
  return this._sendPlayerCommand('play', deviceId, descriptor);
};

/**
 * Triggers the target device id to update its context.
 *
 * @param {string} deviceId The target device id.
 * @param {Object} options The options for update.
 * @return {Promise.<boolean>} True if the device was updated, false otherwise.
 */
PlayerAPIClient.prototype.updateCurrentContext = function(deviceId, options) {
  var _options = options || {};
  return this.getContextPlayerState()
    .then(function(state) {
      if (!state) {
        return Promise.reject(
          new PlayerAPIClientError(
            Errors.CONNECTAPI_CLIENT_NO_STATE,
            'Nothing playing'
          )
        );
      }
      if (!state.session_id) {
        return Promise.reject(
          new PlayerAPIClientError(
            Errors.CONNECTAPI_CLIENT_NO_SESSION_ID,
            'The current state does not have a session id'
          )
        );
      }

      if (!state.context_url && !_options.forceNonUpdateable) {
        // If there is no context_url, the context was probably resolved by
        // the origin of the context rather than by the backend. In which case,
        // calls to update the context would most likely result in a weird
        // state. Disable this behaviour unless the user chose to do it.
        return Promise.resolve(false);
      }

      return this._sendPlayerCommand('update_context', deviceId, {
        context: {
          url: state.context_url || 'context://' + state.context_uri
        },
        session_id: state.session_id
      });
    }.bind(this));
};

/**
 * Sets the Player queue.
 *
 * @param {module:spotify-playerapi-client/types.QueueDescriptor} queue The
 *     queue to set.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.setQueue = function(queue, deviceId) {
  return this._sendPlayerCommand('set_queue', deviceId, queue);
};

/**
 * Toggles the playback state of the device.
 *
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.togglePlay = function(deviceId) {
  return this.getContextPlayerState().then(
    function(state) {
      if (!state) {
        return Promise.reject(
          new PlayerAPIClientError(
            Errors.CONNECTAPI_CLIENT_NO_STATE,
            'Nothing playing'
          )
        );
      }
      return state.is_paused ? this.resume(deviceId) : this.pause(deviceId);
    }.bind(this)
  );
};

/**
 * Transfers the playback from the current active device to a target device.
 *
 * @param {string=} deviceId The target device id. If omitted, the local device
 *     id is used.
 * @param {module:spotify-playerapi-client/types.TransferOptions} options The
 *     options for transfer.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.transfer = function(deviceId, options) {
  var payload = {
    transfer_options: {
      restore_paused: 'restore'
    }
  };
  if (options && 'initially_paused' in options) {
    payload.transfer_options.restore_paused = options.initially_paused ?
      'pause' :
      'resume';
  }
  return this._sendConnectCommand('transfer', deviceId || '@local', payload);
};

/**
 * Pauses the current playback on the target device.
 *
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.pause = function(deviceId) {
  return this._sendPlayerCommand('pause', deviceId);
};

/**
 * Resumes the current playback on the target device.
 *
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.resume = function(deviceId) {
  return this._sendPlayerCommand('resume', deviceId);
};

/**
 * Skips the playback of the target device to the next track.
 *
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.nextTrack = function(deviceId) {
  return this._sendPlayerCommand('skip_next', deviceId);
};

/**
 * Skips the playback of the target device to the previous track.
 *
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.previousTrack = function(deviceId) {
  return this._sendPlayerCommand('skip_prev', deviceId);
};

/**
 * Changes the track position of the currently playing track of the target
 * device.
 *
 * @param {number} position The new position in milliseconds.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.seek = function(position, deviceId) {
  if (isNaN(position) || position < 0) {
    return Promise.reject(
      new PlayerAPIClientError(
        Errors.CONNECT_API_CLIENT_INVALID_POSITION,
        'Invalid position.'
      )
    );
  }
  return this._sendPlayerCommand('seek_to', deviceId, {value: position});
};

/**
 * Sets the shuffle mode of the current track.
 *
 * @param {boolean} shuffle When set to true, the context will be played
 *     shuffled.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.setShuffle = function(shuffle, deviceId) {
  return this._sendPlayerCommand(
    'set_shuffling_context',
    deviceId,
    {value: !!shuffle}
  );
};

PlayerAPIClient.prototype.toggleShuffle = function(deviceId) {
  return this.getContextPlayerState()
    .then(function(state) {
      if (!state) {
        return Promise.reject(
          new PlayerAPIClientError(
            Errors.CONNECTAPI_CLIENT_NO_STATE,
            'Nothing playing'
          )
        );
      }
      var isShuffled = state.options && state.options.shuffling_context;
      return this.setShuffle(!isShuffled, deviceId);
    }.bind(this));
};

/**
 * Sets the repeating context mode of the current track.
 *
 * @param {boolean} value When set to true, the context will be played on
 *     repeat, playing the first track at the end of the context.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.setRepeatingContext = function(value, deviceId) {
  return this._sendPlayerCommand(
    'set_repeating_context',
    deviceId,
    {value: !!value}
  );
};

/**
 * Sets the repeating track mode of the current track.
 *
 * @param {boolean} value When set to true, tracks will be played on repeat
 *     mode, replayuing the same track after it has ended.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.setRepeatingTrack = function(value, deviceId) {
  return this._sendPlayerCommand(
    'set_repeating_track',
    deviceId,
    {value: !!value}
  );
};

/**
 * Sets the volume of the target device.
 *
 * @param {number} volume The volume as a number from 0 to 1.0.
 * @param {string=} deviceId The target device id. If omitted, the last active
 *     device id is used.
 * @return {Promise.<boolean>} True if the operation was sent successfully.
 */
PlayerAPIClient.prototype.setVolume = function(volume, deviceId) {
  if (isNaN(volume) || volume < 0) {
    return Promise.reject(
      new PlayerAPIClientError(
        Errors.CONNECT_API_CLIENT_INVALID_VOLUME,
        'Invalid volume.'
      )
    );
  }
  // Gaia volume needs to be an int, so we need to round it.
  var gaiaVolume = Math.round(volume * GAIA_VOLUME);
  // var gaiaVolume = (volume * GAIA_VOLUME);
  return this._sendConnectCommand('volume', deviceId, {volume: gaiaVolume});
};

module.exports = PlayerAPIClient;
