'use strict';

var Promise = require('spotify-promise-plus');
var endpointsProvider =
  require('spotify-transport/providers/endpoints/xresolve');
var createTransport = require('./utils/create_transport');
var HarmonyClient = require('./_internal/lib/client');

var VALID_DEVICE_ID_EXP = /^[a-zA-Z0-9_%:-]{1,40}$/;

module.exports = {
  create: function(options) {
    if (!options) {
      throw new TypeError('Argument `options` is not defined.');
    }

    // Descriptor test
    if (
      options.descriptor &&
      options.descriptor.id &&
      !VALID_DEVICE_ID_EXP.test(options.descriptor.id)
    ) {
      throw new TypeError('Invalid device id.');
    }

    var ownerRef = {};
    var transport;
    var allowLifecycleManagement;
    if (options.transport) {
      // User provided their own transport; use that.
      transport = options.transport;
      allowLifecycleManagement = !!options.allowLifecycleManagement;
    } else {
      // Create a transport instance.
      if (typeof options.getToken !== 'function') {
        throw new TypeError('Argument options.getToken must be a function');
      }
      var provider = endpointsProvider(options.xresolve);
      transport = createTransport({
        ownerRef: ownerRef,
        providers: {
          endpoints: function(publicTransport) {
            return provider(publicTransport).then(function(endpoints) {
              var override = options.endpoints;
              if (override) {
                for (var key in override) {
                  if (override.hasOwnProperty(key) && override[key]) {
                    endpoints[key] = override[key];
                  }
                }
              }
              return endpoints;
            });
          },
          token: function() {
            return new Promise(function(resolve) {
              options.getToken(function(token, optTTL) {
                if (typeof optTTL !== 'undefined') {
                  resolve([token, optTTL]);
                  return;
                }
                resolve(token);
              });
            });
          }
        },
        requestMode: options.requestMode || 'fetch',
        reconnectionRetries: options.reconnectionRetries,
        forcePolyfillTypes: options.forcePolyfillTypes
      });
      allowLifecycleManagement = true;
    }

    return HarmonyClient.create({
      transport: transport,
      ownerRef: ownerRef,
      allowLifecycleManagement: allowLifecycleManagement,
      descriptor: options.descriptor,
      playTokenLostBehavior: options.playTokenLostBehavior,
      hidden: options.hidden
    });
  }
};
