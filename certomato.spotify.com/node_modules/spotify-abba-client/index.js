'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');

/**
 * The default service endpoint to use.
 *
 * @const
 * @private
 */
var DEFAULT_ENDPOINT = 'https://@webapi/v1/me/feature-flags';

/**
 * @name module:spotify-abba-client~ABBAClientOptions
 * @typedef Object
 * @property {string} endpoint The ABBA service endpoint to use. Defaults to
 *     'https://@webapi/v1/me/feature-flags'.
 */

/**
 * An ABBA Service client.
 *
 * @constructor
 * @param {module:spotify-transport} session A transport session.
 * @param {module:spotify-abba-client~ABBAClientOptions}  options The options
 *     for this instance.
 * @exports module:spotify-abba-client
 */
function ABBAClient(session, options) {
  EventEmitter.call(this);
  var _options = options || {};

  /**
   * The session object.
   *
   * @type {module:spotify-transport}
   * @protected
   */
  this._session = session;

  /**
   * The endpoint to use for this client instance.
   *
   * @type {string}
   * @protected
   */
  this._endpoint = _options.endpoint || DEFAULT_ENDPOINT;

  /**
   * A deferred Promise used to determine whether the user is authenticated.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._authenticated = Promise.defer();

  /**
   * A deferred Promise used to determine if the requests have been completed.
   * @type {Promise.Deferred}
   * @protected
   */
  this._dataDeferred = Promise.defer();

  /**
   * A map of the flags.
   *
   * @type {Object.<String, String>}
   * @protected
   */
  this._flagMap = {};

  this._init();
}
inherit(ABBAClient, EventEmitter);

/**
 * Creates a new instance of the ABBAClient.
 *
 * @param {module:spotify-transport} session A transport session.
 * @param {module:spotify-abba-client~ABBAClientOptions}  options The options
 *     for this instance.
 * @return {module:spotify-abba-client} An instance of the ABBAClient.
 */
ABBAClient.forSession = function(session, options) {
  return new ABBAClient(session, options);
};

/**
 * Initializes the instance
 *
 * @protected
 */
ABBAClient.prototype._init = function() {
  this._session.on(
    'authenticated',
    function() {
      this._authenticated.resolve(true);
    }.bind(this)
  );
};

/**
 * Sends a request to the ABBA service endpoint to fetch the flags for the
 * current logged-in user.
 *
 * @param {Array.<string>} featureNames
 *
 * @return {module:spotify-transport/types.SessionResponse} The response from
 *     the service.
 * @protected
 */
ABBAClient.prototype._fetchData = function(featureNames) {
  var allFlagsCached = featureNames.every(function(flag) {
    return (flag in this._flagMap);
  }.bind(this));

  if (allFlagsCached) {
    // All features have already been fetched, use the cache
    return Promise.resolve(true);
  }

  var previousDeferred = this._dataDeferred;
  this._dataDeferred = Promise.defer();
  this._dataDeferred.promise.then(
    previousDeferred.resolve,
    previousDeferred.reject
  );

  var url = this._endpoint + '?tests=' + featureNames.join(',');
  return this._session
    .request(url, {
      authorize: true,
      responseType: 'json'
    })
    .then(this._parseData.bind(this))
    .catch(function(e) {
      this.emit('error', {
        name: 'abbaError',
        error: e
      });
      // We still want to ensure that the data is here,
      // since we don't want things to hang.
      this._dataDeferred.resolve(false);

      return false;
    }.bind(this));
};

/**
 * Parses the response from the ABBA service endpoint into a map.
 *
 * @param {module:spotify-transport/types.SessionResponse} response The response
 *     from the service to parse.
 * @return {boolean}
 *
 * @protected
 */
ABBAClient.prototype._parseData = function(response) {
  var body = response.body;
  if (response.status !== 200) {
    throw new Error(
      'Request to abba-service failed with status code ' + response.status
    );
  }
  if (!body) {
    throw new Error('Unexpected empty response from abba service.');
  }
  if (!body.flags) {
    throw new Error('Unexpected response format from abba service.');
  }

  Object.keys(body.flags).forEach(
    function(key) {
      this._flagMap[key] = body.flags[key];
    }.bind(this)
  );

  this._dataDeferred.resolve(true);

  return true;
};

/**
 * Returns the cell for a given feature flag.
 *
 * @param {string} featureName The name of the feature.
 * @return {Promise.<Object>} A Promise that is resolved to the cell for
 *     the given featureName.
 */
ABBAClient.prototype.getCell = function(featureName) {
  return this.getCells([featureName]).then(function(cells) {
    return cells[featureName];
  });
};

/**
 * Returns the cells for the given feature flags
 *
 * @param {Array.string} featureNames The names of the features.
 * @return {Promise.<Object>} A Promise that is resolved to a map containg
 *     flags as keys and cells as values
 */
ABBAClient.prototype.getCells = function(featureNames) {
  return this._authenticated.promise
    .then(this._fetchData.bind(this, featureNames))
    .then(function(hasData) {
      var cells = {};
      for (var i = 0; i < featureNames.length; i++) {
        var featureName = featureNames[i];
        cells[featureName] = {
          value: this._flagMap[featureName] || null,
          exists: featureName in this._flagMap,
          featureName: featureName,
          fromAbba: hasData
        };
      }

      return cells;
    }.bind(this));
};

module.exports = ABBAClient;
