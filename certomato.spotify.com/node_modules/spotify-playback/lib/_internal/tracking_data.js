'use strict';

var TrackingError = require('../../lib/tracking_error');
var DataValue = require('../../types/data_value');
var Errors = require('../../types/errors');
var CDNURLTracker = require('./cdn_url_tracker');

var KeySystem = require('../../types/keysystem');

var UNSET_BITRATE_LABEL = 'dummy';

/**
 * The tracker data for a track.
 */
function TrackingData() {
  /**
   * The Bitrates for individual segments of the current track.
   *
   * @protected
   */
  this._bitrates = {};

  /**
   * A flag that indicates whether the data has been finalized.
   *
   * @type {boolean}
   * @protected
   */
  this._isFinalized = false;

  /**
   * A flag that indicates whether an 'end' PlaySegment is needed.
   *
   * @type {boolean}
   * @protected
   */
  this._needsEndSegment = false;

  /**
   * The PlaySegments for the currently playing track.
   *
   * @type {Array.<module:spotify-playback/lib/tracker~PlaySegment>}
   * @protected
   */
  this._segments = [];

  /**
   * An instance of CDNURLTracker that will be used to keep track of the
   * CDN URLs that are used during playback.
   *
   * @type {module:spotify-playback/lib/_internal/cdn_url_tracker}
   * @protected
   */
  this._cdnURLTracker = new CDNURLTracker();

  /**
   * The codec of the tracks played by the player.
   *
   * @type {string}
   */
  this.audiocodec = null;

  /**
   * The bitrate amount of the tracks played by the player.
   *
   * @type {number}
   */
  this.bitrate = 160000;

  /**
   * The amount of relative time the user spent rebuffering this video compared
   *     with playing it.
   *
   * @type {number}
   */
  this.bufferingPercentage = null;

  /**
   * The timestamp of when the first bytes of the file where asked to be loaded.
   * this will be used to calculate the latency numbers for msInitLatency and
   * msHeadLatency
   *
   * @type {number}
   */
  this.bufferLoadStartTime = 0;

  /**
   * An array containing all (including fallbacks) urls from the storage/video
   * resolver.
   *
   * @type {Array.<string>}
   */
  this.urls = {};

  /**
   * The URI of the current track being played by the monitored player.
   *
   * @type {string}
   */
  this.currentTrackUri = DataValue.EMPTY;

  /**
   * The URI of the track being displayed as "playing" by the player.
   *
   * In cases of alternates, this URI can differ from the actual playing track.
   *
   * @type {string}
   */
  this.displayTrack = DataValue.EMPTY;

  /**
   * @type {number}
   */
  this.externalLoadTime = 0;

  /**
   * The fileId of the current track.
   *
   * @type {string}
   */
  this.fileId = '';

  /**
   * The device id for connect.
   *
   * @type {string}
   */
  this.gaiaDevId = 'none';

  /**
   * True if playback of a track encountered a playback error.
   *
   * @type {boolean}
   */
  this.hadError = false;

  /**
   * The internal playid for a track.
   *
   * @type {string}
   */
  this.internalPlayId = '';

  /**
   * True if the file for the track is encrypted.
   *
   * @type {boolean}
   */
  this.isProtected = false;

  /**
   * The DRM key system of the current track.
   *
   * @type {string}
   */
  this.keySystem = '';

  /**
   * The keysystem implemenation description.
   *
   * @type {string}
   */
  this.keySystemImpl = '';

  /**
   * The timestamp of the last time the player started playing.
   *
   * @type {number}
   */
  this.lastPlayStartTime = 0;

  /**
   * The timestamp of when the player has received the request to load the
   * track.
   *
   * @type {number}
   */
  this.loadTime = 0;

  /**
   * The local time at which playback was initiated (Unix timestamp in
   *     milliseconds)
   *
   * @type {number}
   */
  this.localTimeMs = -1;

  /**
   * The maximum time of continuous playback for the current track, in
   * milliseconds.
   *
   * @type {number}
   */
  this.maxContinuous = 0;

  /**
   * Maximum time spent re-buffering from a single seek.
   *
   * @type {number}
   */
  this.maxMsSeekRebuffering = 0;

  /**
   * Maximum time stalled from a single stall.
   *
   * @type {number}
   */
  this.maxMsStalled = 0;

  /**
   * True if the playing ACMETrack was cached.
   *
   * @type {boolean}
   */
  this.memoryCached = false;

  /**
   * Duration in milliseconds.
   *
   * @type {number}
   */
  this.msActualDuration = 0;

  /**
   * Duration calculated from number of samples over sample rate for a specific
   * file.
   *
   * @type {number}
   */
  this.msFileDuration = 0;

  /**
   * Time spent on the request for the head fragment for a file.
   *
   * @type {number}
   */
  this.msHeadLatency = 0;

  /**
   * Time between first segment load and first frame ready to play in
   *     milliseconds
   *
   * @type {number}
   */
  this.msInitLatency = 0;

  /**
   * Key latency.
   *
   * @type {number}
   */
  this.msKeyLatency = 0;

  /**
   * Time spent generating the license.
   *
   * @type {number}
   */
  this.msLicenseGenerationLatency = 0;

  /**
   * Time spent requesting the license.
   *
   * @type {number}
   */
  this.msLicenseRequestLatency = 0;

  /**
   * Time spent creating the license session.
   *
   * @type {number}
   */
  this.msLicenseSessionLatency = 0;

  /**
   * Time spent updating the license.
   *
   * @type {number}
   */
  this.msLicenseUpdateLatency = 0;

  /**
   * The time in milliseconds spent fetching the track manifest.
   *
   * @type {number}
   */
  this.msManifestLatency = 0;

  /**
   * The total time of playback for the current track, in milliseconds.
   *
   * @type {number}
   */
  this.msPlayed = 0;

  /**
   * The union time of playback for the current track, in milliseconds.
   *
   * @type {number}
   */
  this.msPlayedUnion = 0;

  /**
   * The latency between the start of the play-request and the time when the
   * music started playing, in milliseconds.
   *
   * @type {number}
   */
  this.msPlayLatency = 0;

  /**
   * Time spent resolving a file url.
   *
   * @type {number}
   */
  this.msResolveLatency = 0;

  /**
   * Total time spent re-buffering from a seek in milliseconds
   *
   * @type {number}
   */
  this.msSeekRebuffering = 0;

  /**
   * The total amount seeked backwards in milliseconds.
   *
   * @type {number}
   */
  this.msSeeksBackward = 0;

  /**
   * The total amount seeked forwards in milliseconds.
   *
   * @type {number}
   */
  this.msSeeksForward = 0;

  /**
   * The next upcoming playbackId.
   *
   * @type {string}
   */
  this.nextPlaybackId = '';

  /**
   * Number of offline events during the playback of a track.
   *
   * @type {number}
   */
  this.nOffline = 0;

  /**
   * If set to true, this data should not be logged.
   *
   * @type {boolean}
   */
  this.noLog = false;

  /**
   * If set to true, this data should not log a TSV.
   *
   * @type {boolean}
   */
  this.noTSV = false;

  /**
   * If set to true, this data should not log PlaybackStats.
   *
   * @type {boolean}
   */
  this.noStats = false;

  /**
   * Number of warnings during the playback of a track.
   *
   * @type {number}
   */
  this.nWarnings = 0;

  /**
   * Total time where playback stalled in milliseconds (excluding initial
   *     buffering and seek rebuffering).
   *
   * @type {number}
   */
  this.msStalled = 0;

  /**
   * The number of times the current track has been seeked to backwards.
   *
   * @type {number}
   */
  this.nSeeksBackward = 0;

  /**
   * The number of times the current track has been seeked to forwards.
   *
   * @type {number}
   */
  this.nSeeksForward = 0;

  /**
   * Number of stalls.
   *
   * @type {number}
   */
  this.nStalls = 0;

  /**
   * True if persistent cache is used.
   *
   * @type {boolean}
   */
  this.persistentCached = false;

  /**
   * @type {string}
   */
  this.playbackId = '';

  /**
   * The URI of the context where the track is playing from.
   *
   * @type {string}
   */
  this.playContext = DataValue.EMPTY;

  /**
   * Boolean flag that tracks whether the track was actually played.
   *
   * @type {boolean}
   */
  this.played = false;

  /**
   * The position of the currently playing track in milliseconds
   *
   * @type {number}
   */
  this.position = 0;

  /**
   * The "reason" why the current track was ended.
   *
   * @type {string}
   */
  this.reasonEnd = DataValue.UNKNOWN;

  /**
   * The "reason" why the current track was started.
   *
   * @type {string}
   */
  this.reasonStart = DataValue.UNKNOWN;

  /**
   * The referrer of the current playback context, usually as an app URI.
   *
   * @type {string}
   */
  this.referrer = DataValue.UNKNOWN;

  /**
   * The vendor of the referrer.
   *
   * @type {string}
   */
  this.referrerVendor = DataValue.UNKNOWN;

  /**
   * The version string of the referrer.
   *
   * @type {string}
   */
  this.referrerVersion = DataValue.UNKNOWN;

  /**
   * The source of the current playing context that ended the playback of
   * the current track.
   *
   * @type {string}
   */
  this.sourceEnd = DataValue.UNKNOWN;

  /**
   * The source of the current playing context that started the current track.
   *
   * @type {string}
   */
  this.sourceStart = DataValue.UNKNOWN;

  /**
   * The Bitrates for the first downloaded segment of the current track.
   *
   * @type {?number=}
   */
  this.startBitrate = null;

  /**
   * The offset at which the video started playing in milliseconds.
   *
   * @type {number}
   */
  this.startPosition = 0;

  /**
   * The timestamp at which the track was stopped.
   *
   * @type {number}
   */
  this.stopTime = 0;

  /**
   * Streaming rule for this track.
   *
   * @type {string}
   */
  this.streamingRule = 'none';

  /**
   * The value of ms played weighed against all of the bitrates played.
   *
   * @type {number}
   */
  this.timeWeightedBitrate = 0;

  /**
   * The total segment bytes downloaded.
   *
   * @type {number}
   */
  this.totalBytes = 0;

  /**
   * The codec used for video in the current track.
   *
   * @type {string}
   */
  this.videocodec = null;
}

/**
 *
 * @static
 * @return {TrackingData}
 */
TrackingData.create = function() {
  return new TrackingData();
};

/**
 * Calculates the union played ms for a track.
 *     Also sets maxContinuous on the tracking data instance.
 *
 * @return {number}
 * @protected
 */
TrackingData.prototype._calculateUnion = function() {
  var segments = this._segments.slice(0);
  var union = 0;
  var count = 0;
  var start = 0;
  var i = 0;
  var l = 0;
  var currentResult = 0;
  // Calculates the max continuous playback
  var maxContinuous = this.maxContinuous;
  for (; l < segments.length; l++) {
    if (l % 2 !== 0) {
      if (typeof segments[l - 1] !== 'undefined') {
        if (segments[l - 1].type === 'start') {
          currentResult = segments[l].time - segments[l - 1].time;
          maxContinuous = currentResult > maxContinuous ?
            currentResult :
            maxContinuous;
        }
      }
    }
  }
  this.maxContinuous = maxContinuous;
  segments.sort(function(a, b) {
    return a.time - b.time;
  });
  for (; i < segments.length; i++) {
    if (segments[i].type === 'start') {
      if (count === 0) {
        start = i;
      }
      ++count;
    }
    if (segments[i].type === 'end') {
      --count;
      if (count === 0) {
        union += segments[i].time - segments[start].time;
      }
    }
  }
  return union;
};

/**
 * Calculates the value for 'weighted bitrate' on a track that has played
 *     more than one bitrate.
 *
 * @param {number} msPlayed The total number of played milliseconds.
 * @return {number}
 * @protected
 */
TrackingData.prototype._calculateWeightedBitrate = function(msPlayed) {
  var bitrates = this._bitrates;
  var timeWeightedBitrate = 0;
  for (var bitrate in bitrates) {
    if (
      bitrate !== UNSET_BITRATE_LABEL &&
      bitrates.hasOwnProperty(bitrate) &&
      msPlayed > 0) {
      timeWeightedBitrate +=
        parseInt(bitrate, 10) * bitrates[bitrate] / msPlayed;
    }
  }
  return Math.round(timeWeightedBitrate);
};

/**
 * Register the audio/video profiles, as well as the initial bitrate for a
 *     video track.
 *
 * @param {Object} data The data params for the bitrange.
 */
TrackingData.prototype.registerVideoVariant = function(data) {
  var bitrate = data.bitrate || UNSET_BITRATE_LABEL;
  this._bitrates[bitrate] = this._bitrates[bitrate] || 0;
  if (!this.startBitrate) {
    this.startBitrate = bitrate;
  }
  if (data.audioProfile && data.audioProfile.audio_codec) {
    this.audiocodec = data.audioProfile.audio_codec;
  }
  if (data.videoProfile && data.videoProfile.video_codec) {
    this.videocodec = data.videoProfile.video_codec;
  }
};

/**
 * Add a start segment.
 */
TrackingData.prototype.addStartSegment = function() {
  this._segments.push({type: 'start', time: this.position});
  this._needsEndSegment = true;
};

/**
 * Add an end segment.
 */
TrackingData.prototype.addEndSegment = function() {
  if (!this._needsEndSegment) {
    return;
  }
  this._segments.push({type: 'end', time: this.position});
  this._needsEndSegment = false;
};

/**
 * Append to the tracks milliseconds played.
 *
 * @param {number} value The number of milliseconds to append.
 */
TrackingData.prototype.addMSPlayed = function(value) {
  if (!value) {
    return;
  }
  this.msPlayed += value;
};

/**
 * Append milliseconds played for a specific bitrate.
 *
 * @param {number|string} label The bitrate represented by a number or string.
 * @param {number} value The number of milliseconds played.
 */
TrackingData.prototype.trackBitrate = function(label, value) {
  var bitrate = label || UNSET_BITRATE_LABEL;
  this._bitrates[bitrate] = this._bitrates[bitrate] || 0;
  this._bitrates[bitrate] += value;
};

TrackingData.prototype.trackBufferURL = function(url, data) {
  this._cdnURLTracker.track(url, data);
};

/**
 * Finalizes the tracking data.
 *
 * @return {boolean}
 */
TrackingData.prototype.finalize = function() {
  if (this._isFinalized) {
    throw new TrackingError(
      Errors.TRACK_DATA_ALREADY_FINALIZED,
      'TrackData already finalized.'
    );
  }
  this.msPlayedUnion = this._calculateUnion(this.msPlayed);
  // If we haven't seeked the ms played should be the same with the union and
  // the _max_continuous
  if (!this.nSeeksBackward && !this.nSeeksForward) {
    this.msPlayed = this.maxContinuous = this.msPlayedUnion;
  }
  this.timeWeightedBitrate = this._calculateWeightedBitrate(this.msPlayed);
  this.bufferingPercentage = this.msStalled / this.msPlayed;
  this.urls = this._cdnURLTracker.toJSON();
  this._isFinalized = true;
  return true;
};

/**
 * Return a formatted object with playback stats data..
 *
 * @return {Object}
 */
TrackingData.prototype.getPlaybackStats = function() {
  // EndVideo requires a specific keysystem string rather than the keysystem id.
  var keySystem;
  switch (this.keySystem) {
    case KeySystem.WIDEVINE:
      keySystem = 'widevine';
      break;

    case KeySystem.PLAYREADY:
    case KeySystem.PLAYREADY_HARDWARE:
      keySystem = 'playready';
      break;

    default:
      keySystem = 'none';
  }

  // We set falsy values to be undefined rather than null so that they can be
  // removed from the serialized JSON.
  return {
    ms_total_est: this.msActualDuration,
    ms_manifest_latency: this.msManifestLatency,
    ms_latency: this.msPlayLatency,
    start_offset_ms: this.startPosition,
    ms_initial_buffering: this.msPlayLatency, // FIXME: Double check
    ms_seek_rebuffering: this.msSeekRebuffering,
    ms_stalled: this.msStalled,
    max_ms_seek_rebuffering: this.maxMsSeekRebuffering,
    max_ms_stalled: this.maxMsStalled,
    n_stalls: this.nStalls,
    audiocodec: this.audiocodec ? this.audiocodec.toLowerCase() : undefined,
    videocodec: this.videocodec ? this.videocodec.toLowerCase() : undefined,
    start_bitrate: this.startBitrate || undefined,
    full_screen: undefined,
    time_weighted_bitrate: this.timeWeightedBitrate,
    buffering_percentage: undefined, // RemovedField
    prefetched_bytes: undefined,
    prefetched_bytes_loaded: undefined,
    prefetched_initial_bitrate: undefined, // RemovedField
    key_system: keySystem,
    ms_key_latency: this.msKeyLatency,
    total_bytes: this.totalBytes,
    local_time_ms: this.localTimeMs,
    ms_played_background: undefined
  };
};

/**
 * Getter for finalized status flag.
 *
 * @return {boolean}
 */
TrackingData.prototype.isFinalized = function() {
  return this._isFinalized;
};

module.exports = TrackingData;
