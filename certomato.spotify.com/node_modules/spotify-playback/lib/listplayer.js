'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');

var Errors = require('../types/errors');
var OperationResult = require('../types/operation_result');
var RepeatMode = require('../types/repeat_mode');
var ListConstants = require('../types/list_constants');
var Reason = require('../types/reason');
var Event = require('../types/event');

var PlaybackError = require('./playback_error');
var PlaybackOptions = require('./playback_options');

/**
 * The maximum value a sequence number can have.
 *
 * @type {number}
 * @private
 */
var MAX_SEQ_ID = 9007199254740991;

/**
 * The default number of errors before the list player stops progressing to the
 * next track.
 *
 * @constant
 * @private
 */
var DEFAULT_MAX_LIST_ERRORS = 5;

/**
 * A ListPlayer manages playing through "smartlists."
 *
 * @exports module:spotify-playback/lib/listplayer
 * @constructor
 * @param {module:spotify-playback/types.ListPlayerOptions} options The
 *     options for this instance of the ListPlayer.
 */
function ListPlayer(options) {
  var _options = options || {};
  if (!_options.trackPlayer) {
    throw new TypeError('Argument `options.trackPlayerManager` not found.');
  }

  /**
   * Used to ensure that the track player is present before any operations.
   *
   * @type {Promise.<module:spotify-playback/types.Player>}
   * @protected
   */
  this._trackPlayerPromise = Promise.defer();

  this._maxListErrors = _options.maxListErrors || DEFAULT_MAX_LIST_ERRORS;

  /**
   * An incrementing ID for the currently playing track.
   *
   * This value can be used to compare whether the tracks have changed.
   *
   * @type {number}
   * @protected
   */
  this._uid = 0;

  /**
   * The list that is loaded into the ListPlayer.
   *
   * All operations happen on this list.
   *
   * @type {module:spotify-playback/types.List}
   * @protected
   */
  this._loadedList = null;

  /**
   * The PlaybackOptions for the currently loaded list.
   *
   * @type {module:spotify-playback/types.PlaybackOptions}
   * @protected
   */
  this._loadedOptions = null;

  /**
   * The currently loaded track.
   *
   * @type {module:spotify-playback/types.Track}
   * @protected
   */
  this._currentTrack = null;

  /**
   * The calculated playback options for the current track.
   *
   * @type {module:spotify-placyback/types.TrackPlaybackOptions}
   * @protected
   */
  this._currentTrackOptions = null;

  /**
   * The amount of items played from the current list.
   *
   * @type {number}
   * @protected
   */
  this._listPlayCount = 0;

  /**
   * Number of times that the list has produced a playback error.
   *
   * @type {number}
   * @protected
   */
  this._listErrorCount = 0;

  /**
   * An internal flag denoting that the ListPlayer should shuffle all lists it
   * plays.
   *
   * @type {boolean}
   * @protected
   */
  this._shuffled = false;

  /**
   * An internal flag denoting the repeat mode of the ListPlayer.
   *
   * @type {module:spotify-playback/types.RepeatMode}
   * @protected
   */
  this._repeatMode = RepeatMode.NONE;

  /**
   * Used to keep track of asynchronous operations that span multiple execution
   * contexts.
   *
   * Note that this value should not be incremented directly. Use the method
   * _incrementSeqId() instead.
   *
   * Every time an operation requiring multiple asynchronous calls is done, we
   * increment this value. During the difference stages in the async operation,
   * we check whether the value has changed. If it has, we assume that the
   * operation was cancelled, and we do not proceed with the rest of the
   * operation.
   *
   * @type {number}
   * @protected
   */
  this._currentSeqId = 0;

  // Rebind
  this._setListOptions = this._setListOptions.bind(this);
  this._replaceCurrentList = this._replaceCurrentList.bind(this);

  // Rebind event handlers
  this._handleBeforeVolumeChange = this._handleBeforeVolumeChange.bind(this);
  this._handleCapped = this._handleCapped.bind(this);
  this._handlePlaying = this._handlePlaying.bind(this);
  this._handlePaused = this._handlePaused.bind(this);
  this._handleEnded = this._handleEnded.bind(this);
  this._handleCanPreload = this._handleCanPreload.bind(this);
  this._handleError = this._handleError.bind(this);
  this._handlePositionChanged = this._handlePositionChanged.bind(this);
  this._handleDurationChanged = this._handleDurationChanged.bind(this);
  this._handleTimeout = this._handleTimeout.bind(this);
  this._handlePlayedThresholdReached =
    this._handlePlayedThresholdReached.bind(this);

  this._init(_options.trackPlayer);
}
inherit(ListPlayer, EventEmitter);

ListPlayer.create = function(options) {
  return new ListPlayer(options);
};

ListPlayer.prototype._init = function(trackPlayer) {
  // Ensure that there's at least 1 listener to trackPlayerPromise so we don't
  // get errors in the dev tools.
  this._trackPlayerPromise.promise.catch(function() { /* NO OP */ });

  // Track Player
  Promise.resolve(trackPlayer).then(function(player) {
    this._attachPlayerEvents(player);
    this._trackPlayerPromise.resolve(player);
  }.bind(this)).catch(this._handlePlayerInitError.bind(this));
};

ListPlayer.prototype._attachPlayerEvents = function(player) {
  player.on(Event.PLAYER_BEFORE_VOLUME_CHANGE, this._handleBeforeVolumeChange);
  player.on(Event.PLAYER_CAN_PRELOAD, this._handleCanPreload);
  player.on(Event.PLAYER_CAPPED, this._handleCapped);
  player.on(Event.PLAYER_ENDED, this._handleEnded);
  player.on(Event.PLAYER_ERROR, this._handleError);
  player.on(Event.PLAYER_PAUSED, this._handlePaused);
  player.on(Event.PLAYER_PLAYING, this._handlePlaying);
  player.on(Event.PLAYER_TIMEOUT, this._handleTimeout);
  player.on(Event.PLAYER_POSITION_CHANGED, this._handlePositionChanged);
  player.on(Event.PLAYER_DURATION_CHANGED, this._handleDurationChanged);

  player.on(
    Event.PLAYER_PLAYED_THRESHOLD_REACHED,
    this._handlePlayedThresholdReached
  );

  // Proxy Events
  this.proxyEmit(player, Event.PLAYER_PROGRESS, Event.LIST_PLAYER_PROGRESS);
  this.proxyEmit(
    player,
    Event.PLAYER_AUTOPLAY_FAILED,
    Event.LIST_PLAYER_AUTOPLAY_FAILED
  );
  this.proxyEmit(
    player,
    Event.PLAYER_BEFORE_LOAD,
    Event.LIST_PLAYER_BEFORE_PLAYER_LOAD
  );
  this.proxyEmitSync(
    player,
    Event.PLAYER_LOAD,
    Event.LIST_PLAYER_PLAYER_LOAD
  );
  this.proxyEmit(
    player,
    Event.PLAYER_TRACKING_DATA_CREATED,
    Event.LIST_PLAYER_TRACKING_DATA_CREATED
  );
  this.proxyEmit(
    player,
    Event.PLAYER_TRACKING_DATA_FINALIZED,
    Event.LIST_PLAYER_TRACKING_DATA_FINALIZED
  );
  this.proxyEmit(
    player,
    Event.PLAYER_BUFFER_STALLED,
    Event.LIST_PLAYER_BUFFER_STALLED
  );
  this.proxyEmit(
    player,
    Event.PLAYER_BUFFERING_START,
    Event.LIST_PLAYER_BUFFERING_START
  );
  this.proxyEmit(
    player,
    Event.PLAYER_BUFFERING_END,
    Event.LIST_PLAYER_BUFFERING_END
  );
  this.proxyEmit(
    player,
    Event.PLAYER_VIDEO_ELEMENT_APPENDED,
    Event.LIST_PLAYER_VIDEO_ELEMENT_APPENDED
  );
  this.proxyEmit(
    player,
    Event.PLAYER_VIDEO_ELEMENT_REMOVED,
    Event.LIST_PLAYER_VIDEO_ELEMENT_REMOVED
  );
};

ListPlayer.prototype._handlePlayerInitError = function(error) {
  this._trackPlayerPromise.reject(
    new PlaybackError(
      Errors.LIST_PLAYER_NO_TRACK_PLAYER,
      error.message || 'Track player promise was rejected.'
    )
  );
};

ListPlayer.prototype._handleCapped = function() {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_CAPPED, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList
  });
};

ListPlayer.prototype._handlePlaying = function(e) {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_PLAYING, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList,
    position: e.position
  });
};

ListPlayer.prototype._handlePaused = function(e) {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_PAUSED, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList,
    position: e.position
  });
};

ListPlayer.prototype._handleBeforeVolumeChange = function(e) {
  var ev = this.emitSync(Event.LIST_PLAYER_BEFORE_VOLUME_CHANGE, {
    volume: e.volume
  });

  if (ev.defaultPrevented) {
    e.preventDefault();
  }
};

/**
 * Callback for when the currently playing track is near the end.
 */
ListPlayer.prototype._handleCanPreload = function() {
  this._preloadUpcomingTrack().catch(function() {
    // Noop
  });
};

ListPlayer.prototype._handleEnded = function() {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_TRACK_ENDED, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList
  });
  this.next(Reason.TRACK_DONE);
};

ListPlayer.prototype._handleTimeout = function() {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_TRACK_TIMEOUT, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList
  });
  this.next(Reason.TRACK_ERROR);
};

ListPlayer.prototype._handlePositionChanged = function(event) {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_POSITION_CHANGED, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList,
    position: event.position
  });
};

ListPlayer.prototype._handleDurationChanged = function(event) {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_DURATION_CHANGED, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList,
    position: event.position,
    duration: event.duration
  });
};

ListPlayer.prototype._handlePlayedThresholdReached = function(e) {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_PLAYED_THRESHOLD_REACHED, {
    uid: this._uid,
    track: currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList,
    total: e.total,
    threshold: e.threshold,
    position: e.position
  });
};

ListPlayer.prototype._handleError = function(event) {
  var currentTrack = this._currentTrack;
  if (!currentTrack) {
    return;
  }
  this.emit(Event.LIST_PLAYER_ERROR, event);
  this.emitSync(Event.LIST_PLAYER_ERROR_SYNC, event);

  // This will be set in cases where errors are expected to not increment the
  // list error count, and to by pass the error count check. This happens in the
  // case of ads, where an error should not prevent moving on to the next track.
  var ignoreError = !!event.error && event.error.listPlayerIgnore;

  if (!ignoreError) {
    this._listErrorCount++;
  }

  if (!event.canPlayNext) {
    return;
  }

  if (ignoreError || (this._listErrorCount <= this._maxListErrors)) {
    this.next(Reason.TRACK_ERROR);
  } else {
    this.emit(Event.LIST_PLAYER_MAX_LIST_ERRORS_REACHED, {
      count: this._listErrorCount,
      threshold: this._maxListErrors
    });
  }
};

ListPlayer.prototype._handleTrackLoaded = function(data) {
  this.emitSync(Event.LIST_PLAYER_TRACK_LOADED, data);
};

/**
 * Increments the internal _seqId value.
 *
 * @return {number} The new seqId value.
 * @protected
 */
ListPlayer.prototype._incrementSeqId = function() {
  if (this._currentSeqId >= MAX_SEQ_ID) {
    this._currentSeqId = 0;
  } else {
    this._currentSeqId += 1;
  }
  return this._currentSeqId;
};

ListPlayer.prototype._getTrackPlayer = function() {
  return this._trackPlayerPromise.promise;
};

ListPlayer.prototype._setListIndex = function(list, options) {
  var index = (!options.index || options.index === -1) ? 0 : options.index;
  return Promise.all([list, options, list.startAt(index)]);
};

ListPlayer.prototype._setListOptions = function(list, options) {
  return Promise.all([
    list.setShuffle(!!this._shuffled),
    list.setRepeatMode(this._repeatMode)
  ]).then(function() {
    return [list, options];
  });
};

ListPlayer.prototype._replaceCurrentList = function(list, options) {
  this.emitSync(Event.LIST_PLAYER_BEFORE_LIST_CHANGE, {
    newList: list,
    newOptions: options,
    oldList: this._loadedList,
    oldOptions: this._loadedOptions
  });

  this._loadedList = list;
  this._loadedOptions = options;

  this._listPlayCount = 0;
  this._listErrorCount = 0;
  this.emit(Event.LIST_PLAYER_LIST_CHANGED, {
    list: list,
    options: options
  });
  return OperationResult.SUCCESS;
};

ListPlayer.prototype._preloadTrack = function(track) {
  return this._getTrackPlayer().then(function(trackPlayer) {
    trackPlayer.preload(track).catch(function() {
      // Preload failed. Ignore.
    });
    return OperationResult.SUCCESS;
  });
};

ListPlayer.prototype._changeTrack = function(track, reason, seqId) {
  if (this._currentSeqId !== seqId) {
    return OperationResult.CANCELLED;
  }
  this.emitSync(Event.LIST_PLAYER_BEFORE_TRACK_LOAD, {
    list: this._loadedList,
    newTrack: track,
    oldTrack: this._currentTrack
  });

  this._uid++;
  var playCount = ++this._listPlayCount;

  // Calculate play options
  var options = this._loadedOptions;

  var autoplay = true;
  var position = 0;
  var playedThreshold = 30000;

  if (playCount === 1) {
    autoplay = !options.paused;
    position = options.initialPosition || options.position || 0;
  } else {
    position = options.position || 0;
  }

  // This option controls the "pausing" behaviour for any previously loaded
  // tracks from the TrackPlayer. When set to true, it'll continue playing
  // the previous track until the next track is loaded. This is the behaviour
  // necessary for preloading.
  var continuePrevious = (reason === Reason.TRACK_DONE);

  // If the track has override options, override any of the variable values.
  if ('options' in track) {
    var overrideOptions = track.options;
    if ('paused' in overrideOptions) {
      autoplay = !overrideOptions.paused;
    }
    if ('position' in overrideOptions) {
      position = overrideOptions.position;
    }
    if ('playedThreshold' in overrideOptions) {
      playedThreshold = overrideOptions.playedThreshold;
    }
  }

  this._currentTrack = track;
  this._currentTrackOptions = {
    reason: reason,
    paused: !autoplay,
    position: position,
    playedThreshold: playedThreshold
  };

  var handleTrackLoaded = this._handleTrackLoaded.bind(this, {
    uid: this._uid,
    track: this._currentTrack,
    options: this._currentTrackOptions,
    list: this._loadedList
  });
  return this._getTrackPlayer().then(function(trackPlayer) {
    if (this._currentSeqId !== seqId) {
      return OperationResult.CANCELLED;
    }
    Promise.resolve(trackPlayer.load(track, {
      uriProperty: 'playableURI',
      autoplay: autoplay,
      position: position,
      playedThreshold: playedThreshold,
      continuePrevious: continuePrevious
    }, handleTrackLoaded)).catch(function() {
      // Ignore, as the events should give us information on errors, if any.
    });
    return OperationResult.SUCCESS;
  }.bind(this));
};

ListPlayer.prototype.load = function(list, options) {
  var userOptions = options || this._loadedOptions || {};
  var mergedOptions = PlaybackOptions.create(userOptions);
  return this._setListIndex(list, mergedOptions)
    .spread(this._setListOptions)
    .spread(this._replaceCurrentList);
};

ListPlayer.prototype.play = function(list, options) {
  var _this = this;
  return this.load(list, options).then(function() {
    // If the list has changed, ignore the operation.
    if (_this._loadedList !== list) {
      return OperationResult.CANCELLED;
    }
    return _this.next(_this._loadedOptions.reason);
  });
};

ListPlayer.prototype.canChangeTrack = function() {
  if (!this._loadedList) {
    return Promise.resolve(true);
  }

  return this._loadedList.peekNext({
    reason: Reason.FORWARD_BUTTON,
    listConstants: ListConstants
  }).then(function(track) {
    return track !== ListConstants.FORBIDDEN;
  });
};

ListPlayer.prototype._preloadUpcomingTrack = function() {
  var list = this._loadedList;
  if (!list) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  var opParams = {
    reason: Reason.TRACK_DONE,
    listConstants: ListConstants
  };
  return list.peekNext(opParams).then(function(track) {
    if (track === ListConstants.FORBIDDEN) {
      return OperationResult.FORBIDDEN;
    }
    if (track === ListConstants.NULL_VALUE) {
      return this._preloadUpcomingTrack();
    }
    if (track === ListConstants.LIST_END) {
      return OperationResult.LIST_END;
    }
    if (!track.playable) {
      return OperationResult.INVALID;
    }
    return this._preloadTrack(track);
  }.bind(this));
};

ListPlayer.prototype.next = function(reason) {
  if (!reason) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_INVALID_ARGUMENT,
        'The argument `reason` is required.'
      )
    );
  }
  var list = this._loadedList;
  if (!list) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  this.emitSync(Event.LIST_PLAYER_BEFORE_NEXT, {
    list: list,
    reason: reason
  });
  var seqId = this._incrementSeqId();
  var opParams = {
    reason: reason,
    listConstants: ListConstants
  };
  return list.next(opParams).then(function(track) {
    if (this._currentSeqId !== seqId) {
      return OperationResult.CANCELLED;
    }
    if (track === ListConstants.FORBIDDEN) {
      return OperationResult.FORBIDDEN;
    }
    if (track === ListConstants.NULL_VALUE) {
      return this.next(reason);
    }
    if (track === ListConstants.LIST_END) {
      this.emit(Event.LIST_PLAYER_LIST_ENDED, {
        list: list,
        reason: Reason.END_PLAY
      });
      this.clear(reason);
      return OperationResult.LIST_END;
    }
    if (!track.playable) {
      this.emit(Event.LIST_PLAYER_TRACK_UNPLAYABLE, {
        track: track,
        list: list
      });
      return this.next(reason);
    }
    return this._changeTrack(track, reason, seqId);
  }.bind(this));
};

ListPlayer.prototype.previous = function(reason) {
  if (!reason) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_INVALID_ARGUMENT,
        'The argument `reason` is required.'
      )
    );
  }
  var list = this._loadedList;
  if (!list) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  this.emitSync(Event.LIST_PLAYER_BEFORE_PREVIOUS, {
    list: list,
    reason: reason
  });
  var seqId = this._incrementSeqId();
  var opParams = {
    reason: reason,
    listConstants: ListConstants
  };
  return list.previous(opParams).then(function(track) {
    if (this._currentSeqId !== seqId) {
      return OperationResult.CANCELLED;
    }
    if (track === ListConstants.FORBIDDEN) {
      return OperationResult.FORBIDDEN;
    }
    if (track === ListConstants.NULL_VALUE) {
      return this.previous(reason);
    }
    if (track === ListConstants.LIST_START) {
      this.emit(Event.LIST_PLAYER_LIST_ENDED, {
        list: list,
        reason: Reason.END_PLAY
      });
      this.clear(reason);
      return OperationResult.LIST_END;
    }
    if (!track.playable) {
      this.emit(Event.LIST_PLAYER_TRACK_UNPLAYABLE, {
        track: track,
        list: list
      });
      return this.previous(reason);
    }
    return this._changeTrack(track, reason, seqId);
  }.bind(this));
};

ListPlayer.prototype.pause = function() {
  if (!this._loadedList) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  if (this._currentTrack) {
    return this._getTrackPlayer().then(function(trackPlayer) {
      trackPlayer.pause();
      return OperationResult.SUCCESS;
    });
  }
  return Promise.resolve(OperationResult.SUCCESS);
};

ListPlayer.prototype.resume = function() {
  if (!this._loadedList) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  if (this._currentTrack) {
    return this._getTrackPlayer().then(function(trackPlayer) {
      trackPlayer.resume();
      return OperationResult.SUCCESS;
    });
  }
  return Promise.resolve(OperationResult.SUCCESS);
};

ListPlayer.prototype.togglePlay = function() {
  if (!this._loadedList) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  if (this._currentTrack) {
    return this._getTrackPlayer().then(function(trackPlayer) {
      trackPlayer.togglePlay();
      return OperationResult.SUCCESS;
    });
  }
  return Promise.resolve(OperationResult.SUCCESS);
};

ListPlayer.prototype.stop = function(reason) {
  var logData = {reason: reason || 'unknown'};
  var currentTrack = this._currentTrack;
  if (currentTrack && currentTrack.logData) {
    logData.source = currentTrack.logData.source;
  }
  this._incrementSeqId();
  return this._getTrackPlayer().then(function(trackPlayer) {
    trackPlayer.stop(logData);
    this.emit(Event.LIST_PLAYER_STOPPED, {
      uid: this._uid,
      options: this._currentTrackOptions,
      list: this._loadedList
    });
    return OperationResult.SUCCESS;
  }.bind(this));
};

ListPlayer.prototype.clear = function(reason) {
  return this.stop(reason).then(function() {
    this._loadedList = null;
    this._loadedOptions = null;
    this._currentTrack = null;
    this._currentTrackOptions = null;
    this.emit(Event.LIST_PLAYER_CLEARED);
    return OperationResult.SUCCESS;
  }.bind(this));
};

ListPlayer.prototype.setShuffle = function(shuffle) {
  // Ensure boolean
  var shuffled = !!shuffle;
  if (this._shuffled !== shuffled) {
    this._shuffled = shuffled;
    this.emit(Event.LIST_PLAYER_SHUFFLE_CHANGED, {
      player: this,
      shuffled: shuffled
    });
    var list = this._loadedList;
    if (list) {
      list.setShuffle(this._shuffled);
    }
  }
  return Promise.resolve(OperationResult.SUCCESS);
};

ListPlayer.prototype.setRepeatMode = function(repeatMode) {
  if (!(repeatMode in RepeatMode)) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_INVALID_ARGUMENT,
        'The value of repeat mode is not a correct RepeatMode enum value'
      )
    );
  }
  if (this._repeatMode !== repeatMode) {
    this._repeatMode = repeatMode;
    this.emit(Event.LIST_PLAYER_REPEAT_MODE_CHANGED, {
      player: this,
      repeatMode: repeatMode
    });
    var list = this._loadedList;
    if (list) {
      list.setRepeatMode(this._repeatMode);
    }
  }
  return Promise.resolve(OperationResult.SUCCESS);
};

ListPlayer.prototype.getVolume = function() {
  return this._getTrackPlayer().then(function(player) {
    return player.getVolume();
  });
};

ListPlayer.prototype.setVolume = function(volume, commandId) {
  return this._getTrackPlayer().then(function(player) {
    player.setVolume(volume);
    this.emit(Event.LIST_PLAYER_VOLUME_CHANGED, {
      volume: volume,
      commandId: commandId || null
    });
    return OperationResult.SUCCESS;
  }.bind(this));
};

ListPlayer.prototype.seek = function(value) {
  var loadedList = this._loadedList;
  if (!loadedList) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_NO_LIST,
        'Cannot perform operation; no list was loaded.'
      )
    );
  }
  if (typeof loadedList.allowSeeking === 'function'
      && !loadedList.allowSeeking()) {
    return Promise.reject(
      new PlaybackError(
        Errors.LIST_PLAYER_FORBIDDEN,
        'The operation is not allowed.'
      )
    );
  }
  if (this._currentTrack) {
    return this._getTrackPlayer().then(function(trackPlayer) {
      trackPlayer.seek(value);
      return OperationResult.SUCCESS;
    });
  }
  return Promise.resolve(OperationResult.SUCCESS);
};

ListPlayer.prototype.getListConstants = function() {
  return ListConstants;
};

ListPlayer.prototype.getLoadedList = function() {
  return this._loadedList;
};

ListPlayer.prototype.getLoadedOptions = function() {
  return this._loadedOptions;
};

ListPlayer.prototype.getPlayerState = function() {
  return this._getTrackPlayer().then(function(trackPlayer) {
    return trackPlayer.getPlayerState();
  });
};

ListPlayer.prototype.getState = function() {
  return this.getPlayerState()
    .then(function(state) {
      return {
        playbackState: state,
        track: this._currentTrack,
        list: this._loadedList,
        options: this._loadedOptions
      };
    }.bind(this));
};

module.exports = ListPlayer;
