'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var TrackingData = require('./_internal/tracking_data');
var DataValue = require('../types/data_value');
var Event = require('../types/event');

var debugLogger = require('spotify-debug-tools/logging')
  .forTag('playback.tracker');

/**
 * The threshold value for playback.
 *
 * @const
 * @private
 */
var PLAYED_THRESHOLD = 31000;

/**
 * Tracks the information about a playback session.
 *
 * @constructor
 * @param {Object} options The options for the tracker instance.
 */
function Tracker(options) {
  var _options = options || {};
  this._playedThreshold = _options.playedThreshold || PLAYED_THRESHOLD;
  this._playedThresholdReached = false;
  this._trackingData = null;
  this._totalStreamTime = 0;
}
inherit(Tracker, EventEmitter);

Tracker.create = function(options) {
  return new Tracker(options);
};

/**
 * Returns the amount played in milliseconds.
 *
  @return {number} The amount played in milliseconds.
 */
Tracker.prototype.getMSPlayed = function() {
  return this._trackingData.msPlayed;
};

/**
 * Function for creating the checking wheather the played threshold have been
 *     reached.
 *     If it has the Event.TRACKER_PLAYED_THRESHOLD_REACHED will be emitted.
 *
 * @protected
 */
Tracker.prototype._checkPlayedThreshold = function() {
  var trackingData = this._trackingData;
  if (!trackingData ||
    !this._playedThreshold ||
    this._playedThresholdReached ||
    trackingData.msPlayed < this._playedThreshold) {
    return;
  }
  this._playedThresholdReached = true;
  this.emit(Event.TRACKER_PLAYED_THRESHOLD_REACHED, {
    played: trackingData.msPlayed,
    threshold: this._playedThreshold
  });
};

/**
 * Function for tracking the start of loading a track.
 *
 * @param {string} uri The track uri.
 * @param {string} fileId The tracks file id.
 * @param {string} playId The internal playId.
 * @param {Object} logData The tracks log data.
 * @public
 */
Tracker.prototype.trackLoadStart = function(uri, fileId, playId, logData) {
  var trackingData = TrackingData.create();
  this._trackingData = trackingData;
  this._playedThresholdReached = false;

  trackingData.fileId = fileId;
  trackingData.currentTrackUri = uri;
  trackingData.loadTime = Date.now();

  trackingData.internalPlayId = playId;
  trackingData.externalLoadTime = logData.externalLoadTime || 0;

  trackingData.displayTrack = logData.displayTrack || DataValue.EMPTY;
  trackingData.playContext = logData.playContext || DataValue.EMPTY;
  trackingData.reasonStart = logData.reason || DataValue.UNKNOWN;
  trackingData.sourceStart = logData.source || DataValue.UNKNOWN;

  var referrerData = logData.referrer || {};
  trackingData.referrer = referrerData.name || DataValue.UNKNOWN;
  trackingData.referrerVersion = referrerData.version || DataValue.UNKNOWN;
  trackingData.referrerVendor = referrerData.vendor || DataValue.UNKNOWN;

  var format = logData.format || {};
  if (format.codec) {
    trackingData.audiocodec = format.codec.toLowerCase();
  }
  if (format.bitrate) {
    trackingData.bitrate = format.bitrate;
  }

  trackingData.gaiaDevId = logData.deviceId || 'none';
  trackingData.playbackId = logData.playbackId || null;

  trackingData.noLog = 'noLog' in logData ? logData.noLog : false;
  trackingData.noTSV = 'noTSV' in logData ? logData.noTSV : false;
  trackingData.noStats = 'noStats' in logData ? logData.noStats : false;

  this.emit(Event.TRACKER_TRACKING_DATA_CREATED, {data: trackingData});
};

/**
 * Function for tracking when the first bytes of the file (init and first
 * playable segment) were triggered to be loaded.
 */
Tracker.prototype.trackBufferLoadStart = function() {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.bufferLoadStartTime = Date.now();
};

/**
 * Function for adding to the amount of bytes downloaded for a track.
 *
 * @param {number} nBytes The number of bytes to append to the tracking data.
 * @public
 */
Tracker.prototype.trackBytesDownloaded = function(nBytes) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.totalBytes += nBytes;
};

/**
 * Function for tracking that a track has finished loading.
 *
 * @param {number} position The position at which playback was initiated.
 * @public
 */
Tracker.prototype.trackLoadDone = function(position) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  var timestamp = Date.now();
  trackingData.msInitLatency = timestamp - trackingData.bufferLoadStartTime;
  trackingData.lastPlayStartTime = timestamp;
  trackingData.localTimeMs = timestamp;
  trackingData.position = position;
  trackingData.startPosition = position;
  trackingData.addStartSegment();
};

/**
 * Function for tracking that a track can start playing.
 *
 * @public
 */
Tracker.prototype.trackCanPlayThrough = function() {
  var trackingData = this._trackingData;
  if (!trackingData || trackingData.msPlayLatency) {
    return;
  }
  var timestamp = Date.now();
  trackingData.msPlayLatency = timestamp - trackingData.loadTime;
  trackingData.msHeadLatency = timestamp - trackingData.bufferLoadStartTime;
};

/**
 * Tracks the use of a cdn URL.
 *
 * @param {string} url The url to track.
 * @param {Object} data The data for the cdn URL.
 * @public
 */
Tracker.prototype.trackBufferURL = function(url, data) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.trackBufferURL(url, data);
};

/**
 * Tracks the use of a cdn URL.
 *
 * @param {string} url The url to track.
 * @public
 */
Tracker.prototype.trackNavigatorOffline = function() {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.nOffline += 1;
};

/**
 * Function for tracking the time in milliseconds spent waiting for
 *     re-buffering on seek.
 *
 * @param {number} ms The number of milliseconds spent buffering.
 * @public
 */
Tracker.prototype.trackSeekRebuffering = function(ms) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  if (ms > this._trackingData.maxMsSeekRebuffering) {
    this._trackingData.maxMsSeekRebuffering = ms;
  }
  this._trackingData.msSeekRebuffering += ms;
};

/**
 * Function for tracking the time in milliseconds with playback stalled due
 *     to buffer underruns.
 *
 * @param {number} ms The number of milliseconds spent buffering.
 * @public
 */
Tracker.prototype.trackMsStalled = function(ms) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  if (ms > trackingData.maxMsStalled) {
    trackingData.maxMsStalled = ms;
  }
  trackingData.msStalled += ms;
  trackingData.nStalls++;
};

/**
 * Function for tracking a track failing to load.
 *
 * @public
 */
Tracker.prototype.trackLoadFailed = function() {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msPlayLatency = Date.now() - trackingData.loadTime;
  trackingData.position = 0;
  trackingData.addStartSegment();
};

/**
 * Function for tracking the stopping of a track.
 *
 * @param {Object} logData The tracks log data.
 * @public
 */
Tracker.prototype.trackStopped = function(logData) {
  var _logData = logData || {};
  var trackingData = this._trackingData;
  if (!trackingData || trackingData.isFinalized()) {
    return;
  }
  var timestamp = Date.now();
  trackingData.stopTime = timestamp;
  if (trackingData.lastPlayStartTime) {
    trackingData.addMSPlayed(timestamp - trackingData.lastPlayStartTime);
    this._checkPlayedThreshold();
  }
  trackingData.addEndSegment();
  trackingData.sourceEnd = _logData.source || DataValue.UNKNOWN;
  trackingData.reasonEnd = _logData.reason || DataValue.UNKNOWN;
  trackingData.nextPlaybackId = _logData.playbackId || DataValue.EMPTY;
  trackingData.finalize();
  this._totalStreamTime += trackingData.msPlayed;
  debugLogger.info('Tracker data finalized.');
  var playbackStats = trackingData.getPlaybackStats();
  this.emit(Event.TRACKER_TRACKING_DATA_FINALIZED, {
    data: trackingData,
    playbackStats: playbackStats
  });
};

/**
 * Function for tracking position changes that don't come from regular
 *     progress events, such as seeks.
 *
 * @param {number} newPosition The position moved to.
 * @param {boolean} paused True if playback was paused when when the change
 *     in position took place.
 * @public
 */
Tracker.prototype.trackPositionChanged = function(newPosition, paused) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  var currentPosition = trackingData.position;
  if (newPosition === currentPosition) {
    return;
  }
  trackingData.addEndSegment();
  if (newPosition > currentPosition) {
    trackingData.nSeeksForward++;
    trackingData.msSeeksForward += newPosition - currentPosition;
  } else if (newPosition < currentPosition) {
    trackingData.nSeeksBackward++;
    trackingData.msSeeksBackward += currentPosition - newPosition;
  }
  if (!paused) {
    trackingData.lastPlayStartTime = Date.now();
  }
  trackingData.position = newPosition;
  trackingData.addStartSegment();
};

/**
 * Function for tracking that a track is playing.
 *
 * @param {number} position The position at which the track started playing.
 * @public
 */
Tracker.prototype.trackPlaying = function(position) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  if (!trackingData.played) {
    // Track only first time playback start
    this.emit(Event.TRACKER_PLAYBACK_START, {
      data: trackingData
    });
  }
  trackingData.played = true;
  trackingData.lastPlayStartTime = Date.now();
  trackingData.position = position;
};

/**
 * Function for tracking that a track is paused.
 *
 * @param {number} position The position at which the track was paused.
 * @public
 */
Tracker.prototype.trackPaused = function(position) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.lastPlayStartTime = 0;
  trackingData.position = position;
};

/**
 * Function for tracking the progress of a tracks playback.
 *
 * @param {number} position The current position of the play head in the
 *     track.
 * @param {number} bitrate The bitrate for the last tracked progress.
 * @public
 */
Tracker.prototype.trackProgress = function(position, bitrate) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  var timestamp = Date.now();
  var offset = 0;
  if (trackingData.lastPlayStartTime) {
    offset = timestamp - trackingData.lastPlayStartTime;
  }
  trackingData.lastPlayStartTime = timestamp;
  trackingData.addMSPlayed(offset);
  this._checkPlayedThreshold();
  trackingData.position = position;
  if (bitrate) {
    trackingData.trackBitrate(bitrate, offset);
  }
};

/**
 * Function for setting initial properties for video tracks.
 *
 * @param {Object} data The profile data for the upcoming video track.
 * @public
 */
Tracker.prototype.trackVideoLoadStart = function(data) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.registerVideoVariant(data);
};

/**
 * Function for incrementing the warnings.
 */
Tracker.prototype.trackWarning = function() {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.nWarnings++;
};

/**
 * Function for incrementing offline counts.
 */
Tracker.prototype.trackOffline = function() {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.nOffline++;
};

// SIMPLE SETTERS

/**
 * Function for tracking the current estimated duration.
 *
 * @param {number} msDuration The length of the media currently loaded in
 *     milliseconds.
 * @protected
 */
Tracker.prototype.setActualDuration = function(msDuration) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msActualDuration = msDuration;
};

/**
 * Function for tracking which key system is used to decrypt the currently
 *     playing track.
 *
 * @param {string} keySystem The keySystem used to decrypt the track.
 * @public
 */
Tracker.prototype.setKeySystem = function(keySystem) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.keySystem = keySystem;
};

/**
 * Tracks the implementation of the EME keysystem used.
 *
 * @param {string} keySystemImpl The keysystem implemenation description.
 * @public
 */
Tracker.prototype.setKeySystemImpl = function(keySystemImpl) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.keySystemImpl = keySystemImpl;
};

/**
 * Function for tracking the time it took for a track manifest to load.
 *
 * @param {number} ms The number of milliseconds it took for the manifest to
 *     load.
 * @public
 */
Tracker.prototype.setManifestLatency = function(ms) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msManifestLatency = ms;
};

/**
 * Function for tracking if the track play is intended.
 *
 * @param {boolean} playIntended True if play is intended.
 * @public
 */
Tracker.prototype.setPlayIntended = function(playIntended) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  this._trackingData.playIntended = !!playIntended;
};

/**
 * Function for tracking the time it took to fetch and install the DRM for a
 *     track.
 *
 * @param {number} value The time in milliseconds.
 * @public
 */
Tracker.prototype.setKeyLatency = function(value) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msKeyLatency = value;
};

Tracker.prototype.setMemoryCached = function(memoryCached) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.memoryCached = !!memoryCached;
};

Tracker.prototype.setPersistentCached = function(persistentCached) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.persistentCached = !!persistentCached;
};

Tracker.prototype.setProtected = function(isProtected) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.isProtected = !!isProtected;
};

Tracker.prototype.setHadError = function(hadError) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.hadError = !!hadError;
};

Tracker.prototype.setLicenseSessionLatency = function(latency) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msLicenseSessionLatency = latency;
};

Tracker.prototype.setLicenseGenerationLatency = function(latency) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msLicenseGenerationLatency = latency;
};

Tracker.prototype.setLicenseRequestLatency = function(latency) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msLicenseRequestLatency = latency;
};

Tracker.prototype.setLicenseUpdateLatency = function(latency) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msLicenseUpdateLatency = latency;
};

/**
 * Function for tracking the time in milliseconds spent on the network when
 *     resolving file urls.
 *
 * @param {number} ms The number of milliseconds.
 * @public
 */
Tracker.prototype.setResolveLatency = function(ms) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msResolveLatency = ms;
};

/**
 * Function for tracking the calculated duration for a track.
 *
 * @param {number} ms The duration in milliseconds.
 * @public
 */
Tracker.prototype.setCalculatedDuration = function(ms) {
  var trackingData = this._trackingData;
  if (!trackingData) {
    return;
  }
  trackingData.msFileDuration = ms;
};

/**
 * Sets the played threshold duration.
 *
 * @param {number} ms The duration in milliseconds.
 * @public
 */
Tracker.prototype.setPlayedThreshold = function(ms) {
  this._playedThreshold = ms || 0;
};

module.exports = Tracker;
