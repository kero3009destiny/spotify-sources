/* eslint-disable dot-notation */
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var Event = require('../../types/event');
var Errors = require('../../types/errors');
var EMEError = require('../../lib/eme_error');

var _emitOwnEncrypted = require('./emit_encrypted');
/**
 * See
 * https://www.w3.org/TR/encrypted-media/#idl-def-mediakeysystemconfiguration
 *
 * @typedef {Object}
 */
// var MediaKeySystemConfiguration;

/**
 * Assigned as the MediaElement.prototype.setMediaKeys method on IE browsers.
 *
 * @param {MediaKeys?} mediaKeys The MediaKeys object to assign. Can be null.
 * @return {Promise.<void>} A promise that will be resolved when the media keys
 *     have been set.
 */
function _setMediaKeys(mediaKeys) {
  var oldKeys = this.mediaKeys;
  if (oldKeys && oldKeys !== mediaKeys) {
    oldKeys.detach(this);
  }
  delete this['mediaKeys'];
  this.mediaKeys = mediaKeys;
  if (mediaKeys) {
    return mediaKeys.attach(this);
  }
  return Promise.resolve();
}

/**
 * A Polyfill of the MediaKeySystemAccess class.
 *
 * @constructor
 * @param {string} keySystem The name of the keySystem.
 * @param {Array.<MediaKeySystemConfiguration>} configs An array of supported
 *     configurations to check.
 */
function MediaKeySystemAccess(keySystem, configs) {
  /**
   * The name of the keysystem.
   *
   * @type {string}
   */
  this.keySystem = keySystem;

  /**
   * The current supported configuration.
   *
   * @type {Array.<MediaKeySystemConfiguration>}
   * @protected
   */
  this._configuration = null;

  if (!this._checkConfig(configs)) {
    throw new EMEError(
      Errors.EME_NO_SUPPORTED_CONFIGURATION,
      'No supported configurations'
    );
  }
}

/**
 * Determines which configs are supported on the current environment.
 *
 * @param {Array.<MediaKeySystemConfiguration>} configs An array of
 *     configurations to check.
 * @return {boolean} `true` if there are any supported configurations, `false`
 *     otherwise.
 * @protected
 */
MediaKeySystemAccess.prototype._checkConfig = function(configs) {
  var keySystem = this.keySystem;

  for (var i = 0, l = configs.length; i < l; i++) {
    var config = configs[i];

    var configuration = {
      initDataTypes: config.initiDataTypes,
      audioCapabilities: [],
      videoCapabilities: [],
      persistentState: 'optional',
      distinctiveIdentifier: 'optional',
      sessionTypes: ['temporary'],
      label: config.label
    };

    var x;
    var y;
    var cap;
    var contentType;

    var hasSupported;
    // Audio caps
    if (config.audioCapabilities && config.audioCapabilities.length) {
      hasSupported = false;
      for (x = 0, y = config.audioCapabilities.length; x < y; x++) {
        cap = config.audioCapabilities[x];
        contentType = cap.contentType.split(';')[0];
        if (global.MSMediaKeys.isTypeSupported(keySystem, contentType)) {
          configuration.audioCapabilities.push(cap);
          hasSupported = true;
        }
      }
    }

    // Video caps
    if (config.videoCapabilities && config.videoCapabilities.length) {
      hasSupported = false;
      for (x = 0, y = config.videoCapabilities.length; x < y; x++) {
        cap = config.videoCapabilities[x];
        contentType = cap.contentType.split(';')[0];
        if (global.MSMediaKeys.isTypeSupported(keySystem, contentType)) {
          configuration.videoCapabilities.push(cap);
          hasSupported = true;
        }
      }
    }

    if (hasSupported) {
      this._configuration = configuration;
      return true;
    }
  }

  return false;
};

/**
 * Returns the supported configurations.
 *
 * @return {Array.<MediaKeySystemConfiguration>} A list of the supported
 *     configurations.
 */
MediaKeySystemAccess.prototype.getConfiguration = function() {
  return this._configuration;
};

/**
 * Creates a `MediaKeys` object.
 *
 * @return {MediaKeys} The created media keys.
 */
MediaKeySystemAccess.prototype.createMediaKeys = function() {
  var keySystem = this.keySystem;
  return new Promise(function(resolve) {
    resolve(new MediaKeys(keySystem));
  });
};


/**
 * Polyfills the `MediaKeys` object.
 *
 * @constructor
 * @param {string} keySystem The keysystem.
 */
function MediaKeys(keySystem) {
  /**
   * The native media keys.
   *
   * @type {MSMediaKeys}
   * @protected
   */
  this._nativeMediaKeys = new global.MSMediaKeys(keySystem);

  /**
   * A reference to the function used to set the media keys into the
   * HTMLMediaElement instance.
   *
   * @type {function}
   * @protected
   */
  this._lastBoundSetter = null;

  /**
   * A public flag that can be used to check whether the `MediaKeys` can be
   * used for more than one track.
   *
   * This is necessary because it seems that IE11 requires that the `MediaKeys`
   * be recreated for every track.
   *
   * @type {boolean}
   */
  this.shouldRefreshPerTrack = true;
}

/**
 * Attaches the instance to the `HTMLMediaElement`.
 *
 * Note that this is not part of the standard.
 *
 * @param {HTMLMediaElement} element The element to attach to.
 * @return {Promise.<void>} A promise that will be resolved when the `MediaKeys`
 *     instance has been attached.
 */
MediaKeys.prototype.attach = function(element) {
  return new Promise(function(resolve) {
    // I811 requires that the `loadedmetadata` event be fired before attaching
    // the MediaKeys (i.e., `readyState` is `1`). If that is already the case,
    // we attach immediately. Otherwise we wait until the event.
    if (element.readyState >= 1) {
      element.msSetMediaKeys(this._nativeMediaKeys);
      resolve();
      return;
    }
    var setter = function() {
      element.removeEventListener(Event.MEDIA_LOADEDMETADATA, setter);
      this._lastBoundSetter = null;
      element.msSetMediaKeys(this._nativeMediaKeys);
    }.bind(this);
    this._lastBoundSetter = setter;
    element.addEventListener(Event.MEDIA_LOADEDMETADATA, setter);
    element.addEventListener(Event.MS_NEEDKEY, _emitOwnEncrypted);
    resolve();
  }.bind(this));
};

/**
 * Detaches the instance from the `HTMLMediaElement`.
 *
 * Note that this is not part of the standard.
 *
 * @param {HTMLMediaElement} element The element to detach from.
 */
MediaKeys.prototype.detach = function(element) {
  if (!this._lastBoundSetter) {
    return;
  }
  element.removeEventListener(Event.MS_NEEDKEY, _emitOwnEncrypted);
  element.removeEventListener(
    Event.MEDIA_LOADEDMETADATA,
    this._lastBoundSetter
  );
  this._lastBoundSetter = null;
};

/**
 * Sets the server certificate for the `MediaKeys` object.
 *
 * Note that this isn't supported on the polyfill, and the returned promise is
 * guaranteed to reject.
 *
 * @return {Promise.<void>} A promise that will be resolved when the server
 *     certificate has been set.
 */
MediaKeys.prototype.setServerCertificate = function() {
  return Promise.reject(
    new EMEError(
      Errors.EME_CANNOT_SET_CERTIFICATE_FOR_PLATFORM,
      'Cannot set server certificate on this platform.'
    )
  );
};

/**
 * Creates a new `MediaKeySession`.
 *
 * @return {MediaKeySession} The created `MediaKeySession`.
 */
MediaKeys.prototype.createSession = function() {
  return new MediaKeySession(this._nativeMediaKeys);
};

/**
 * Polyfills `MediaKeySession`
 *
 * @constructor
 * @param {MSMediaKeys} nativeMediaKeys An instance of the prefixed MediaKeys.
 */
function MediaKeySession(nativeMediaKeys) {
  EventEmitter.call(this);

  /**
   * An instance of the prefixed MediaKeys.
   *
   * @type {MSMediaKeys}
   * @protected
   */
  this._nativeMediaKeys = nativeMediaKeys;

  /**
   * The native KeySession that is wrapped by this object.
   *
   * @type {MSKeySession}
   * @protected
   */
  this._nativeKeySession = null;

  /**
   * The last deferred created for the last `update` call.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._lastUpdateDeferred = null;

  /**
   * The last deferred created for the last `generateRequest` call.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._lastGenerateDeferred = null;

  // EventTarget mocking
  this.addEventListener = this.addListener;
  this.removeEventListener = this.removeListener;

  this._onKeyMessage = this._onKeyMessage.bind(this);
  this._onKeyAdded = this._onKeyAdded.bind(this);
  this._onKeyError = this._onKeyError.bind(this);
}
inherit(MediaKeySession, EventEmitter);

/**
 * Attaches events to the native MSKeySession object.
 *
 * @protected
 */
MediaKeySession.prototype._attach = function() {
  var nativeKeySession = this._nativeKeySession;
  nativeKeySession.addEventListener(Event.MS_KEY_ADDED, this._onKeyAdded);
  nativeKeySession.addEventListener(Event.MS_KEY_ERROR, this._onKeyError);
  nativeKeySession.addEventListener(Event.MS_KEY_MESSAGE, this._onKeyMessage);
};

/**
 * Detaches events from the native MSKeySession object.
 *
 * @protected
 */
MediaKeySession.prototype._detach = function() {
  var nativeKeySession = this._nativeKeySession;
  nativeKeySession.removeEventListener(Event.MS_KEY_ADDED, this._onKeyAdded);
  nativeKeySession.removeEventListener(Event.MS_KEY_ERROR, this._onKeyError);
  nativeKeySession.removeEventListener(
    Event.MS_KEY_MESSAGE,
    this._onKeyMessage
  );
};

/**
 * Handles an `mskeymessage` event from the `MSKeySession` instance.
 *
 * @param {MSMediaKeySessionEvent} ev The event object.
 * @protected
 */
MediaKeySession.prototype._onKeyMessage = function(ev) {
  if (!ev.message || !ev.message.buffer) {
    return;
  }
  this.emit(Event.KEY_SESSION_MESSAGE, {
    messageType: 'license-request',
    message: ev.message.buffer
  });
  if (this._lastGenerateDeferred) {
    this._lastGenerateDeferred.resolve(true);
    this._lastGenerateDeferred = null;
  }
};

/**
 * Handles an `mskeyadded` event from the `MSKeySession` instance.
 *
 * @protected
 */
MediaKeySession.prototype._onKeyAdded = function() {
  if (this._lastUpdateDeferred) {
    this._lastUpdateDeferred.resolve(true);
    this._lastUpdateDeferred = null;
  }
  if (this._lastGenerateDeferred) {
    this._lastGenerateDeferred.resolve(true);
    this._lastGenerateDeferred = null;
  }
  this.emit(Event.KEY_SESSION_STATUSES_CHANGE);
};

/**
 * Handles an `mskeyerror` event from the `MSKeySession` instance.
 *
 * @protected
 */
MediaKeySession.prototype._onKeyError = function() {
  var error = this._nativeKeySession.error;
  if (this._lastGenerateDeferred) {
    this._lastGenerateDeferred.reject(error);
    this._lastGenerateDeferred = null;
  }
  if (this._lastUpdateDeferred) {
    this._lastUpdateDeferred.reject(error);
    this._lastUpdateDeferred = null;
  }
  this.emit(Event.KEY_SESSION_STATUSES_CHANGE);
};

/**
 * Generates a request for a license.
 *
 * @param {string} initDataType The type of the init data.
 * @param {ArrayBuffer} initData The init data.
 * @return {Promise.<void>} A promise that will be resolved when the message is
 *     generated.
 */
MediaKeySession.prototype.generateRequest = function(initDataType, initData) {
  return new Promise(function(resolve, reject) {
    this._lastGenerateDeferred = {
      resolve: resolve,
      reject: reject
    };
    this._nativeKeySession = this._nativeMediaKeys.createSession(
      'audio/mp4', // This can be any mime-type.
      new global.Uint8Array(initData),
      null
    );
    this._attach();
  }.bind(this));
};

/**
 * Attaches a license to the `MediaKeySession`.
 *
 * @param {ArrayBuffer} license The license to attach.
 * @return {Promise.<void>} A promise that will be resolved when the license
 *     has been updated.
 */
MediaKeySession.prototype.update = function(license) {
  return new Promise(function(resolve, reject) {
    this._lastUpdateDeferred = {
      resolve: resolve,
      reject: reject
    };
    this._nativeKeySession.update(new global.Uint8Array(license));
  }.bind(this));
};

/**
 * Closes the `MediaKeySession`.
 *
 * @return {Promise.<void>} A promise that will be resolved when the instance
 *     has been closed.
 */
MediaKeySession.prototype.close = function() {
  return new Promise(function(resolve) {
    this._nativeKeySession.close();
    this._detach();
    resolve(true);
  }.bind(this));
};

module.exports = {

  setup: function() {
    // Polyfill `navigator.requestMediaKeySystemAccess`
    global.navigator.requestMediaKeySystemAccess = function(ks, conf) {
      return new Promise(function(resolve) {
        resolve(new MediaKeySystemAccess(ks, conf));
      });
    };

    // Polyfill `HTMLMediaElement.prototype.setMediaKeys`
    var MediaElement = global.HTMLMediaElement;
    if (MediaElement) {
      delete MediaElement.prototype['mediaKeys'];
      MediaElement.prototype.setMediaKeys = _setMediaKeys;
    }
  }

};
