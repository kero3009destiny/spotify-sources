/* eslint-disable dot-notation */
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var Event = require('../../types/event');
var Errors = require('../../types/errors');
var EMEError = require('../../lib/eme_error');

var _emitOwnEncrypted = require('./emit_encrypted');

var debugLogger = require('spotify-debug-tools/logging').forTag(
  'eme_polyfill.v0_1b'
);

/**
 * See
 * https://www.w3.org/TR/encrypted-media/#idl-def-mediakeysystemconfiguration
 *
 * @typedef {Object}
 */
// var MediaKeySystemConfiguration;

/**
 * Assigned as the MediaElement.prototype.setMediaKeys method on IE browsers.
 *
 * @param {MediaKeys?} mediaKeys The MediaKeys object to assign. Can be null.
 * @return {Promise.<void>} A promise that will be resolved when the media keys
 *     have been set.
 */
function _setMediaKeys(mediaKeys) {
  var oldKeys = this.mediaKeys;
  if (oldKeys && oldKeys !== mediaKeys) {
    oldKeys.detach(this);
  }
  delete this['mediaKeys'];
  this.mediaKeys = mediaKeys;
  if (mediaKeys) {
    mediaKeys.attach(this);
  }
  return Promise.resolve();
}

/**
 * A Polyfill of the MediaKeySystemAccess class.
 *
 * @constructor
 * @param {string} keySystem The name of the keySystem.
 * @param {Array.<MediaKeySystemConfiguration>} configs An array of supported
 *     configurations to check.
 * @param {string} prefix The prefix to use for the APIs, if any.
 */
function MediaKeySystemAccess(keySystem, configs, prefix) {
  /**
   * The name of the keysystem.
   *
   * @type {string}
   */
  this.keySystem = keySystem;

  /**
   * The current supported configuration.
   *
   * @type {Array.<MediaKeySystemConfiguration>}
   * @protected
   */
  this._configuration = null;

  /**
   * The prefix for the apis to use, if any.
   *
   * @type {string}
   * @protected
   */
  this._prefix = prefix;

  if (!this._checkConfig(configs)) {
    throw new EMEError(
      Errors.EME_NO_SUPPORTED_CONFIGURATION,
      'No supported configurations'
    );
  }
}

/**
 * Determines which configs are supported on the current environment.
 *
 * @param {Array.<MediaKeySystemConfiguration>} configs An array of
 *     configurations to check.
 * @return {boolean} `true` if there are any supported configurations, `false`
 *     otherwise.
 * @protected
 */
MediaKeySystemAccess.prototype._checkConfig = function(configs) {
  var keySystem = this.keySystem;

  var testVideo = document.createElement('video');
  for (var i = 0, l = configs.length; i < l; i++) {
    var config = configs[i];

    var configuration = {
      initDataTypes: config.initiDataTypes,
      audioCapabilities: [],
      videoCapabilities: [],
      persistentState: 'optional',
      distinctiveIdentifier: 'optional',
      sessionTypes: ['temporary'],
      label: config.label
    };

    var x;
    var y;
    var cap;
    var contentType;

    var hasSupported = false;
    // Audio caps
    if (config.audioCapabilities && config.audioCapabilities.length) {
      hasSupported = false;
      for (x = 0, y = config.audioCapabilities.length; x < y; x++) {
        cap = config.audioCapabilities[x];
        contentType = cap.contentType.split(';')[0];
        if (testVideo.canPlayType(contentType, keySystem)) {
          configuration.audioCapabilities.push(cap);
          hasSupported = true;
        }
      }
    }

    // Video caps
    if (config.videoCapabilities && config.videoCapabilities.length) {
      hasSupported = false;
      for (x = 0, y = config.videoCapabilities.length; x < y; x++) {
        cap = config.videoCapabilities[x];
        contentType = cap.contentType;
        if (testVideo.canPlayType(contentType, keySystem)) {
          configuration.videoCapabilities.push(cap);
          hasSupported = true;
        }
      }
    }

    if (hasSupported) {
      this._configuration = configuration;
      return true;
    }
  }

  return false;
};

/**
 * Returns the supported configurations.
 *
 * @return {Array.<MediaKeySystemConfiguration>} A list of the supported
 *     configurations.
 */
MediaKeySystemAccess.prototype.getConfiguration = function() {
  return this._configuration;
};

/**
 * Creates a `MediaKeys` object.
 *
 * @return {MediaKeys} The created media keys.
 */
MediaKeySystemAccess.prototype.createMediaKeys = function() {
  var keySystem = this.keySystem;
  var prefix = this._prefix;
  return new Promise(function(resolve) {
    resolve(new MediaKeys(keySystem, prefix));
  });
};


/**
 * Polyfills the `MediaKeys` object.
 *
 * @constructor
 * @param {string} keySystem The keysystem.
 * @param {string} prefix The prefix for the APIs to use, if any.
 */
function MediaKeys(keySystem, prefix) {
  /**
   * The keysystem
   *
   * @type {string}
   * @protected
   */
  this._keySystem = keySystem;

  /**
   * The prefix to use for the APIs, if any.
   *
   * @type {string}
   * @protected
   */
  this._prefix = prefix;

  /**
   * The media element where this MediaKeys instance is attached.
   *
   * @type {HTMLMediaElement}
   * @protected
   */
  this._mediaElement = null;

  /**
   * An array holding the sessions that are currently awaiting session ids.
   *
   * @type {Array.<MediaKeySession>}
   * @protected
   */
  this._waitingForSessionIds = [];

  /**
   * A map of MediaKeySession objects to session ids.
   *
   * @type {Object.<string, MediaKeySession>}
   * @protected
   */
  this._sessionMap = {};

  /**
   * A public flag that can be used to check whether the `MediaKeys` can be
   * used for more than one track.
   *
   * @type {boolean}
   */
  this.shouldRefreshPerTrack = true;

  // Rebind event handlers
  this._onKeyMessage = this._onKeyMessage.bind(this);
  this._onKeyAdded = this._onKeyAdded.bind(this);
  this._onKeyError = this._onKeyError.bind(this);
}

/**
 * Attaches the instance to the `HTMLMediaElement`.
 *
 * Note that this is not part of the standard.
 *
 * @param {HTMLMediaElement} element The element to attach to.
 */
MediaKeys.prototype.attach = function(element) {
  this._mediaElement = element;
  var prefix = this._prefix;
  element.addEventListener(prefix + Event.V0_1B_NEEDKEY, _emitOwnEncrypted);
  element.addEventListener(prefix + Event.V0_1B_KEY_ADDED, this._onKeyAdded);
  element.addEventListener(prefix + Event.V0_1B_KEY_ERROR, this._onKeyError);
  element.addEventListener(
    prefix + Event.V0_1B_KEY_MESSAGE,
    this._onKeyMessage
  );
};

/**
 * Detaches the instance from the `HTMLMediaElement`.
 *
 * Note that this is not part of the standard.
 *
 * @param {HTMLMediaElement} element The element to detach from.
 */
MediaKeys.prototype.detach = function(element) {
  this._mediaElement = null;
  var prefix = this._prefix;
  element.removeEventListener(prefix + Event.V0_1B_NEEDKEY, _emitOwnEncrypted);
  element.removeEventListener(prefix + Event.V0_1B_KEY_ADDED, this._onKeyAdded);
  element.removeEventListener(prefix + Event.V0_1B_KEY_ERROR, this._onKeyError);
  element.removeEventListener(
    prefix + Event.V0_1B_KEY_MESSAGE,
    this._onKeyMessage
  );
};

MediaKeys.prototype._getSession = function(sessionId) {
  var session = this._sessionMap[sessionId];
  if (session) {
    return session;
  }

  var newSession = this._waitingForSessionIds.shift();
  if (newSession) {
    newSession.sessionId = sessionId;
    this._sessionMap[sessionId] = newSession;
    return newSession;
  }

  return null;
};

MediaKeys.prototype._onKeyMessage = function(e) {
  var session = this._getSession(e.sessionId);
  if (!session) {
    debugLogger.warn('Got keymessage without session.');
    return;
  }
  session.generateComplete(e.message);
};

MediaKeys.prototype._onKeyAdded = function(e) {
  var session = this._getSession(e.sessionId);
  if (!session) {
    debugLogger.warn('Got keyadded without session.');
    return;
  }
  session.updateComplete();
};

MediaKeys.prototype._onKeyError = function(e) {
  var session = this._getSession(e.sessionId);
  if (!session) {
    debugLogger.warn('Got keyerror without session.');
    return;
  }
  session.handleErrorEvent(e);
};


/**
 * Sets the server certificate for the `MediaKeys` object.
 *
 * Note that this isn't supported on the polyfill, and the returned promise is
 * guaranteed to reject.
 *
 * @return {Promise.<void>} A promise that will be resolved when the server
 *     certificate has been set.
 */
MediaKeys.prototype.setServerCertificate = function() {
  return Promise.reject(
    new EMEError(
      Errors.EME_CANNOT_SET_CERTIFICATE_FOR_PLATFORM,
      'Cannot set server certificate on this platform.'
    )
  );
};

/**
 * Creates a new `MediaKeySession`.
 *
 * @return {MediaKeySession} The created `MediaKeySession`.
 */
MediaKeys.prototype.createSession = function() {
  var session = new MediaKeySession(
    this._keySystem,
    this._mediaElement,
    this._prefix
  );
  this._waitingForSessionIds.push(session);
  return session;
};

/**
 * Polyfills `MediaKeySession`
 *
 * @constructor
 * @param {string} keySystem The name of the keysystem.
 * @param {Object} mediaElement The media element.
 * @param {string} prefix The prefix to use for the APIs, if any.
 */
function MediaKeySession(keySystem, mediaElement, prefix) {
  EventEmitter.call(this);

  /**
   * The keysystem.
   *
   * @type {String}
   * @protected
   */
  this._keySystem = keySystem;

  /**
   * The media element where this MediaKeys instance is attached.
   *
   * @type {HTMLMediaElement}
   * @protected
   */
  this._mediaElement = mediaElement;

  /**
   * The prefix for the apis to use, if any.
   *
   * @type {string}
   * @protected
   */
  this._prefix = prefix;

  /**
   * The last deferred created for the last `update` call.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._lastUpdateDeferred = null;

  /**
   * The last deferred created for the last `generateRequest` call.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._lastGenerateDeferred = null;

  /**
   * The session id.
   */
  this.sessionId = null;

  // EventTarget mocking
  this.addEventListener = this.addListener;
  this.removeEventListener = this.removeListener;
}
inherit(MediaKeySession, EventEmitter);

MediaKeySession.prototype._addPrefix = function(name) {
  if (this._prefix) {
    return this._prefix + name.replace(/\b[a-z]/, function(l) {
      return l.toUpperCase();
    });
  }
  return name;
};

MediaKeySession.prototype.generateComplete = function(message) {
  this.emit(Event.KEY_SESSION_MESSAGE, {
    messageType: 'license-request',
    message: message
  });
  if (this._lastGenerateDeferred) {
    this._lastGenerateDeferred.resolve(true);
    this._lastGenerateDeferred = null;
  }
};

MediaKeySession.prototype.updateComplete = function() {
  if (this._lastUpdateDeferred) {
    this._lastUpdateDeferred.resolve(true);
    this._lastUpdateDeferred = null;
  }
  this.emit(Event.KEY_SESSION_STATUSES_CHANGE);
};

MediaKeySession.prototype.handleErrorEvent = function(e) {
  var error = new EMEError(
    Errors.EME_MEDIA_KEY_SESSION_V0_1B_ERROR,
    'MediaKeySession v0.1b Error'
  );
  error.debug.errorCode = e.errorCode;
  error.debug.systemCode = e.systemCode;

  if (!e.sessionId && this._lastGenerateDeferred) {
    this._lastGenerateDeferred.reject(error);
    this._lastGenerateDeferred = null;
  } else if (e.sessionId && this._lastUpdateDeferred) {
    this._lastUpdateDeferred.reject(error);
    this._lastUpdateDeferred = null;
  } else {
    this.emit(Event.KEY_SESSION_STATUSES_CHANGE);
  }
};

/**
 * Generates a request for a license.
 *
 * @param {string} initDataType The type of the init data.
 * @param {ArrayBuffer} initData The init data.
 * @return {Promise.<void>} A promise that will be resolved when the message is
 *     generated.
 */
MediaKeySession.prototype.generateRequest = function(initDataType, initData) {
  return new Promise(function(resolve, reject) {
    this._lastGenerateDeferred = {
      resolve: resolve,
      reject: reject
    };

    try {
      this._mediaElement[this._addPrefix('generateKeyRequest')](
        this._keySystem,
        new global.Uint8Array(initData)
      );
    } catch (e) {
      reject(e);
      this._lastGenerateDeferred = null;
    }
  }.bind(this));
};

/**
 * Attaches a license to the `MediaKeySession`.
 *
 * @param {ArrayBuffer} license The license to attach.
 * @return {Promise.<void>} A promise that will be resolved when the license
 *     has been updated.
 */
MediaKeySession.prototype.update = function(license) {
  if (this._lastUpdateDeferred) {
    // We are still updating. We need to wait until that is finished.
    var next = this.update.bind(this, license);
    return this._lastUpdateDeferred.promise.then(next, next);
  }

  var deferred = Promise.defer();
  this._lastUpdateDeferred = deferred;
  try {
    this._mediaElement[this._addPrefix('addKey')](
      this._keySystem,
      new global.Uint8Array(license),
      null, // License/Key Id,
      this.sessionId
    );
  } catch (e) {
    deferred.reject(e);
    this._lastUpdateDeferred = null;
  }
  return deferred.promise;
};

/**
 * Closes the `MediaKeySession`.
 *
 * @return {Promise.<void>} A promise that will be resolved when the instance
 *     has been closed.
 */
MediaKeySession.prototype.close = function() {
  if (this.sessionId) {
    try {
      this._mediaElement[this._addPrefix('cancelKeyRequest')](
        this._keySystem,
        this.sessionId
      );
    } catch (e) {
      debugLogger.warn('Could not close keysession', e);
    }
  }
  return Promise.resolve(true);
};

module.exports = {

  setup: function(prefix) {
    // Polyfill `navigator.requestMediaKeySystemAccess`
    global.navigator.requestMediaKeySystemAccess = function(ks, conf) {
      return new Promise(function(resolve) {
        resolve(new MediaKeySystemAccess(ks, conf, prefix));
      });
    };

    // Polyfill `HTMLMediaElement.prototype.setMediaKeys`
    var MediaElement = global.HTMLMediaElement;
    if (MediaElement) {
      delete MediaElement.prototype['mediaKeys'];
      MediaElement.prototype.setMediaKeys = _setMediaKeys;
    }
  }

};
