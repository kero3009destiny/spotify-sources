'use strict';
/**
 * @module spotify-playback/player
 */

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var LRUCache = require('spotify-linkedlist/lrucache');
var debugLogger = require('spotify-debug-tools/logging').forTag(
  'playback.acme_player'
);

var OperationResult = require('./types/operation_result');
var StorageError = require('./lib/storage_error');

var ABRManager = require('./_internal/bandwidth_estimator');
var ACMETrack = require('./_internal/track');
var ACMEVideoTrack = require('./_internal/videotrack');
var Event = require('./types/event');
var EMEManager = require('./_internal/eme_manager');
var Buffer = require('./_internal/buffer');
var Errors = require('./types/errors');
var PlaybackError = require('./lib/playback_error');

function _createPlayer(type) {
  return document.createElement(type);
}

function _secToMS(seconds) {
  return Math.ceil(seconds * 1000);
}

function _msToSec(ms) {
  return ms / 1000;
}

/**
 * The amount of time in seconds before the end of the song before marking it as
 *     almost ended.
 */
var CAN_PRELOAD_THRESHOLD = 10;

/**
 * The default track cache size, used if it's not overridden in the constructor
 *     options.
 */
var TRACK_CACHE_SIZE = 2;

/**
 * Blob URL check.
 */
var BLOB_URL_EXP = /^blob:/;

/**
 * Subtitles visibility mode enum.
 */
var SubtitleMode = {
  SHOWING: 'showing',
  HIDDEN: 'hidden'
};


/**
 * ACME Player: AAC, CENC, MSE, EME.
 *
 * This player can be used to play EME-encoded tracks using MSE, as well as
 * unencrypted tracks.
 *
 * @constructor
 * @exports module:spotify-playback/player
 * @param {module:spotify-playback/types.ACMEPlayerOptions} options The
 *     options for this track player.
 * @implements {module:spotify-playback/types.Player}
 */
function ACMEPlayer(options) {
  EventEmitter.call(this);

  /**
   * The public ID for the player.
   *
   * @type {string}
   */
  this.id = options.id;

  /**
   * Function for creating the mediaElement.
   *
   * @type {module:spotify-playback/types.CDNResolver}
   * @protected
   */
  this._createPlayer = options.createPlayer || _createPlayer;

  /**
   * Container to which the video player element will be appended after load.
   *
   * @type {HTMLElement}
   * @protected
   */
  this._videoPlayerContainer = options.videoPlayerContainer || null;

  /**
   * A flag that indicates whether the subtitles track for a video is visible
   *     or not.
   *
   * @type {boolean}
   * @protected
   */
  this._subtitlesVisible = false;

  /**
   * A flag that indicates whether the set volume should have a cubic curve
   *     applied to it or not.
   *
   * @type {boolean}
   * @protected
   */
  this._cubicVolume = options.cubicVolume;

  /**
   * String representation of the chosen language for video subtitles.
   *
   * @type {string}
   * @protected
   */
  this._subtitleLanguage = '';

  /**
   * The storage audioResolver for the player.
   *
   * @type {module:spotify-playback/types.CDNResolver}
   * @protected
   */
  this._audioResolver = options.audioResolver;

  /**
   * The video resolver for the player.
   *
   * @type {module:spotify-playback/types.CDNResolver}
   * @protected
   */
  this._videoResolver = options.videoResolver;

  this._licenseURLResolver = options.licenseURLResolver;

  /**
   * The player element.
   *
   * @type {HTMLMediaElement}
   * @protected
   */
  this._player = null;

  /**
   * An instance of the EMEManager.
   *
   * @type {module:spotify-playback/_internal/eme_manager}
   * @protected
   */
  this._emeManager = options.disallowProtectedTracks ?
    null :
    options.emeManager;

  /**
   * The tracker.
   *
   * @type {module:spotify-playback/lib/tracker}
   * @protected
   */
  this._tracker = options.tracker;

  /**
   * The currently active codecs concatenated into a string. Used for comparing
   *     the next tracks codecs with currents, to determine if the player can be
   *     re-used.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._activeCodecs = '';

  /**
   * A cache for ACMETracks
   *
   * @type {module:spotify-linkedlist/lrucache}
   * @protected
   */
  this._cache = new LRUCache(options.trackCacheSize || TRACK_CACHE_SIZE);
  debugLogger.info(
    'Setting ACMEPlayer track cache to:',
    options.trackCacheSize || TRACK_CACHE_SIZE
  );

  /**
   * When set to true, it will force the player to create ended events
   * artificially using timeouts rather than waiting for the `ended` event from
   * the `HTMLMediaElement`.
   *
   * This is needed for some platforms where the ended event is not emitted when
   * using MediaSource due to a bug.
   *
   * @type {boolean}
   * @protected
   */
  this._synthesizeEnded = options.synthesizeEnded;

  /**
   * When set to true, it will force the player to create a new Audio element
   * for each track that will be played.
   *
   * @type {boolean}
   * @protected
   */
  this._newElementPerTrack = options.newElementPerTrack;

  /**
   * When set to true, it will force the player to recreate the Buffer for each
   * track that will be played.
   *
   * @type {boolean}
   * @protected
   */
  this._newBufferPerTrack = options.newBufferPerTrack;

  /**
   * When set to true, a new set of MediaKeys will be generated for each track
   * played.
   *
   * @type {boolean}
   * @protected
   */
  this._newMediaKeysPerTrack = options.newMediaKeysPerTrack;

  /**
   * When set to true, a seek operation will force clearing the entire buffer.
   *
   * @type {boolean}
   * @protected
   */
  this._clearBufferOnSeek = options.clearBufferOnSeek;

  /**
   * When set to true, we will force a rebuffering of the entire track when a
   * QuotaExceededError is encountered.
   *
   * @type {boolean}
   * @protected
   */
  this._rebufferOnQuotaExceeded = options.rebufferOnQuotaExceeded;

  /**
   * When set to true, it disables caching of ACMETracks and buffers.
   *
   * @type {boolean}
   * @protected
   */
  this._disableCache = options.disableCache;

  /**
   * When set to true, calls to `buffer.abort()` will be no-ops.
   *
   * @type {boolean}
   * @protected
   */
  this._disableBufferAbort = options.disableBufferAbort;

  /**
   * The ACMETrack that's currently playing.
   *
   * @type {module:spotify-playaback/_internal/track}
   * @protected
   */
  this._acmeTrack = null;

  /**
   * The next ACMETrack that will be loaded.
   *
   * We save this as an internal variable so that the loading related functions
   * will be able to access it rather than us passing it around promises, which
   * can lead to memory leaks.
   *
   * @type {module:spotify-playaback/_internal/track}
   * @protected
   */
  this._upcomingACMETrack = null;

  /**
   * Timestamp for the previous load request.
   *
   * @type {number}
   * @protected
   */
  this._lastLoadedTS = 0;

  /**
   * Map of file-ids being preloaded.
   *
   * @type {Object.<string, Promise>}
   * @protected
   */
  this._preloadingTracks = {};

  /**
   * An incrementing ID for playback.
   *
   * Every time we play a new track, we increment this value. We then use this
   * value to keep track of operations within the track, such as adding or
   * removing chunks from the buffer.
   *
   * @type {number}
   * @protected
   */
  this._playId = 0;

  /**
   * A flag that indicates whether a track has been loaded and can be played.
   *
   * @type {boolean}
   * @protected
   */
  this._loaded = false;

  /**
   * Handles the throttling timer token for pause events.
   *
   * Audio tags fire a pause event before an ended event, and we do not want to
   * catch that last pause event in most cases. We therefore throttle the pause
   * events to ensure that they don't fire if an ended event is fired.
   *
   * @type {number}
   * @protected
   */
  this._pauseToken = null;

  /**
   * The setTimeout token for the synthetic ended event.
   *
   * @type {number}
   * @protected
   */
  this._syntheticEndedToken = null;

  /**
   * A reference to the current transport.
   *
   * @type {module:spotify-transport/types.transport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * A flag that indicates whether the 'preload' event can be emitted.
   *
   * @type {boolean}
   * @protected
   */
  this._canPreloadEmitted = false;

  /**
   * The current volume of the player.
   *
   * @type {number}
   * @protected
   */
  this._playerVolume = 1;

  /**
   * Sets whether the next native error is unrecoverable.
   *
   * @type {boolean}
   * @protected
   */
  this._fatalOnNextError = false;

  /**
   * The position of the player at the time when the last `timeupdate` event
   * was called.
   *
   * Used to guard against cases where the timeupdate is fired multiple times
   * for the same position.
   *
   * @type {number}
   */
  this._lastTimeUpdatePostion = 0;

  // Player Event Handlers
  this._onCanPlay = this._onCanPlay.bind(this);
  this._onCanPlayThrough = this._onCanPlayThrough.bind(this);
  this._onTimeUpdate = this._onTimeUpdate.bind(this);
  this._onDurationChange = this._onDurationChange.bind(this);
  this._onPlaying = this._onPlaying.bind(this);
  this._onPause = this._onPause.bind(this);
  this._onSeeking = this._onSeeking.bind(this);
  this._onEncrypted = this._onEncrypted.bind(this);
  this._onEnded = this._onEnded.bind(this);
  this._onError = this._onError.bind(this);
  this._onRequiresDuration = this._onRequiresDuration.bind(this);
  this._onQuotaExceeded = this._onQuotaExceeded.bind(this);
  this._onLoadedMetadata = this._onLoadedMetadata.bind(this);
  this._onWaiting = this._onWaiting.bind(this);

  this.proxyEmitSync(
    this._tracker,
    Event.TRACKER_TRACKING_DATA_CREATED,
    Event.PLAYER_TRACKING_DATA_CREATED
  );

  this.proxyEmitSync(
    this._tracker,
    Event.TRACKER_TRACKING_DATA_FINALIZED,
    Event.PLAYER_TRACKING_DATA_FINALIZED
  );

  this.proxyEmitSync(
    this._tracker,
    Event.TRACKER_PLAYBACK_START,
    Event.PLAYER_PLAYBACK_START
  );

  this._tracker.on(
    Event.TRACKER_PLAYED_THRESHOLD_REACHED,
    this._onPlayedThresholdReached.bind(this)
  );

  if (this._emeManager) {
    this._emeManager.on(
      Event.EME_LICENSE_REQUEST_CAPPED,
      this._onLicenseRequestCapped.bind(this)
    );
    this._emeManager.on(
      Event.EME_LICENSE_REQUEST_ERROR,
      this._onLicenseRequestError.bind(this)
    );
  }

  this._init();
}
inherit(ACMEPlayer, EventEmitter);

ACMEPlayer.prototype._onLicenseRequestError = function(e) {
  if (e.playId !== this._playId) {
    return;
  }
  var acmeTrack = this._acmeTrack;
  if (!acmeTrack) {
    return;
  }
  var error = e.error;
  if (error.shouldRefreshEndpoint) {
    this._licenseURLResolver.remove(
      acmeTrack.getKeySystem(),
      acmeTrack.getMediaType()
    );
  }

  this._emitError(error, !error.unrecoverable, acmeTrack.toLogJSON());
};

ACMEPlayer.prototype._onLicenseRequestCapped = function(e) {
  if (e.playId !== this._playId) {
    return;
  }
  var acmeTrack = this._acmeTrack;
  if (!acmeTrack) {
    return;
  }
  this.pause();
  this.emit(Event.PLAYER_CAPPED);
};

/**
 * Creates a new ACMEPlayer
 *
 * @param {module:spotify-playback/types.ACMEPlayerOptions} options The
 *     options for this track player.
 * @return {Promise.<module:spotify-playback/player>} The new player.
 */
ACMEPlayer.create = function(options) {
  if (options.disableProtection) {
    return ACMEPlayer.createWithOptions(options);
  }

  return EMEManager.create({
    transport: options.transport,
    disallowRobustnessValues: options.disallowRobustnessValues,
    noServerCertificate: options.noServerCertificate,
    preferredKeySystems: options.preferredKeySystems
  }).then(function(emeManager) {
    options.emeManager = emeManager;
    return new ACMEPlayer(options);
  });
};

/**
 * Creates a new ACMEPlayer with the passed in options.
 *
 * Note that unlike the `ACMEPlayer.create` function, this does not
 * automatically create an EMEManager instance.
 *
 * @param {module:spotify-playback/types.ACMEPlayerOptions} options The
 *     options for this track player.
 * @return {Promise.<module:spotify-playback/player>} The new player.
 */
ACMEPlayer.createWithOptions = function(options) {
  return new Promise(function(resolve) {
    resolve(new ACMEPlayer(options));
  });
};

/**
 * Initializes the ACMEPlayer.
 *
 * @protected
 */
ACMEPlayer.prototype._init = function() {
  if (this._disableCache) {
    debugLogger.info('Cache disabled.');
  }

  this._transport.on(
    this._transport.EVENT_CONNECTION_OFFLINE,
    this._onNavigatorOffline.bind(this)
  );
  this._abrManager = new ABRManager();
  this._buffer = Buffer.create(
    this._tracker,
    null,
    {disableBufferAbort: this._disableBufferAbort}
  );
  this._buffer.on(Event.BUFFER_APPEND_ERROR, this._onBufferError.bind(this));
  this._buffer.on(Event.BUFFER_QUOTA_EXCEEDED, this._onQuotaExceeded);
  this.proxyEmit(
    this._buffer,
    Event.BUFFER_STALLED,
    Event.PLAYER_BUFFER_STALLED
  );
  this.proxyEmit(
    this._buffer,
    Event.BUFFERING_START,
    Event.PLAYER_BUFFERING_START
  );
  this.proxyEmit(
    this._buffer,
    Event.BUFFERING_END,
    Event.PLAYER_BUFFERING_END
  );
};

ACMEPlayer.prototype._onNavigatorOffline = function() {
  this._tracker.trackNavigatorOffline();
};

ACMEPlayer.prototype._onBufferError = function(e) {
  this._emitError(e.error, e.canPlayNext, e.track);
};

ACMEPlayer.prototype._addPlayerEvents = function(player) {
  player.addEventListener(Event.MEDIA_TIMEUPDATE, this._onTimeUpdate);
  player.addEventListener(Event.MEDIA_PLAYING, this._onPlaying);
  player.addEventListener(Event.MEDIA_PAUSE, this._onPause);
  player.addEventListener(Event.MEDIA_SEEKING, this._onSeeking);
  player.addEventListener(Event.MEDIA_ENCRYPTED, this._onEncrypted);
  player.addEventListener(Event.MEDIA_ENDED, this._onEnded);
  player.addEventListener(Event.MEDIA_ERROR, this._onError);
  player.addEventListener(Event.MEDIA_LOADEDMETADATA, this._onLoadedMetadata);
  player.addEventListener(Event.MEDIA_DURATIONCHANGE, this._onDurationChange);
  player.addEventListener(Event.MEDIA_WAITING, this._onWaiting);
  player.addEventListener(Event.MEDIA_CANPLAY, this._onCanPlay);
  player.addEventListener(Event.MEDIA_CANPLAYTHROUGH, this._onCanPlayThrough);
  player.addEventListener(
    Event.INTERNAL_MEDIA_REQUIRES_DURATION,
    this._onRequiresDuration
  );
};

ACMEPlayer.prototype._removePlayerEvents = function(player) {
  player.removeEventListener(Event.MEDIA_TIMEUPDATE, this._onTimeUpdate);
  player.removeEventListener(Event.MEDIA_PLAYING, this._onPlaying);
  player.removeEventListener(Event.MEDIA_PAUSE, this._onPause);
  player.removeEventListener(Event.MEDIA_SEEKING, this._onSeeking);
  player.removeEventListener(Event.MEDIA_ENCRYPTED, this._onEncrypted);
  player.removeEventListener(Event.MEDIA_ENDED, this._onEnded);
  player.removeEventListener(Event.MEDIA_ERROR, this._onError);
  player.removeEventListener(Event.MEDIA_WAITING, this._onWaiting);
  player.removeEventListener(Event.MEDIA_CANPLAY, this._onCanPlay);
  player.removeEventListener(
    Event.MEDIA_CANPLAYTHROUGH,
    this._onCanPlayThrough
  );
  player.removeEventListener(
    Event.MEDIA_LOADEDMETADATA,
    this._onLoadedMetadata
  );
  player.removeEventListener(
    Event.MEDIA_DURATIONCHANGE,
    this._onDurationChange
  );
  player.removeEventListener(
    Event.INTERNAL_MEDIA_REQUIRES_DURATION,
    this._onRequiresDuration
  );
};

/**
 * Recreates the audio element, hooks it up with the eme manager and sets it up
 *     with new sourcebuffers.
 *
 * @param {boolean} withProtection Whether or not the track to be played
 *     requires protection support.
 * @param {Array.<string>} codecs The codecs that will be played on this player.
 * @param {number} playId The id for playback.
 * @param {string} mediaElementType The type of media element to create.
 * @return {Promise}
 * @protected
 */
ACMEPlayer.prototype._recreateMediaElement = function(
  withProtection,
  codecs,
  playId,
  mediaElementType
) {
  if (playId !== this._playId) {
    debugLogger.info('Recreate player dropped: playId has changed.');
    return Promise.resolve(false);
  }

  var sameCodec = this._activeCodecs === codecs.join('');

  var oldPlayer = this._player;

  if (oldPlayer) {
    if (!this._newElementPerTrack) {
      // support multiple codecs for one track, since they are separate for
      // video/audio.
      var canPlayCodecs = true;
      for (var i = 0, len = codecs.length; i < len; i++) {
        if (oldPlayer.canPlayType(codecs[i]) !== 'probably') {
          canPlayCodecs = false;
          break;
        }
      }

      if (sameCodec && canPlayCodecs && oldPlayer.withProtection) {
        debugLogger.info('Reusing old audio player with default protection.');
        if (this._newBufferPerTrack) {
          debugLogger.info('Recreating buffer.');
          this._buffer.recreate(codecs);
        }
        return Promise.resolve(true);
      }
      if (sameCodec && oldPlayer.withProtection === withProtection) {
        debugLogger.info('Reusing old audio player with variable protection.');
        if (this._newBufferPerTrack) {
          debugLogger.info('Recreating buffer.');
          this._buffer.recreate(codecs);
        }
        return Promise.resolve(true);
      }
    }

    this._removePlayerEvents(oldPlayer);

    oldPlayer.pause();

    if (this._emeManager) {
      this._emeManager.removeMediaKeys(oldPlayer).catch(function(e) {
        debugLogger.warn('Failed to remove media keys.', e);
      });
    }
    this._player = null;
  }

  debugLogger.info('Creating new media element.');

  var newPlayer = this._createPlayer(mediaElementType);
  var amount = this._playerVolume;
  newPlayer.autoplay = false;
  newPlayer.loop = false;
  newPlayer.volume = this._cubicVolume ? amount * amount * amount : amount;
  newPlayer.withProtection = withProtection;

  this._player = newPlayer;
  this._addPlayerEvents(newPlayer);
  this._buffer.recreate(codecs);
  this._activeCodecs = codecs.join('');

  return Promise.resolve(true);
};

/**
 * Returns the container element where the video will be injected.
 *
 * @return {Element?} An HTMLElement object or null if there's no video
 *     container
 */
ACMEPlayer.prototype._getVideoContainer = function() {
  if (typeof this._videoPlayerContainer === 'string') {
    return document.querySelector(this._videoPlayerContainer);
  }
  return this._videoPlayerContainer || null;
};

/**
 * Returns list of available Video Profiles for the currently playing Video.
 *
 * @return {Array.<module:spotify-playback/types.VideoProfile>} List of
 *     currently available video profiles.
 */
ACMEPlayer.prototype.getVideoProfiles = function() {
  if (!this._acmeTrack || this._acmeTrack.getMediaType() !== 'video') {
    return [];
  }
  var result = [];
  var profiles = this._acmeTrack.getVideoProfiles();
  for (var i = 0, len = profiles.length; i < len; i++) {
    var profile = profiles[i];
    result.push({
      width: profile.video_width,
      height: profile.video_height,
      bitrate: profile.video_bitrate
    });
  }
  return result;
};

/**
 * Set the preferred video profile, will override adaptive bitrate playback.
 *
 * @param {number} bitrate The preferred bitrate.
 * @return {Promise.<boolean>}
 */
ACMEPlayer.prototype.setPreferredBitrate = function(bitrate) {
  if (typeof bitrate !== 'number') {
    return Promise.resolve(OperationResult.INVALID);
  }
  if (this._acmeTrack &&
      this._acmeTrack.getMediaType() === 'video' &&
      bitrate > 0
  ) {
    this._buffer.abort(true);
  }
  this._abrManager.overrideBitrate(bitrate);
  return Promise.resolve(OperationResult.SUCCESS);
};

/**
 * Creates an ACMETrack.
 *
 * @param {string} uri The track uri.
 * @param {module:spotify-playback/types.PlayerLoadOptions} track Load options
 *     for the track.
 * @protected
 * @return {Promise.<ACMETrack>}
 */
ACMEPlayer.prototype._createAudioTrack = function(uri, track) {
  var measures = {
    manifestLatency: 0,
    resolveLatency: 0
  };

  var getKeySystemInfo = this._emeManager ?
    this._emeManager.getKeySystemInfo() :
    Promise.resolve({
      keySystem: 'com.spotify.invalid'
    });

  return getKeySystemInfo
    .then(function(config) {
      var acmeTrack = ACMETrack.create({
        abrManager: this._abrManager,
        keySystem: config.keySystem,
        licenseEndpoint: track.licenseEndpoint,
        transport: this._transport,
        resolver: this._audioResolver,
        uri: uri,
        fileId: track.fileId,
        format: track.format,
        isAd: track.isAd,
        resolvedURL: track.resolvedURL,
        noManifest: track.noManifest,
        preloadedManifest: track.preloadedManifest,
        logData: track.logData,
        disableCache: this._disableCache,
        emitWarning: this._emitWarning.bind(this)
      });
      return acmeTrack.load(measures);
    }.bind(this))
    .then(function(acmeTrack) {
      var tracker = this._tracker;
      tracker.setResolveLatency(measures.resolveLatency);
      tracker.setManifestLatency(measures.manifestLatency);

      if (acmeTrack.isProtected() && track.fileId && !this._disableCache) {
        this._cache.set(track.fileId, acmeTrack);
      }
      return acmeTrack;
    }.bind(this));
};

/**
 * Creates an ACMEVideoTrack.
 *
 * @param {module:spotify-playback/types.PlayerLoadOptions} track Load options
 *     for the track.
 * @return {Promise.<ACMEVideoTrackACMEVideoTrack>}
 */
ACMEPlayer.prototype._createVideoTrack = function(track) {
  var measures = {
    manifestLatency: 0,
    resolveLatency: 0
  };
  var fileId = track.fileId;

  return this._emeManager.getKeySystemInfo()
    .then(function(config) {
      var audioFormat = config.audioFormats[0];
      var videoFormat = config.videoFormats[0];
      var acmeTrack = ACMEVideoTrack.create({
        abrManager: this._abrManager,
        resolver: this._videoResolver,
        keySystem: config.keySystem,
        licenseEndpoint: track.licenseEndpoint,
        fileId: fileId,
        isAd: track.isAd,
        transport: this._transport,
        videoCodec: videoFormat.codec,
        videoMimeType: videoFormat.mimeType,
        audioCodec: audioFormat.codec,
        audioMimeType: audioFormat.mimeType,
        disableCache: this._disableCache
      });
      return acmeTrack.load(measures);
    }.bind(this))
    .then(function(acmeTrack) {
      var tracker = this._tracker;
      tracker.setResolveLatency(measures.resolveLatency);
      tracker.setManifestLatency(measures.manifestLatency);

      if (acmeTrack.isProtected() && fileId && !this._disableCache) {
        this._cache.set(fileId, acmeTrack);
      }
      return acmeTrack;
    }.bind(this));
};

/**
 * Handles a "durationchange" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onDurationChange = function() {
  var playId = this._playId;
  var trigger = function() {
    if (playId !== this._playId) {
      // Track changed, don't emit.
      debugLogger.info('Duration changed drop: playId has changed.');
      return;
    }
    var msDuration = _secToMS(this._player.duration);
    this._tracker.setActualDuration(msDuration);
    this.emit(Event.PLAYER_DURATION_CHANGED, {
      timestamp: Date.now(),
      position: _secToMS(this._player.currentTime),
      duration: msDuration
    });
  }.bind(this);
  if (this._loaded) {
    trigger();
  } else {
    this.once(Event.PLAYER_LOAD, trigger);
  }
};

/**
 * Handles a "playing" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onPlaying = function() {
  var acmeTrack = this._acmeTrack;
  var position = _secToMS(this._player.currentTime);
  this._tracker.trackPlaying(position);
  this.emit(Event.PLAYER_PLAYING, {
    timestamp: Date.now(),
    position: position,
    logData: acmeTrack ? acmeTrack.getLogData() : null
  });
};

/**
 * Handles a "pause" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onPause = function() {
  var position = _secToMS(this._player.currentTime);
  this._tracker.trackPaused(position);

  // Throttle the pause event a few ms so that pause events that are triggered
  // by the track ending are not fired. This prevents the UI from flickering to
  // a paused state.
  var logData = this._acmeTrack ? this._acmeTrack.getLogData() : null;
  this._pauseToken = setTimeout(
    function() {
      clearTimeout(this._syntheticEndedToken);
      this.emit(Event.PLAYER_PAUSED, {
        position: position,
        logData: logData
      });
    }.bind(this),
    10
  );
};

/**
 * Handles a "seeking" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onSeeking = function() {
  this._buffer.abort(this._clearBufferOnSeek);
  this._onTimeUpdate();
};

ACMEPlayer.prototype._onRequiresDuration = function() {
  if (this._acmeTrack && this._acmeTrack.isProtected()) {
    this._player.duration = this._acmeTrack.getCalculatedDuration();
  }
};

/**
 * Handles a "quota_exceeded" event from the buffer.
 *
 * @protected
 */
ACMEPlayer.prototype._onQuotaExceeded = function() {
  if (this._rebufferOnQuotaExceeded) {
    debugLogger.info('Exceeded quota: rebuffering current track.');
    // When this happens, we want to clear all buffers and issue a seek command.
    this._buffer.abort(true);
    this._player.currentTime = this._player.currentTime;
    this._onTimeUpdate();
  } else {
    debugLogger.info('Exceeded quota: moving to next track.');
    this._player.pause();
    this._buffer.abort();
    var error = new PlaybackError(
      Errors.PLAYER_BUFFER_QUOTA_EXCEEDED,
      'Buffer quota exceeded.'
    );
    this._emitError(
      error,
      true, // Assume that moving to the next track will reset quotas.
      this._acmeTrack ? this._acmeTrack.toLogJSON() : {}
    );
  }
};

/**
 * Handles the "encrypted" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onEncrypted = function() {
  debugLogger.info('Got Encrypted event');
};

/**
 * Handles an "ended" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onEnded = function() {
  if (this._synthesizeEnded && this._acmeTrack.isProtected()) {
    return;
  }
  debugLogger.info('Native ended emitted.');
  this._emitEnded();
};

/**
 * Handles the timeout for the synthetic ended event.
 *
 * @protected
 */
ACMEPlayer.prototype._onSyntheticEnded = function() {
  if (
    this._synthesizeEnded &&
    this._acmeTrack &&
    this._acmeTrack.isProtected()
  ) {
    debugLogger.info('Synthetic ended emitted.');
    this._emitEnded();
  }
};

/**
 * Handles an "error" event from the HTMLMediaElement.
 *
 * @protected
 */
ACMEPlayer.prototype._onError = function() {
  var player = this._player;
  var error = player.error;

  var trackData = {};

  var isProtected = false;
  var acmeTrack = this._acmeTrack;
  var isAd = false;
  if (acmeTrack) {
    isProtected = acmeTrack.isProtected();
    trackData = acmeTrack.toLogJSON();
    isAd = acmeTrack.isAd();
    acmeTrack.clearCachedBuffers();
  }

  var code;
  var message;
  var debug;
  // MediaError is not an actual error, so we should format it.
  var canPlayNext = true;

  // Ads are not protected, and we can skip when the error happens on ads. We
  // also want to determine whether there was a MediaError from the previous
  // track. This prevents some errors from triggering multiple times if there
  // is a severe issue with the system.
  var canPlayIfNotFatal = !acmeTrack ||
    isAd ||
    !this._fatalOnNextError;

  // Microsoft has extended codes for errors.
  var extendedCode = error && error.msExtendedCode ?
    '0x' + (error.msExtendedCode >>> 0).toString(16).toUpperCase() :
    null;

  if (error instanceof global.MediaError) {
    var ME = global.MediaError;
    switch (error.code) {
      case ME.MEDIA_ERR_ABORTED:
        code = Errors.MEDIA_ABORTED;
        message = 'Media aborted.';
        break;
      case ME.MEDIA_ERR_NETWORK:
        code = Errors.MEDIA_NETWORK_ERROR;
        message = 'Network error.';
        break;
      case ME.MEDIA_ERR_DECODE:
        code = Errors.MEDIA_DECODING_ERROR;
        message = 'Media decoding error.';
        canPlayNext = canPlayIfNotFatal;
        break;
      case ME.MEDIA_ERR_SRC_NOT_SUPPORTED:
        code = Errors.MEDIA_NOT_SUPPORTED;
        message = 'Media not supported.';
        canPlayNext = canPlayIfNotFatal;
        break;
      default:
        code = Errors.PLAYER_MEDIA_ERROR;
        message = 'Media error.';
        debug = true;
        break;
    }

    // Chrome and Firefox have started outputing more interesting error
    // messages, so we capture the native message as well.
    //
    // Edge doesn't seem to have a native `error.message` property for some of
    // the errors, however, so we'll just use the extended code, or if that's
    // also not available, stringify the error itself.
    var nativeMessage = error.message || extendedCode || error.toString();
    message += ' (' + nativeMessage + ')';
  } else {
    code = Errors.PLAYER_PLAYBACK_ERROR;
    // The track-playback-integration tests rely on the posibility to pass
    // along the error message from the (mocked) player.
    // So if it's present: pick it up from the error and use it.
    message = error ?
      (error.message || error.toString()) :
      'Error message undefined';
    debug = true;
  }

  this._buffer.abort(true);

  var playbackError = new PlaybackError(code, message);
  if (!canPlayNext) {
    playbackError.fatal();
  }

  // The list player takes note of the number of errors that occur and stops
  // playback after a certain threshold. If the track is an ad, we want the
  // list player to ignore the error.
  playbackError.listPlayerIgnore = isAd;

  // Add some debug logging information
  playbackError.debug.src_url = player.src;
  playbackError.debug.protected = isProtected;
  playbackError.debug.extendedCode = extendedCode;
  playbackError.debug.rawExCode = (error && error.msExtendedCode) || null;

  // Technically error should not be anything other an error object, as this is
  // the standard behaviour. However, in the case where the browser misbehaves
  // and triggers an error without and error object, we should guard against
  // access just to not trigger an error within the error handler.
  if (debug && error) {
    playbackError.debug.nativeCode = error.code || null;
    playbackError.debug.errorData = error;
  }

  this._emitError(playbackError, canPlayNext, trackData);
};

ACMEPlayer.prototype._onLoadedMetadata = function() {
  this.emitSync(Event.INTERNAL_PLAYER_LOADED_METADATA);
};

ACMEPlayer.prototype._onCanPlay = function() {
  this.emitSync(Event.INTERNAL_PLAYER_CANPLAY);
  this.emit(Event.PLAYER_FIRST_BYTES);
};

ACMEPlayer.prototype._onCanPlayThrough = function() {
  this.emitSync(Event.INTERNAL_PLAYER_CANPLAYTHROUGH);
};

ACMEPlayer.prototype._onWaiting = function() {
  clearTimeout(this._syntheticEndedToken);
  if (this._player.seeking) {
    return;
  }
  this._getBufferingLatency()
    .then(function(ms) {
      this._tracker.trackMsStalled(ms);
    }.bind(this));
};

ACMEPlayer.prototype._onPlayedThresholdReached = function(e) {
  if (this._acmeTrack) {
    this.emit(Event.PLAYER_PLAYED_THRESHOLD_REACHED, {
      played: e.played,
      threshold: e.threshold,
      position: _secToMS(this._player.currentTime)
    });
  }
};

/**
 * Called internally by the _onEnded handler and the synthesized ended trigger.
 *
 * @protected
 */
ACMEPlayer.prototype._emitEnded = function() {
  if (this._acmeTrack.getMediaType() === 'video') {
    this.emit(Event.PLAYER_ENDED_VIDEO);
  }
  clearTimeout(this._pauseToken);
  this.emit(Event.PLAYER_ENDED);
};

/**
 * Emits an error event.
 *
 * @param {Error} error The error object.
 * @param {boolean} canPlayNext If true, the player can continue playing the
 *     next track.
 * @param {Object} trackData Optional additional data about the track.
 */
ACMEPlayer.prototype._emitError = function(error, canPlayNext, trackData) {
  debugLogger.error('Player Error', error, trackData, canPlayNext);
  this._tracker.setHadError(true);

  // If there's an error with the track, we remove it from the cache, which
  // ensures that the next time this track is played, we will be able to have
  // a fresh track instance.
  if (!this._disableCache && trackData && trackData.fileId) {
    this._cache.remove(trackData.fileId);
  }

  this.emit(Event.PLAYER_ERROR, {
    playId: this._playId,
    error: error,
    track: trackData,
    canPlayNext: canPlayNext,
    position: this._player ?
      _secToMS(this._player.currentTime) :
      0
  });
};

/**
 * Emits an warning event.
 *
 * @param {Error} error The error object.
 * @param {Object} trackData Optional additional data about the track.
 */
ACMEPlayer.prototype._emitWarning = function(error, trackData) {
  debugLogger.error('Player Warning', error, trackData, true);
  this._tracker.trackWarning();
  this.emit(Event.PLAYER_WARNING, {
    playId: this._playId,
    error: error,
    track: trackData,
    canPlayNext: true,
    position: _secToMS(this._player.currentTime)
  });
};

/**
 * Prepares a player that will be capable to play the provided track.
 *
 * @param {Object} loadingOptions The options for this playback.
 * @param {number} playId The id for playback.
 * @param {module:spotify-playback/_internal/track} acmeTrack The track to
 *     load.
 * @return {Promise} The promise.
 */
ACMEPlayer.prototype._prepareMediaElement = function(
  loadingOptions,
  playId
) {
  if (playId !== this._playId || !this._upcomingACMETrack) {
    debugLogger.info('Load ACMETrack dropped: playId has changed.');
    return Promise.resolve(false);
  }
  return this._recreateMediaElement(
    this._upcomingACMETrack.isProtected(),
    this._upcomingACMETrack.getPlayableCodecs(),
    playId,
    this._upcomingACMETrack.getMediaType()
  ).then(function(result) {
    if (!result || playId !== this._playId) {
      debugLogger.info(
        'Load ACMETrack dropped after recreate: playId has changed.'
      );
      return Promise.resolve(false);
    }
    var player = this._player;
    var ensureMediaKeys;
    if (
      player.withProtection &&
      this._emeManager &&
      (
        !player.mediaKeys ||
        player.mediaKeys.shouldRefreshPerTrack ||
        this._newMediaKeysPerTrack
      )
    ) {
      ensureMediaKeys = this._emeManager.createMediaKeys(player)
        .then(function() {
          return true;
        })
        .catch(function(error) {
          if (error.fatal) {
            error.fatal();
          } else {
            error.unrecoverable = true;
          }
          this._emitError(error, false, this._upcomingACMETrack.toLogJSON());
          return Promise.reject(error);
        }.bind(this));
    } else {
      ensureMediaKeys = Promise.resolve(true);
    }
    return ensureMediaKeys;
  }.bind(this));
};

ACMEPlayer.prototype._handleLoadingComplete = function(result) {
  var mediaType = this._acmeTrack.getMediaType();
  var videoContainer = this._getVideoContainer();
  if (
    mediaType === 'video' &&
    videoContainer &&
    this._player.parentNode !== videoContainer
  ) {
    videoContainer.appendChild(this._player);
    this.emit(Event.PLAYER_VIDEO_ELEMENT_APPENDED);
  }
  this._upcomingACMETrack = null;
  return result;
};

ACMEPlayer.prototype._handleLoadingError = function(uri, track, playId, error) {
  this._upcomingACMETrack = null;

  if (playId !== this._playId) {
    return Promise.resolve(false);
  }
  this._tracker.trackLoadFailed();
  this.emit(Event.PLAYER_LOADING_FAILED, {
    uri: uri,
    logData: track.logData
  });

  if (error) {
    // Log the errors
    var trackData = error.track || {
      uri: uri,
      fileId: track.fileId,
      format: track.format,
      deviceId: track.logData.deviceId
    };
    this._emitError(
      error,
      error instanceof StorageError ? error.canPlayNext : true,
      trackData
    );
  }

  return Promise.reject(error);
};

ACMEPlayer.prototype._handleLoadedMetadata = function(
  playId,
  logData,
  loadingOptions
) {
  if (playId !== this._playId) {
    debugLogger.info(
      'LoadedMetadata operations dropped: playId has changed.'
    );
    return;
  }
  this._loaded = true;

  var player = this._player;

  // Force this in case something was waiting for metadata.
  this._buffer.dequeueUpdates();

  var initialPosition = loadingOptions.position || 0;
  if (initialPosition > player.duration) {
    initialPosition = 0;
  }

  this._lastTimeUpdatePostion = 0;
  player.currentTime = initialPosition;
  this._tracker.trackLoadDone(_secToMS(player.currentTime));

  // MS browsers don't automatically fire a seeking event when the position is
  // set to 0, so we need to trigger timeupdate ourselves. This unfortunately
  // triggers a bug in other browsers where we append duplicates of the initial
  // fragment. We prevent this by triggering the initial timeupdate a few ms
  // later.
  setTimeout(this._onTimeUpdate.bind(this), 10);

  this.emitSync(Event.PLAYER_LOAD, {
    autoplay: loadingOptions.autoplay,
    position: initialPosition,
    logData: logData
  });

  // Play if autoplay
  if (loadingOptions.autoplay && !player.error) {
    var triggerPlay = function() {
      if (this._playId !== playId) {
        debugLogger.info('Play trigger dropped; different playId');
        return;
      }

      var playPromise = new Promise(function(resolve) {
        resolve(this._player.play());
      }.bind(this));

      playPromise
        .catch(function(e) {
          if (e) {
            if (e.name === 'NotSupportedError') {
              // There's an issue with the track, do not try to play it again.
              // Error will be emitted as part of the normal HTMLMediaElement
              // error event.
              return Promise.reject(e);
            } else if (e.name === 'NotAllowedError') {
              this.emit(Event.PLAYER_AUTOPLAY_FAILED);
              return Promise.reject(e);
            }
          }

          // This was added for cases where the original call to `play()` was
          // cancelled by a call to `pause()` somewhere.
          // FIXME: Verify whether this is still the case.
          return this._player.play();
        }.bind(this))
        .catch(function() {
          // Since we definitely cannot play, we should inform observers that we
          // were "paused" by the browser.
          this._onPause();
        }.bind(this));
    }.bind(this);

    if (player.readyState > 2) {
      debugLogger.info('Ready to play, triggering play.');
      triggerPlay();
    } else {
      debugLogger.info('Waiting to be playable.');
      this.once(Event.INTERNAL_PLAYER_CANPLAY, triggerPlay);
    }
  }
};

ACMEPlayer.prototype._handleCanPlayThrough = function(playId) {
  if (playId !== this._playId) {
    debugLogger.info(
      'CanPlayThrough operations dropped: playId has changed.'
    );
    return;
  }
  this._tracker.trackCanPlayThrough();
};

ACMEPlayer.prototype._loadACMETrack = function(
  loadingOptions,
  playId
) {
  if (playId !== this._playId || !this._upcomingACMETrack) {
    debugLogger.info('Load ACMETrack dropped: playId has changed.');
    return Promise.resolve(false);
  }

  this._canPreloadEmitted = false;
  var acmeTrack = this._upcomingACMETrack;
  this._upcomingACMETrack = null;
  this._acmeTrack = acmeTrack;

  var callback = loadingOptions.callback;
  this.once(Event.PLAYER_LOAD, function() {
    if (playId !== this._playId) {
      debugLogger.info('Load ACMETrack event dropped: playId has changed.');
      // Track changed, do not fire.
      return;
    }
    callback();
  }.bind(this));

  // We set the load emitter here to ensure that we trigger the loaded
  // event properly. This ensures that if a playback was cancelled, we will
  // not emit the loaded event for that track
  this.once(
    Event.INTERNAL_PLAYER_LOADED_METADATA,
    this._handleLoadedMetadata.bind(
      this,
      playId,
      this._acmeTrack.getLogData(),
      loadingOptions
    )
  );

  this.once(
    Event.INTERNAL_PLAYER_CANPLAYTHROUGH,
    this._handleCanPlayThrough.bind(this, playId)
  );

  var isProtected = acmeTrack.isProtected();
  this._tracker.setProtected(isProtected);

  if (acmeTrack instanceof ACMEVideoTrack) {
    return this._loadVideoTrack(loadingOptions, playId);
  } else if (!isProtected) {
    return this._loadUnprotectedTrack();
  }
  return this._loadProtectedTrack(loadingOptions, playId);
};

ACMEPlayer.prototype._getBufferingLatency = function() {
  return new Promise(function(resolve) {
    var bufferingStartTs = Date.now();
    this._player.addEventListener('canplaythrough', function onCanPlay() {
      this.removeEventListener('canplaythrough', onCanPlay);
      resolve(Date.now() - bufferingStartTs);
    });
  }.bind(this));
};

ACMEPlayer.prototype._loadVideoTrack = function(options, playId) {
  var acmeTrack = this._acmeTrack;
  debugLogger.info('_loadVideoTrack');

  this._buffer.once(Event.BUFFER_SOURCE_OPEN, function(_playId) {
    if (this._acmeTrack.isProtected()) {
      this._requestLicense(_playId);
    }
  }.bind(this, playId));

  this._player.src = global.URL.createObjectURL(this._buffer.getMediaSource());

  var videoProfile = acmeTrack.getVideoProfile();
  var audioProfile = acmeTrack.getAudioProfile();
  this._tracker.trackVideoLoadStart({
    bitrate: videoProfile.video_bitrate,
    audioProfile: audioProfile,
    videoProfile: videoProfile
  });

  this._tracker.trackBufferLoadStart();

  var initFragment = acmeTrack.getInitFragment();
  return this._buffer.appendFragment(acmeTrack, initFragment)
    .then(this._buffer.setDuration.bind(
      this._buffer,
      acmeTrack.getCalculatedDuration()
    ))
    .then(function() {
      if (this._subtitleLanguage) {
        this.setSubtitleLanguage(this._subtitleLanguage);
      }
      return Promise.resolve(true);
    }.bind(this))
    .then(this._onAppendedHeadSegment(playId));
};

/**
 * Loads a track that doesn't have EME protection.
 *
 * @return {boolean} True if the track was loaded, false otherwise.
 * @protected
 */
ACMEPlayer.prototype._loadUnprotectedTrack = function() {
  debugLogger.info('_loadUnprotectedTrack', this._acmeTrack.getURI());
  this._tracker.trackBufferLoadStart();

  var resolvedURL = this._acmeTrack.getResolvedURL();
  this._tracker.trackBufferURL(resolvedURL, {bandwidth: 0});
  this._player.src = resolvedURL;
  return true;
};

ACMEPlayer.prototype._onAppendedHeadSegment = function(playId) {
  return function() {
    if (playId !== this._playId) {
      return false;
    }
    if (this._player.spload) {
      this._player.spload();
    }
    debugLogger.info('Head segment appended.');
    return true;
  }.bind(this);
};

/**
 * Loads a track that has EME protection.
 *
 * @param {module:spotify-playback/player~LoadingOptions} options The
 *     loading options for the track.
 * @param {number} playId The id for playback.
 * @return {boolean} True if the track was loaded, false otherwise
 * @protected
 */
ACMEPlayer.prototype._loadProtectedTrack = function(
  options,
  playId
) {
  var acmeTrack = this._acmeTrack;
  debugLogger.info('_loadProtectedTrack', acmeTrack.getURI());

  this._buffer.once(
    Event.BUFFER_SOURCE_OPEN,
    this._requestLicense.bind(this, playId)
  );

  this._player.src = global.URL.createObjectURL(this._buffer.getMediaSource());

  this._tracker.trackBufferLoadStart();

  var initialAppend = null;
  var initialFragment = acmeTrack.getFragmentForTime(options.position || 0);

  if (initialFragment === acmeTrack.getFirstFragment()) {
    debugLogger.info('Appending combined init and playable fragment.');
    initialAppend = this._buffer.appendFragment(
      acmeTrack,
      acmeTrack.getHeadFragment()
    );
  } else {
    debugLogger.info('Appending split init and playable fragment.');
    initialAppend = Promise.all([
      // Request and append the head fragment
      this._buffer.appendFragment(acmeTrack, acmeTrack.getInitFragment()),

      // Request the initial fragment. This might seem redundant if the item
      // is already preloaded or cached, but this should be cheap.
      initialFragment ?
        acmeTrack.getBufferForFragment(initialFragment) :
        Promise.resolve(false)
    ]);
  }

  return initialAppend
    .then(this._onAppendedHeadSegment(playId))
    .then(function() {
      return Promise.resolve(playId === this._playId);
    }.bind(this));
};

ACMEPlayer.prototype._requestLicense = function(playId) {
  if (playId !== this._playId) {
    var msg = 'Request license dropped: playId has changed.';
    debugLogger.info(msg);
    return Promise.resolve(false);
  }
  var licenseRequestStart = Date.now();
  var mediaKeys = this._player.mediaKeys;

  var acmeTrack = this._acmeTrack;

  // Memory leak prevention: cache the local buffers as to not keep references
  // to AcmeTrack.
  var fileId = acmeTrack.getFileId();
  var logData = acmeTrack.getLogData();
  var trackLogJSON = acmeTrack.toLogJSON();
  var keySystem = acmeTrack.getKeySystem();

  var emeManager = this._emeManager;
  var tracker = this._tracker;
  tracker.setKeySystem(keySystem);
  tracker.setKeySystemImpl(emeManager.getKeySystemImpl());

  return Promise.all([
    acmeTrack.getLicenseEndpoint() || this._licenseURLResolver.get(
      keySystem,
      acmeTrack.getMediaType()
    ),
    acmeTrack.getInitParams()
  ])
    .spread(function(licenseURL, params) {
      tracker.setLicenseSessionLatency(Date.now() - licenseRequestStart);

      params.licenseServer = licenseURL.replace(/\{contentId\}/, fileId);
      params.playId = playId;
      params.mediaKeys = mediaKeys;
      return emeManager.createSessionWithParams(params);
    })
    .then(function(props) {
      if (playId !== this._playId) {
        debugLogger.info('License tracking dropped: playId has changed.');
        return Promise.resolve(false);
      }

      if (props && props.elapsed) {
        tracker.setLicenseGenerationLatency(props.elapsed.generate);
        tracker.setLicenseRequestLatency(props.elapsed.request);
        tracker.setLicenseUpdateLatency(props.elapsed.update);
      }

      var latency = Date.now() - licenseRequestStart;
      tracker.setKeyLatency(latency);
      this.emit(Event.PLAYER_KEY_RECEIVED, {
        requestTime: latency,
        logData: logData
      });
      debugLogger.info('License updated.');

      return Promise.resolve(true);
    }.bind(this))
    .catch(function(err) {
      if (!err || playId !== this._playId) {
        return Promise.resolve(false);
      }
      var canPlayNext = err && 'canPlayNext' in err ? err.canPlayNext : true;
      this._emitError(err, canPlayNext, trackLogJSON);
      return Promise.reject(err);
    }.bind(this));
};

/**
 * Handles a time update.
 *
 * @protected
 */
ACMEPlayer.prototype._onTimeUpdate = function() {
  if (!this._loaded) {
    return;
  }
  var bitrate = 0;
  var isSeeking = this._player.seeking;
  var currentTime = this._player.currentTime;
  var isVideo = this._acmeTrack.getMediaType() === 'video';

  if (isVideo) {
    bitrate = this._acmeTrack.getBitrateForTime(this._player.currentTime);
  }

  if (
    !isSeeking &&
    this._lastTimeUpdatePostion &&
    this._lastTimeUpdatePostion === currentTime) {
    // We got a duplicate event.
    debugLogger.warn('Dropping duplicate time update.');
    return;
  }
  this._lastTimeUpdatePostion = isSeeking ? 0 : currentTime;

  if (isVideo || this._acmeTrack.isProtected()) {
    // Only do buffer progress for protected tracks.
    this._buffer.progress(this._acmeTrack, isSeeking, currentTime, isVideo);
  }

  // Events
  var msTime = _secToMS(currentTime);
  var logData = this._acmeTrack ? this._acmeTrack.getLogData() : null;
  if (isSeeking) {
    this._tracker.trackPositionChanged(msTime, this._player.paused);
    this.emit(Event.PLAYER_POSITION_CHANGED, {
      position: msTime,
      logData: logData
    });
  } else {
    this._tracker.trackProgress(msTime, bitrate);
    this.emit(Event.PLAYER_PROGRESS, {
      timestamp: Date.now(),
      position: msTime,
      played: this._tracker.getMSPlayed(),
      interval: 500, // Dummy, as we no longer use it.
      logData: logData
    });
  }
  if (
    !this._canPreloadEmitted &&
    this._player.duration - currentTime <= CAN_PRELOAD_THRESHOLD
  ) {
    this._canPreloadEmitted = true;
    this.emit(Event.PLAYER_CAN_PRELOAD);
  } else {
    this._canPreloadEmitted = false;
  }

  // Synthesize ended events when necessary.
  clearTimeout(this._syntheticEndedToken);
  if (
    this._synthesizeEnded &&
    this._acmeTrack.isProtected() &&
    this._isPlaying()
  ) {
    this._syntheticEndedToken = setTimeout(
      this._onSyntheticEnded.bind(this),
      _secToMS(this._player.duration - currentTime)
    );
  }
};

/**
 * Returns whether the player is currently playing.
 *
 * @return {boolean} True if the player is playing, false otherwise.
 * @protected
 */
ACMEPlayer.prototype._isPlaying = function() {
  if (!this._player) {
    return false;
  }
  return !this._player.paused;
};

/**
 * Determines whether the next MediaError should be unrecoverable.
 *
 * @return {boolean} True if the next error should be fatal, false otherwise.
 * @protected
 */
ACMEPlayer.prototype._shouldNextErrorBeFatal = function() {
  var acmeTrack = this._acmeTrack;
  if (!acmeTrack || acmeTrack.isAd() || !acmeTrack.isProtected()) {
    return false;
  }

  var previousError = this._player.error;
  var ME = global.MediaError;
  if (!previousError || !(previousError instanceof ME)) {
    // Non-MediaErrors are most likely non-fatal.
    this._fatalOnNextError = false;
    return false;
  }

  switch (previousError.code) {
    case ME.MEDIA_ERR_SRC_NOT_SUPPORTED:
    case ME.MEDIA_ERR_DECODE:
      return true;

    default:
      return false;
  }
};

/**
 * Get the ID of the player.
 *
 * @return {string} Player ID
 */
ACMEPlayer.prototype.getId = function() {
  return this.id;
};

/**
 * Get information about the audio codec.
 * @return {module:spotify-playback/types.PlayerCodecInfo}
 */
ACMEPlayer.prototype.getCodecInfo = function() {
  return {
    audiocodec: 'mp3',
    bitrate: 160
  };
};

/**
 * Returns the instance's media source object.
 *
 * @return {MediaSource} The instance's internal media source object.
 * @protected
 */
ACMEPlayer.prototype.getMediaSource = function() {
  return this._buffer.getMediaSource();
};

ACMEPlayer.prototype.load = function(track, options, callback) {
  var opts = options || {};
  var uri = track[opts.uriProperty || 'uri'];
  debugLogger.info('load', uri);
  if (!uri) {
    return Promise.reject(
      new PlaybackError(
        Errors.PLAYER_CANNOT_FIND_PLAYABLE_URI,
        'Cannot find a playable URI.'
      )
    );
  }
  if (!track.logData) {
    return Promise.reject(Error('Invalid track: logging info not specified'));
  }


  this.stop(track.logData, track.mediaType);

  this._loaded = false;
  this._acmeTrack = null;
  var playId = ++this._playId;

  var tracker = this._tracker;

  tracker.trackLoadStart(
    uri,
    track.fileId,
    playId.toString(),
    track.logData
  );

  this.emit(Event.PLAYER_BEFORE_LOAD, {
    track: track,
    options: options,
    logData: track.logData,
    uri: uri,
    timestamp: Date.now()
  });

  this._buffer.setPlayId(playId);

  var loadingOptions = {
    position: _msToSec(opts.position || 0),
    autoplay: 'autoplay' in opts ? opts.autoplay : true,
    callback: callback || function() { }
  };

  // Set whether the user intends to play the track.
  tracker.setPlayIntended(loadingOptions.autoplay);

  tracker.setPlayedThreshold(opts.playedThreshold);

  var trackPromise;
  var cache = this._cache;

  if (track.mediaType === 'video' && !this._emeManager) {
    return Promise.reject(
      new PlaybackError(
        Errors.DISALLOW_PROTECTED_TRACK_ERROR,
        'Protected tracks not supported'
      )
    );
  }

  var createFn = track.mediaType === 'video' ?
    this._createVideoTrack.bind(this, track) :
    this._createAudioTrack.bind(this, uri, track, playId);

  var preloadingACMETrack = this._preloadingTracks[track.fileId];
  var cachedACMETrack = this._disableCache ? null : cache.get(track.fileId);
  if (preloadingACMETrack) {
    debugLogger.info('Waiting for preloading track.', track.fileId);
    trackPromise = preloadingACMETrack.then(
      function(measures) {
        debugLogger.info('Preloading succeeded.', track.fileId);
        tracker.setResolveLatency(measures.resolveLatency);
        tracker.setManifestLatency(measures.manifestLatency);
        return cache.get(track.fileId);
      },
      function() {
        // Catch an error
        debugLogger.info('Preloading failed, creating new track', track.fileId);
        return createFn();
      }
    );
  } else if (cachedACMETrack) {
    debugLogger.info('Using cached track.', track.fileId, cachedACMETrack);
    tracker.setMemoryCached(true);
    trackPromise = Promise.resolve(cachedACMETrack);
  } else {
    debugLogger.info('Creating new track', track.fileId);
    trackPromise = createFn();
  }

  return trackPromise
    .then(function(acmeTrack) {
      if (acmeTrack.isProtected() && !this._emeManager) {
        return Promise.reject(
          new PlaybackError(
            Errors.DISALLOW_PROTECTED_TRACK_ERROR,
            'Protected tracks not supported'
          )
        );
      }

      acmeTrack.setLogData(track.logData);
      tracker.setCalculatedDuration(
        _secToMS(acmeTrack.getCalculatedDuration())
      );

      this._upcomingACMETrack = acmeTrack;
      return Promise.resolve();
    }.bind(this))
    .then(this._prepareMediaElement.bind(this, loadingOptions, playId))
    .then(this._loadACMETrack.bind(this, loadingOptions, playId))
    .then(
      this._handleLoadingComplete.bind(this),
      this._handleLoadingError.bind(this, uri, track, playId)
    );
};

ACMEPlayer.prototype.preload = function(track) {
  var uri = track.playableURI;
  var fileId = track.fileId;
  var cache = this._cache;

  if (!fileId) {
    return Promise.resolve(false);
  }

  if (!this._emeManager) {
    return Promise.resolve(false);
  }

  var canCache = !this._disableCache;
  var isVideo = track.mediaType === 'video';

  // Unencrypted MP3s cannot be preloaded because the URL will expire.
  var canPreloadFormat = track.format === 'MP4' || track.format === 'MP4_DUAL';

  var shouldPreload = canCache && canPreloadFormat && !isVideo;
  if (!shouldPreload || (canCache && cache.get(fileId))) {
    return Promise.resolve(false);
  }

  var preloadingTracks = this._preloadingTracks;
  if (preloadingTracks[fileId]) {
    return preloadingTracks[fileId];
  }

  debugLogger.info('Preloading track', fileId);

  var measures = {
    manifestLatency: 0,
    resolveLatency: 0
  };

  var preloadingPromise = this._emeManager
    .getKeySystemInfo()
    .then(function(config) {
      var acmeTrack = ACMETrack.create({
        abrManager: this._abrManager,
        keySystem: config.keySystem,
        licenseEndpoint: track.licenseEndpoint,
        transport: this._transport,
        resolver: this._audioResolver,
        uri: uri,
        fileId: fileId,
        format: track.format,
        isAd: track.isAd,
        resolvedURL: track.resolvedURL,
        noManifest: track.noManifest,
        preloadedManifest: track.preloadedManifest,
        logData: track.logData,
        disableCache: this._disableCache,
        emitWarning: this._emitWarning.bind(this)
      });
      return acmeTrack.load(measures);
    }.bind(this))
    .then(function(acmeTrack) {
      return Promise.all([
        acmeTrack,
        acmeTrack.getBufferForFragment(acmeTrack.getHeadFragment())
      ]);
    })
    .spread(function(acmeTrack) {
      cache.set(fileId, acmeTrack);
      preloadingTracks[fileId] = null;
      debugLogger.info('Cached', fileId);
      return measures;
    })
    .catch(function(e) {
      preloadingTracks[fileId] = null;
      this.emit(Event.PLAYER_PRELOADING_ERROR, {
        error: e,
        track: e.track || null,
        canPlayNext: 'canPlayNext' in e ? e.canPlayNext : true,
        preloading: true
      });
      return Promise.reject(e);
    }.bind(this));

  preloadingTracks[fileId] = preloadingPromise;
  return preloadingPromise;
};

/**
 * Toggle between playing / paused.
 *
 * Pauses the player if it is playing. Resumes playback if the player is paused.
 */
ACMEPlayer.prototype.togglePlay = function() {
  if (!this._isPlaying()) {
    this.resume();
  } else {
    this.pause();
  }
};

/**
 * Set language to use for subtitles.
 *
 * @param {string} code Language code.
 */
ACMEPlayer.prototype.setSubtitleLanguage = function(code) {
  this._subtitleLanguage = code;
  if (this._acmeTrack.getMediaType() !== 'video') {
    return;
  }
  var available = this._acmeTrack.getSubtitleLanguages();
  if (available.indexOf(code) < 0) {
    debugLogger.warn('No available subtitle for language: ', code);
    return;
  }
  var track = document.createElement('track');
  track.label = code + ' subtitles';
  track.kind = 'subtitles';
  track.srclang = code;
  track.src = this._acmeTrack.getSubtitleForLanguage(code);
  this._player.appendChild(track);
  if (this._subtitlesVisible) {
    this.showSubtitles();
  }
};

/**
 * Set language to use for subtitles.
 *
 * @return {Array.<string>} List of languages available for the current track.
 */
ACMEPlayer.prototype.getSubtitleLanguages = function() {
  return this._acmeTrack.getMediaType() === 'video' ?
    this._acmeTrack.getSubtitleLanguages() :
    [];
};


/**
 * Set the volume of the player.
 *
 * @param {number} amount Volume between 0.0 (silent) and 1.0 (loudest).
 */
ACMEPlayer.prototype.setVolume = function(amount) {
  var ev = this.emitSync(Event.PLAYER_BEFORE_VOLUME_CHANGE, {volume: amount});
  if (ev.defaultPrevented) {
    return;
  }
  if (amount < 0 || amount > 1) {
    throw new PlaybackError(
      Errors.PLAYER_ATTEMPTED_VOLUME_OUT_OF_RANGE,
      'Volume should be in range [0, 1]'
    );
  }
  this._playerVolume = amount;
  if (this._player) {
    this._player.volume = this._cubicVolume ? amount * amount * amount : amount;
  }
};

/**
 * Get the current volume of the player.
 *
 * @return {number} Volume between 0.0 (silent) and 1.0 (loudest).
 */
ACMEPlayer.prototype.getVolume = function() {
  return this._playerVolume;
};

/**
 * Get the state of the player.
 *
 * @return {module:spotify-playback/types.PlayerState}
 */
ACMEPlayer.prototype.getPlayerState = function() {
  var player = this._player;
  return {
    playing: this._isPlaying(),
    position: !player ? 0 : _secToMS(player.currentTime),
    duration: !player ? 0 : _secToMS(player.duration),
    volume: !player ? 1 : this._playerVolume
  };
};

/**
 * Seek in a track.
 *
 * @todo Consider having the position in seconds instead?
 * @param  {number} position The position to play from (in milliseconds)
 */
ACMEPlayer.prototype.seek = function(position) {
  if (!this._player) {
    return;
  }
  var playId = this._playId;
  var seeker = function() {
    if (playId !== this._playId) {
      debugLogger.info('Seek dropped: playId has changed.');
      return;
    }
    var posInSec = _msToSec(position);
    if (posInSec < 0) {
      posInSec = 0;
    } else if (posInSec >= this._player.duration) {
      posInSec = this._player.duration;
    }
    this._player.currentTime = posInSec;
  }.bind(this);
  if (!this._loaded) {
    this.once(Event.PLAYER_LOAD, seeker);
  } else {
    seeker();
  }

  this._getBufferingLatency()
    .then(function(ms) {
      this._tracker.trackSeekRebuffering(ms);
    }.bind(this));
};

/**
 * Pause playback of the track.
 */
ACMEPlayer.prototype.pause = function() {
  if (this._player && this._isPlaying()) {
    new Promise(function(resolve) {
      resolve(this._player.pause());
    }.bind(this)).catch(function() {
      // Noop
    });
  }
};

/**
 * Resume playback of the track.
 */
ACMEPlayer.prototype.resume = function() {
  if (this._player && !this._isPlaying()) {
    new Promise(function(resolve) {
      resolve(this._player.play());
    }.bind(this)).catch(function() {
      // Noop
    });
  }
};

/**
 * Stop playback.
 *
 * Unloads the track from the media element.
 *
 * @override
 * @inheritDoc
 */
ACMEPlayer.prototype.stop = function(logData, nextMediaType) {
  var promises = [];
  var _logData = logData || {};
  this.emit(Event.PLAYER_BEFORE_STOP, {
    timestamp: Date.now(),
    logData: _logData
  });
  this._tracker.trackStopped(logData);
  this._buffer.abort(true);

  // Destroy all media key sessions.
  if (this._emeManager) {
    promises.push(this._emeManager.destroySessions());
  }

  if (this._player) {
    this._fatalOnNextError = this._shouldNextErrorBeFatal();

    if (this._fatalOnNextError) {
      debugLogger.warn(
        'MediaError detected: next immediate media error will be fatal.'
      );
    }

    var url = this._player.src;
    if (BLOB_URL_EXP.test(url)) {
      // Only revoke Blob URLs, otherwise we get warnings on some browsers.
      global.URL.revokeObjectURL(url);
    }
    this._player.removeAttribute('src');
    this._player.load();
  }

  if (this._acmeTrack && this._disableCache) {
    this._acmeTrack.clearCachedBuffers();
  }
  if (this._acmeTrack && this._acmeTrack.getMediaType() === 'video') {
    var textTracks = this._player.children;
    for (var i = 0, len = textTracks.length; i < len; i++) {
      this._player.removeChild(textTracks[i]);
    }
    var videoContainer = this._getVideoContainer();
    if (
      videoContainer &&
      this._player.parentNode === videoContainer &&
      (
        this._newElementPerTrack ||
        nextMediaType !== 'video'
      )
    ) {
      videoContainer.removeChild(this._player);
      this.emit(Event.PLAYER_VIDEO_ELEMENT_REMOVED);
    }
  }
  this.emit(Event.PLAYER_STOPPED);
  return Promise.all(promises).then(function() {
    return true;
  });
};

/**
 * Hide subtitles.
 */
ACMEPlayer.prototype.hideSubtitles = function() {
  var tracks = this._player.textTracks;
  for (var i = 0, len = tracks.length; i < len; i++) {
    tracks[i].mode = SubtitleMode.HIDDEN;
  }
  this._subtitlesVisible = false;
};

/**
 * Show subtitles.
 */
ACMEPlayer.prototype.showSubtitles = function() {
  var tracks = this._player.textTracks;
  for (var i = 0, len = tracks.length; i < len; i++) {
    var track = tracks[i];
    if (track.language === this._subtitleLanguage) {
      track.mode = SubtitleMode.SHOWING;
    } else {
      track.mode = SubtitleMode.HIDDEN;
    }
  }
  this._subtitlesVisible = true;
};

/**
 * Returns the KeySystemInfo associated with the current player.
 *
 * @return {Promise.<?module:spotify-playback/types.KeySystemInfo>}
 *      The key system info.
 */
ACMEPlayer.prototype.getKeySystemInfo = function() {
  return this._emeManager ?
    this._emeManager.getKeySystemInfo() :
    Promise.resolve(null);
};

module.exports = ACMEPlayer;
