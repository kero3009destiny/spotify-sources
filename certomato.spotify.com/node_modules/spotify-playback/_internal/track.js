'use strict';

var Base64 = require('spotify-crypto/base64');
var Promise = require('spotify-promise-plus');

var FragmentError = require('../lib/fragment_error');
var FileError = require('../lib/file_error');
var Errors = require('../types/errors');

var KeySystemSetting = require('./keysystem_setting');
var KeySystem = require('./../types/keysystem');

/**
 * The length of the audio fragments.
 */
var FRAGMENT_LENGTH = 10;

/* eslint-disable */
var DEFAULT_PSSH_BOX = 'AAAAT3Bzc2gAAAAA7e+LqXnWSs6jyCfc1R0h7QAAAC8IARIQjkdvXv0rqMqeUvuJdEQ6BxoHc3BvdGlmeSIQU5XxcNx4EeWn2APhWavFng==';
/* eslint-enable*/

var DEFAULT_FRONT_PADDING_DURATION = 1024 / 44100; // samples / samplerate

/**
 * The minimum amount of time between two resolve requests before we get a new
 * URL from the Storage Resolve service.
 *
 * @const
 */
var MINIMUM_RESOLVE_THRESHOLD = 1001;


/**
 * An object representation of a track that can be played by the ACMEPlayer.
 *
 * This class also manages the fragments for protected tracks encoded as CENC.
 *
 * @constructor
 * @param {module:spotify-playback/types/media~ACMETrackOptions}
 *     options The options for this instance.
 */
function ACMETrack(options) {
  /**
   * The current keysystem.
   *
   * @type {string}
   * @protected
   */
  this._keySystem = options.keySystem;

  /**
   * The keySystem settings for the keySystem.
   *
   * @type {module:spotify-playback/_internal/protection.KeySystemSetting}
   * @protected
   */
  this._keySystemSettings = KeySystemSetting[this._keySystem];

  /**
   * Bandwidth estimator instance.
   *
   * @see {module:spotify-playback/_internal/bandwidth_estimator}
   * @protected
   */
  this._abrManager = options.abrManager;

  /**
   * The media type of the track.
   *
   * @type {string}
   * @protected
   */
  this._mediaType = 'audio';

  /**
   * The URI for the track.
   *
   * @type {string}
   * @protected
   */
  this._uri = options.uri;

  /**
   * The file id of the track.
   *
   * @type {string}
   * @protected
   */
  this._fileId = options.fileId;

  /**
   * The format of this track.
   *
   * @type {string}
   * @protected
   */
  this._format = options.format;

  /**
   * True if track is an ad.
   *
   * @type {bool}
   * @protected
   */
  this._isAd = options.isAd;

  /**
   * An instance of transport that can be used to make requests.
   *
   * @type {module:spotify-transport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * A track-to-CDN resolver.
   *
   * @type {module:spotify-playback/types.StorageResolver}
   * @protected
   */
  this._resolver = options.resolver;

  /**
   * The CDN URL of the track.
   *
   * @type {string}
   * @protected
   */
  this._resolvedURL = options.resolvedURL;

  /**
   * A list of fallback URLs.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._fallbackURLs = [];

  /**
   * The full list of resolved URLs.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._resolvedURLs = [];

  /**
   * The LogData associated with this track.
   *
   * @type {Object}
   * @protected
   */
  this._logData = options.logData || {};

  /**
   *
   * @type {string}
   * @protected
   */
  this._codec = options.codec || ACMETrack.PROTECTED_CODEC;

  /**
   * When set to true, calls to `resolve` are no-op.
   *
   * @type {boolean}
   * @protected
   */
  this._bypassResolve = !!this._resolvedURL;

  /**
   * When set to true, the track will be played without using a manifest.
   *
   * @type {boolean}
   * @protected
   */
  this._noManifest = options.noManifest || false;

  /**
   * Preloaded manifest for this track.
   *
   * @type {?Object=}
   * @protected
   */
  this._preloadedManifest = options.preloadedManifest || null;

  /**
   * When set to true, the track's buffers will not be cached.
   *
   * @type {boolean}
   * @protected
   */
  this._disableCache = options.disableCache;

  /**
   * Function used for non-blocking warning emits.
   *
   * @type {Function}
   * @protected
   */
  this._emitWarning = options.emitWarning || function() {};

  /**
   * The protection type for the file.
   *
   * @type {string}
   * @protected
   */
  this._protection = null;

  /**
   * The PSSH Box containing the protection details for the track.
   *
   * @type {ArrayBuffer}
   * @protected
   */
  this._psshBox = null;

  /**
   * An array containing the different fragments for the track.
   *
   * @type {Array.<module:spotify-playback/types/media~TrackFragment>}
   * @protected
   */
  this._fragments = null;

  /**
   * The calculated duration of the track.
   *
   * @type {number}
   * @protected
   */
  this._duration = 0;

  /**
   * The duration of the front padding.
   *
   * @type {number}
   * @protected
   */
  this._frontPaddingDuration = 0;

  /**
   * The duration of the end padding.
   *
   * @type {number}
   * @protected
   */
  this._endPaddingDuration = 0;

  /**
   * The "init fragment" of the track. Contains metadata about the track's
   * protection as well as the sidx table.
   *
   * @type {module:spotify-playback/types/media~TrackFragment}
   * @protected
   */
  this._initFragment = null;

  /**
   * The buffer for the "head fragment" of the track, which is the "init
   * fragment" plus the first playable fragment of the track.
   *
   * @type {ArrayBuffer}
   * @protected
   */
  this._headFragment = null;

  /**
   * An array containing the fragments that are currently being fetched.
   *
   * @type {Array.<module:spotify-playback/types/media~TrackFragment>}
   * @protected
   */
  this._fetching = [];

  /**
   * A flag indicating whether this instance's load method has been called
   * successfully.
   *
   * @type {boolean}
   * @protected
   */
  this._loaded = false;

  /**
   * The last timestamp for when resolve() was called.
   *
   * @type {number}
   * @protected
   */
  this._lastResolveTimestamp = 0;

  /**
   * The last `setTimeout` token for the last resolve call.
   *
   * @type {number}
   * @protected
   */
  this._lastResolveToken = null;

  /**
   * Optional license server url.
   *     If unset, the default one in license_url_resolver will be used.
   *
   * @type {?string}
   * @protected
   */
  this._licenseEndpoint = options.licenseEndpoint || null;
}

/**
 * Creates a new ACMETrack
 *
 * @param {module:spotify-playback/types/media~ACMETrackOptions}
 *     options The options for this instance.
 * @static
 * @return {module:spotify-playback/_internal/track}
 */
ACMETrack.create = function(options) {
  return new ACMETrack(options || {});
};

/**
 * Default unprotected codec for mp3s.
 *
 * @type {string}
 * @static
 */
ACMETrack.UNPROTECTED_CODEC = 'audio/mpeg';

/**
 * Default protected codec for mp3s.
 *
 * @type {string}
 * @static
 */
ACMETrack.PROTECTED_CODEC = 'audio/mp4; codecs="mp4a.40.2"';

/**
 * Resolves the track's URI to a CDN URL.
 *
 * @param {Object} measures A reference to an object where latency measurements
 *     will be stored.
 * @return {Promise.<Object>} The resolution object from Storage Resolve.
 * @public
 */
ACMETrack.prototype.resolve = function(measures) {
  if (this._bypassResolve) {
    if (measures) {
      measures.resolveLatency = 0;
    }
    // If a resolvedURL was passed during the creation of the track, we
    // disregard any calls to resolve().
    return Promise.resolve({
      lid: null,
      uri: this._resolvedURL,
      protection: !!this._preloadedManifest || !this._noManifest
    });
  }
  clearTimeout(this._lastResolveToken);
  var resolver = function() {
    this._lastResolveTimestamp = Date.now();
    return this._resolver.getCDNURL(this._uri, this._fileId, this._keySystem)
      .then(function(data) {
        if (measures) {
          measures.resolveLatency = Date.now() - this._lastResolveTimestamp;
        }
        return data;
      }.bind(this));
  }.bind(this);

  var elapsedSinceLastResolve = Date.now() - this._lastResolveTimestamp;
  var resolverPromise;
  if (elapsedSinceLastResolve < MINIMUM_RESOLVE_THRESHOLD) {
    resolverPromise = new Promise(function(resolve, reject) {
      this._lastResolveToken = setTimeout(function() {
        resolver().then(resolve, reject);
      }, MINIMUM_RESOLVE_THRESHOLD - elapsedSinceLastResolve);
    }.bind(this));
  } else {
    resolverPromise = resolver();
  }

  return resolverPromise.then(function(data) {
    this._resolvedURLs = [];
    for (var i = 0, len = data.uris.length; i < len; i++) {
      // We're triming these urls from any query params (tokens et al) that
      // are contained in the urls in the response.
      var trimmed = data.uris[i].split('?')[0];
      this._resolvedURLs.push(trimmed);
    }
    this._fallbackURLs = data.uris;
    this._resolvedURL = this._fallbackURLs.shift();
    return data;
  }.bind(this)).catch(function(e) {
    if (e) {
      e.track = this.toLogJSON();
    }
    return Promise.reject(e);
  }.bind(this));
};

/**
 * Parses a base64 encoded PSSH box and converts it into a Uint8Array.
 *
 * @param {string} psshBox A base64 encoded PSSH Box.
 * @return {Uint8Array} The decoded PSSH Box.
 */
ACMETrack.prototype._parsePSSHBox = function(psshBox) {
  var decoded = Base64.decode(psshBox);
  var box = new global.Uint8Array(decoded.length);
  for (var i = 0, l = decoded.length; i < l; i++) {
    box[i] = decoded.charCodeAt(i);
  }
  return box;
};

/**
 * Load an ACMEVideoTrack.
 *
 * @param {?object=} measures Object containing latency measurements used for
 *     logging.
 * @return {Promise<module:spotify-playback/types/media~TrackDescriptor>} The
 *     manifest.
 */
ACMETrack.prototype._getManifest = function(measures) {
  if (this._noManifest) {
    if (measures) {
      measures.manifestLatency = 0;
    }
    return Promise.resolve(null);
  }

  if (this._preloadedManifest) {
    if (measures) {
      measures.manifestLatency = 0;
    }
    return Promise.resolve(this._preloadedManifest);
  }

  var timeStart = Date.now();
  return this._resolver.getManifest(this._fileId, this._keySystem)
    .then(function(descriptor) {
      if (measures) {
        measures.manifestLatency = Date.now() - timeStart;
      }
      return descriptor;
    });
};

/**
 * Calculates the different fragments from the descriptor.
 *
 * @param {module:spotify-playback/types/media~TrackDescriptor} descriptor
 *     The descriptor for the track.
 */
ACMETrack.prototype._calculateFragments = function(descriptor) {
  // Offset is the start of the first fragment.
  var offset = descriptor.offset;

  // Initialization fragment. Used to initialize audio.
  this._initFragment = {
    init: true,
    cacheBuffer: !this._disableCache,
    bufferURL: null,
    buffer: null,
    byteStart: 0,
    byteEnd: offset - 1,
    codec: this._codec
  };

  var segments = descriptor.segments;
  var timescale = descriptor.timescale;
  var time = 0;
  var refLength = segments.length;
  var fragments = new Array(refLength);
  var totalDuration = 0;
  for (var i = 0, l = refLength; i < l; i++) {
    var segment = segments[i];
    var segmentSize = segment[0];
    var segmentDuration = segment[1];
    var duration = segmentDuration / timescale;
    fragments[i] = {
      cacheBuffer: !i && !this._disableCache,
      bufferURL: null,
      buffer: null,
      byteStart: offset,
      byteEnd: offset + (segmentSize - 1),
      timeStart: time,
      timeEnd: time + duration,
      codec: this._codec
    };
    offset = offset + segmentSize;
    totalDuration += segmentDuration;
    time += duration;
  }
  var byteEnd = fragments[fragments.length - 1].byteEnd;
  fragments[fragments.length - 1].isLastFragment = true;
  this._fragments = fragments;
  this._duration = totalDuration / timescale;
  this._frontPaddingDuration = DEFAULT_FRONT_PADDING_DURATION;
  this._endPaddingDuration = (2048 + (1024 - (byteEnd % 1024))) / timescale;
};

/**
 * Calculates the different fragments from the descriptor.
 *
 * @param {module:spotify-playback/types/media~TrackDescriptor} descriptor
 *     The descriptor for the track.
 */
ACMETrack.prototype._calculateFragmentsV1 = function(descriptor) {
  // Offset is the start of the first fragment.
  var offset = descriptor.offset;

  // Initialization fragment. Used to initialize audio.
  this._initFragment = {
    init: true,
    cacheBuffer: !this._disableCache,
    buffer: null,
    byteStart: 0,
    byteEnd: offset - 1,
    codec: this._codec
  };

  var references = descriptor.references;
  var timescale = descriptor.timescale;
  var time = 0;
  var refLength = references.length;
  var fragments = new Array(refLength);
  var totalDuration = 0;
  for (var i = 0, l = refLength; i < l; i++) {
    var reference = references[i];
    var duration = reference.duration / timescale;
    fragments[i] = {
      cacheBuffer: !i && !this._disableCache,
      buffer: null,
      byteStart: offset,
      byteEnd: offset + (reference.size - 1),
      timeStart: time,
      timeEnd: time + duration,
      codec: this._codec
    };
    offset = offset + reference.size;
    totalDuration += reference.duration;
    time += duration;
  }
  fragments[fragments.length - 1].isLastFragment = true;
  this._fragments = fragments;
  this._duration = totalDuration / timescale;
};

/**
 * Returns the length of audio fragments.
 *
 * @return {number} The average length of fragments.
 */
ACMETrack.prototype.getFragmentLength = function() {
  return FRAGMENT_LENGTH;
};

/**
 * Returns the optional property value for the license server url.
 *
 * @return {?string} The endpoint url if it's set.
 */
ACMETrack.prototype.getLicenseEndpoint = function() {
  return this._licenseEndpoint;
};

/**
 * Fetches and returns an array buffer containing the bytes for a particular
 * fragment.
 *
 * @param {module:spotify-playback/types/track~track-Fragment} fragment The
 *     fragment to fetch.
 * @return {Promise.<ArrayBuffer>} The bytes of the fragment as an array buffer.
 */
ACMETrack.prototype.getBufferForFragment = function(fragment) {
  if (!fragment) {
    return null;
  }
  if (fragment.buffer) {
    return Promise.resolve({
      audio: {
        bufferURL: fragment.bufferURL,
        buffer: fragment.buffer,
        codec: this._codec,
        bandwidth: null
      }
    });
  }
  if (!this._resolvedURL) {
    return Promise.reject(
      new FileError(
        Errors.FILE_NOT_RESOLVED,
        'Cannot fetch buffer: No resolved URL'
      )
    );
  }
  var canceller = Promise.defer();
  this._startFetching(canceller.resolve);
  var expectedLength = (fragment.byteEnd + 1) - fragment.byteStart;
  var byteRange = fragment.byteStart + '-' + fragment.byteEnd;
  var timeRange = fragment.timeStart + '-' + fragment.timeEnd;

  var hasFallback; // Used for fallback checking

  var requestURL = this._resolvedURL;
  return this._transport.request(requestURL, {
    method: 'GET',
    responseType: 'arraybuffer',
    headers: {
      'Range': 'bytes=' + byteRange
    },
    timing: true,
    canceller: canceller.promise,
    retry: {
      condition: function(response, StatusFamily) {
        if (response.status === 0) {
          return response.offline; // retry only if client is offline.
        }
        var statusFamily = response.getStatusFamily();
        if (statusFamily === StatusFamily.CONNECTION_ERROR ||
            statusFamily === StatusFamily.SERVER_ERROR) {
          return true;
        }
        if (statusFamily === StatusFamily.SUCCESS && response.body) {
          return response.body.byteLength !== expectedLength;
        }
        return false;
      }
    }
  }).then(function(response) {
    this._endFetching(canceller.resolve);
    switch (response.status) {
      case 0:
        if (response.offline) {
          return Promise.reject(new FragmentError(
            Errors.FRAGMENT_OFFLINE_REQUEST_FAILED_WITH_ZERO,
            'Request failed with status 0.',
            0,
            {
              time_range: timeRange,
              byte_range: byteRange
            }
          ));
        }

        var fragmentErrorOnline = new FragmentError(
          Errors.FRAGMENT_ONLINE_REQUEST_FAILED_WITH_ZERO,
          'Request failed with status 0.',
          0
        );

        hasFallback = false;
        if (this._resolvedURL !== requestURL) {
          // The fallback has been triggered by a parallel request, retry with
          // the fallback.
          hasFallback = true;
        } else if (
          this._fallbackURLs.length &&
          this._resolvedURL === requestURL
        ) {
          // If there are fallback URLs, we should retry. Also, ensure to only
          // do the retry if it hasn't been done so by any parallel requests.
          hasFallback = true;
          this._resolvedURL = this._fallbackURLs.shift();
        }

        fragmentErrorOnline.debug.has_fallback = hasFallback;

        if (hasFallback) {
          this._emitWarning(fragmentErrorOnline, this.toLogJSON());
          return this.getBufferForFragment(fragment);
        }

        return Promise.reject(fragmentErrorOnline);
      case 200:
      case 206:
        if (!response.body) {
          return Promise.reject(
            new FragmentError(
              Errors.FRAGMENT_REQUEST_EMPTY_RESPONSE,
              'Empty response for successful buffer.',
              response.status,
              {
                time_range: timeRange,
                byte_range: byteRange
              }
            )
          );
        }
        var buffer = response.body;
        if (buffer.byteLength !== expectedLength) {
          return Promise.reject(
            new FragmentError(
              Errors.FRAGMENT_REQUEST_UNEXPECTED_LENGTH,
              'Received buffer of unexpected length.',
              response.status,
              {
                time_range: timeRange,
                byte_range: byteRange,
                received_length: buffer.byteLength,
                expected_length: expectedLength
              }
            )
          );
        }
        if (fragment.cacheBuffer && buffer && buffer.byteLength) {
          fragment.bufferURL = requestURL;
          fragment.buffer = buffer;

          var sliceInto = fragment.sliceInto;
          if (sliceInto && sliceInto.length) {
            for (var i = 0, l = fragment.sliceInto.length; i < l; i++) {
              var sliced = sliceInto[i];
              if (!sliced.fragment || !sliced.fragment.cacheBuffer) {
                continue;
              }
              sliced.fragment.bufferURL = requestURL;
              sliced.fragment.buffer = buffer.slice(sliced.start, sliced.end);
            }
          }
        }

        this._abrManager.sample(buffer.byteLength, response.timing.completed);

        return {
          audio: {
            bufferURL: requestURL,
            buffer: buffer,
            codec: this._codec,
            bandwidth: 8000 * buffer.byteLength / response.timing.completed
          }
        };

      case 403:
        // Track has expired, request new CDN URL. Note that we do not use the
        // fallback URLs as they were requested at the same time, and are most
        // likely also expired at this point.
        return this.resolve().then(function() {
          return this.getBufferForFragment(fragment);
        }.bind(this));
      default:
        hasFallback = false;
        if (this._resolvedURL !== requestURL) {
          hasFallback = true;
        } else if (
          this._fallbackURLs.length &&
          this._resolvedURL === requestURL
        ) {
          hasFallback = true;
          this._resolvedURL = this._fallbackURLs.shift();
        }

        return hasFallback ?
          this.getBufferForFragment(fragment) :
          Promise.reject(
            new FragmentError(
              Errors.FRAGMENT_REQUEST_FAILED_WITH_STATUS,
              'Buffer request failed with status ' + response.status,
              response.status,
              {
                time_range: timeRange,
                byte_range: byteRange
              }
            )
          );
    }
  }.bind(this));
};

/**
 * Starts fetching a buffer's xhr.
 *
 * @param {XMLHttpRequest} resolver The request.
 */
ACMETrack.prototype._startFetching = function(resolver) {
  this._fetching.push(resolver);
};

/**
 * Ends fetching a buffer's xhr.
 *
 * @param {XMLHttpRequest} resolver The request.
 */
ACMETrack.prototype._endFetching = function(resolver) {
  var index = this._fetching.indexOf(resolver);
  if (index === -1) {
    return;
  }
  this._fetching.splice(index, 1);
};

/**
 * Returns the URI for the track.
 *
 * @return {string} The track's URI.
 */
ACMETrack.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the resolved URLs for the tracks file, for logging purposes.
 *
 * @return {Array.<string>} The list of urls.
 */
ACMETrack.prototype.getResolvedURLs = function() {
  return this._resolvedURLs;
};

/**
 * Returns the file id for the file.
 *
 * @return {string} The file id.
 */
ACMETrack.prototype.getFileId = function() {
  return this._fileId;
};

/**
 * Returns the format for the file.
 *
 * @return {string} The format for the file.
 */
ACMETrack.prototype.getFormat = function() {
  return this._format;
};

/**
 * Returns the duration based on the segments.
 *
 * @return {number} The duration of the file.
 */
ACMETrack.prototype.getCalculatedDuration = function() {
  return this._duration;
};

/**
 * Returns the resolved URL (i.e., CDN URL) for the track.
 *
 * @return {string} The track's resolved URI.
 */
ACMETrack.prototype.getResolvedURL = function() {
  return this._resolvedURL;
};

/**
 * Returns the LogData for this track.
 *
 * @return {Object} The LogData for the track.
 */
ACMETrack.prototype.getLogData = function() {
  return this._logData;
};

/**
 * Returns the keysystem for the ACMETrack.
 *
 * @return {string} The keysystem.
 */
ACMETrack.prototype.getKeySystem = function() {
  return this._keySystem;
};

/**
 * Returns the media type for the ACMETrack.
 *
 * @return {string} The type name.
 */
ACMETrack.prototype.getMediaType = function() {
  return this._mediaType;
};

/**
 * Returns the init params for the track, used for EME.
 *
 * @return {module:spotify-playback/types/media~TrackInitParams} The init
 *     params for the track.
 */
ACMETrack.prototype.getInitParams = function() {
  var initData = {
    keySystem: this._keySystem,
    initDataType: this._protection,
    initData: this._psshBox,
    licenseServer: null
  };
  return Promise.resolve(initData);
};

/**
 * Returns whether the track is an ad.
 *
 * @return {boolean} True if the track is an ad.
 */
ACMETrack.prototype.isAd = function() {
  return !!this._isAd;
};

/**
 * Returns whether the track has any protection.
 *
 * @return {boolean} True if the track has an associated protection, false
 *     otherwise.
 */
ACMETrack.prototype.isProtected = function() {
  return !!this._protection && !!this._psshBox;
};

/**
 * Set LogData for the track.
 *
 * @param {Object} logData The logData object to attach to this instance.
 * @return {ACMETrack} This instance, for chaining.
 */
ACMETrack.prototype.setLogData = function(logData) {
  this._logData = logData;
  return this;
};

/**
 * Loads the descriptor for the track and processes it.
 *
 * For most cases, you will call this method right after you instantiate
 * ACMETrack.
 *
 * @param {Object} measures A reference to an object where latency measurements
 *     will be stored.
 * @return {module:spotify-playback/_internal/track} Returns the ACMETrack
 *     instance.
    tracker.trackMan
 */
ACMETrack.prototype.load = function(measures) {
  var _measures = measures || {};

  if (this._loaded) {
    _measures.resolveLatency = 0;
    _measures.manifestLatency = 0;
    return Promise.resolve(this);
  }

  return Promise.all([
    this.resolve(_measures),
    this._getManifest(_measures)
  ]).spread(function(data, descriptor) {
    this._loaded = true;
    if (!data.protection || !descriptor) {
      return this;
    }

    // This protected track was loaded on a player that does not
    // support protected tracks. We set these dummy values to
    // ensure that `isProtected()` will still return true, but as this
    // track is not going to be played, these values should not matter.
    if (this._keySystem === KeySystem.INVALID_SPOTIFY_KEY) {
      this._protection = descriptor.protection || 'cenc';
      this._psshBox = new global.Uint8Array();
      return this;
    }

    var error;
    var psshField = this._keySystemSettings.pssh_field.audio;
    var pssh = descriptor[psshField];
    if (!pssh) {
      // Most likely a non-MP4_DUAL file. For now, we should fallback to the
      // PSSH field until all files have been migrated to DUAL.
      if (psshField === 'pssh_widevine') {
        pssh = descriptor.pssh;
      } else {
        error = new FileError(
          Errors.FILE_FORMAT_NOT_SUPPORTED,
          'KeySystem does not support the file format.'
        );
        error.track = this.toLogJSON();
        return Promise.reject(error);
      }
    }
    this._protection = descriptor.protection || 'cenc';
    this._psshBox = this._parsePSSHBox(pssh || DEFAULT_PSSH_BOX);

    // Parse segments
    if (descriptor.segments) {
      this._calculateFragments(descriptor);
    } else if (descriptor.references) {
      this._calculateFragmentsV1(descriptor);
    } else {
      error = new FileError(
        Errors.FILE_MALFORMED_SEEKTABLE,
        'Malformed seektable.'
      );
      // Add the acme track so end-song logging will work.
      error.track = this.toLogJSON();
      return Promise.reject(error);
    }
    return this;
  }.bind(this));
};

/**
 * Returns the "init fragment" for the track.
 *
 * @return {module:spotify-playback/types/media~TrackFragment} The init
 *     fragment.
 */
ACMETrack.prototype.getInitFragment = function() {
  return this._initFragment;
};

/**
 * Returns the first fragment for the track.
 *
 * @return {module:spotify-playback/types/media~TrackFragment} The first
 *     fragment.
 */
ACMETrack.prototype.getFirstFragment = function() {
  return this._fragments[0];
};

/**
 * Returns the "head fragment" for the track.
 *
 * @todo Fix the implementation of this.
 * @return {module:spotify-playback/types/media~TrackFragment} The init
 *     fragment.
 */
ACMETrack.prototype.getHeadFragment = function() {
  var initFragment = this._initFragment;
  var firstFragment = this._fragments[0];
  if (!this._headFragment) {
    this._headFragment = {
      init: true,
      cacheBuffer: true,
      bufferURL: null,
      buffer: null,
      byteStart: initFragment.byteStart,
      byteEnd: firstFragment.byteEnd,
      codec: this._codec,
      sliceInto: [
        {
          fragment: initFragment,
          start: 0,
          end: firstFragment.byteStart
        },
        {
          fragment: firstFragment,
          start: firstFragment.byteStart,
          end: undefined
        }
      ]
    };
  }
  return this._headFragment;
};

/**
 * Removes any cached buffers for the starting fragments.
 */
ACMETrack.prototype.clearCachedBuffers = function() {
  if (this._headFragment) {
    this._headFragment = null;
  }
  if (this._initFragment) {
    this._initFragment.buffer = null;
  }
  if (this._fragments && this._fragments[0]) {
    this._fragments[0].buffer = null;
  }
};

/**
 * Returns the codec to check playability on the audio element with.
 *
 * @return {Array.<string>} The codec strings
 */
ACMETrack.prototype.getPlayableCodecs = function() {
  return [this.isProtected() ? this._codec : ACMETrack.UNPROTECTED_CODEC];
};

/**
 * Returns the fragment for a particular time.
 *
 * @param {number} time The time in seconds.
 * @return {module:spotify-playback/types/media-TrackFragment} The fragment
 *     for the time specified, or null if the time is out of bounds.
 */
ACMETrack.prototype.getFragmentForTime = function(time) {
  if (this._fragments === null) {
    return null;
  }

  var fragment = null;
  if (time === 0 || time === 0.01) {
    fragment = this._fragments[0];
  } else {
    for (var i = 0, l = this._fragments.length; i < l; i++) {
      if (this._fragments[i].timeStart <= time &&
          this._fragments[i].timeEnd >= time) {
        fragment = this._fragments[i];
        break;
      }
    }
  }

  return fragment;
};

/**
 * Returns the next fragment after a particular time.
 *
 * @param {number} time The time in seconds.
 * @return {module:spotify-playback/types/media-TrackFragment} The fragment
 *     for the time specified, or null if the time is out of bounds.
 */
ACMETrack.prototype.getFragmentAfterTime = function(time) {
  if (this._fragments === null) {
    return null;
  }

  var fragment = null;
  if (time === 0 || time === 0.01) {
    fragment = this._fragments[1];
  } else {
    for (var i = 0, l = this._fragments.length; i < l; i++) {
      if (this._fragments[i].timeStart > time) {
        fragment = this._fragments[i];
        break;
      }
    }
  }

  return fragment;
};

/**
 * Aborts any fetching operation.
 */
ACMETrack.prototype.abort = function() {
  this._fetching.forEach(function(resolver) {
    if (typeof resolver !== 'function') {
      return;
    }
    resolver(true);
  });
  this._fetching = [];
};

/**
 * Returns a json-serializable object representing the logData for this track.
 *
 * @return {Object} The LogData.
 */
ACMETrack.prototype.toLogJSON = function() {
  return {
    uri: this._uri,
    fileId: this._fileId,
    format: this._format,
    resolved_url: this._resolvedURL
  };
};


module.exports = ACMETrack;
