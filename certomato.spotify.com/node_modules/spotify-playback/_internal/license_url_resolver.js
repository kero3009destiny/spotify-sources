'use strict';

var Promise = require('spotify-promise-plus');

var LicenseError = require('../lib/license_error');
var Errors = require('../types/errors');

var LICENSE_URL_ENDPOINT = '@webgate/melody/v1/license_url';

var EXPIRY_THRESHOLD = 60000;

/**
 * Used for resolving signed URLs to the license server.
 *
 * @constructor
 * @param {Object} options The options for the instance.
 */
function LicenseURLResolver(options) {
  /**
   * An instance transport that will be used for the request.
   *
   * @type {module:spotify-tranport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * A string identifying the SDK version of the library wrapping playback.
   *
   * @type {string}
   * @protected
   */
  this._sdk = options.sdk || {
    name: '',
    version: ''
  };

  /**
   * The security level for the required licenses.
   *
   * @type {*}
   * @protected
   */
  this._securityLevel = options.securityLevel;

  /**
   * A map containing the last known valid signed urls.
   *
   * Entries are keyed in the format `<keysystem>:<mediatype>`.
   *
   * @type {Object.<string, Object>}
   * @protected
   */
  this._urls = {};

  this._init();
}

LicenseURLResolver.prototype._init = function() {
  this._transport.on(this._transport.EVENT_CONNECTION_ID, function() {
    // We assume that when we get a new connection id, we will have a new user,
    // so we don't want to re-use the old urls, which are tied to a different
    // user. We just clear them as is.
    this._urls = {};
  }.bind(this));
};

/**
 * Fetches a signed license URL for a particular keysystem and mediatype combo.
 *
 * @param {string} keySystem The key system for the media.
 * @param {string} mediaType The type of media, can be "audio" or "video".
 * @return {Promise.<string>} A promise containing the string URL.
 */
LicenseURLResolver.prototype.get = function(keySystem, mediaType) {
  var key = keySystem + ':' + mediaType;
  var cached = this._urls[key];
  if (cached && cached.expires > (Date.now() + EXPIRY_THRESHOLD)) {
    return Promise.resolve(cached.uri);
  }
  var url = [
    LICENSE_URL_ENDPOINT,
    '?keysystem=', keySystem,
    '&mediatype=', mediaType,
    '&sdk_name=', this._sdk.name,
    '&sdk_version=', this._sdk.version
  ].join('');
  return this._transport.request(url, {
    responseType: 'json',
    retry: {
      condition: function(resp, StatusFamily) {
        var statusFamily = resp.getStatusFamily();
        return statusFamily === StatusFamily.SERVER_ERROR ||
          statusFamily === StatusFamily.CONNECTION_ERROR;
      }
    }
  }).then(function(response) {
    var result = response.body;

    // Successful
    if (response.status === 200) {
      // Expiry is in seconds, turn it into ms.
      result.expires *= 1000;
      result.uri = '@webgate/' + result.uri;
      if (this._securityLevel) {
        result.uri += [
          result.uri.indexOf('?') !== -1 ? '&' : '?',
          'sl=',
          this._securityLevel
        ].join('');
      }
      this._urls[key] = result;
      return result.uri;
    }

    // Errors
    var error;
    if (
      response.status === 400 &&
      result &&
      result.code === 'deprecated-version'
    ) {
      error = new LicenseError(
        Errors.LICENSE_RESOLVER_DEPRECATED_VERSION,
        'This version of the SDK is no longer supported. Please upgrade'
      );
      error.canPlayNext = false;
      error.fatal();
    } else {
      error = new LicenseError(
        Errors.LICENSE_RESOLVER_CANT_RESOLVE_URL,
        'License URL endpoint responded with status ' + response.status
      );
    }

    error.status = response.status;
    return Promise.reject(error);
  }.bind(this));
};

/**
 * Removes a signed license for a particular keysystem and mediatype.
 *
 * @param {string} keySystem The key system for the media.
 * @param {string} mediaType The type of media, can be "audio" or "video".
 */
LicenseURLResolver.prototype.remove = function(keySystem, mediaType) {
  this._urls[keySystem + ':' + mediaType] = null;
};

module.exports = LicenseURLResolver;
