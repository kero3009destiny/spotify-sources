'use strict';

var inherit = require('spotify-inheritance/inherit');
var Promise = require('spotify-promise-plus');
var EMEError = require('../lib/eme_error');
var CappingError = require('../lib/capping_error');
var EventEmitter = require('spotify-eventemitter');
var Event = require('../types/event');
var Errors = require('../types/errors');
var KeySystem = require('../types/keysystem');

var EMEPolyfills = require('../lib/eme_polyfills');

var KeySystemSetting = require('./keysystem_setting');

var KEY_SYSTEM_CONFIGS = require('./eme_configs');

var createConfigFilter = require('./util/create_config_filter');

var debugLogger = require('spotify-debug-tools/logging')
  .forTag('playback.eme_manager');

var CODEC_EXP = /([^;]+)(?:;\s?codecs="(.*)")?/;

/**
 * Manages the KeySessions for a player tag.
 *
 * @constructor
 * @param {module:spotify-playback/eme_manager~EMEManagerOptions} options
 *     The options for the instance.
 */
function EMEManager(options) {
  EventEmitter.call(this);

  /**
   * The current transport object. Used to talk to the license server.
   *
   * @type {module:spotify-transport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * A flag that indicates whether to set the server certificate when creating
   * the media keys.
   *
   * In some certain implementations of widevine, setting the server certificate
   * results in an error.
   *
   * @type {boolean}
   * @protected
   */
  this._noServerCertificate = options.noServerCertificate;

  /**
   */
  this._preferredKeySystems = options.preferredKeySystems || [
    KeySystem.WIDEVINE,
    KeySystem.PLAYREADY,
    KeySystem.PLAYREADY_HARDWARE
  ];

  /**
   * A regular expression that will be used to filter out KeySystem
   * configurations based on robustness values.
   *
   * @type {RegExp}
   * @protected
   */
  this._configFilter = createConfigFilter(
    options.disallowRobustnessValues || []
  );

  /**
   * The type of implementation for the platform.
   *
   * @type {string}
   */
  this._emeImpl = options.emeImpl;

  /**
   * A promise that will be resolved with the system's KeyAccess object.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._keySystemDeferred = Promise.defer();

  /**
   * A promise that will be resolved with the KeySystemInfo.
   *
   * @type {Promise.Deferred}
   * @protected
   */
  this._configuration = Promise.defer();

  /**
   * Settings for the keysystem
   *
   * @type {Object}
   * @protected
   */
  this._keySystemSettings = null;

  /**
   * Keeps track of all current KeySessions.
   *
   * @type {Array.<Object>}
   * @protected
   */
  this._keySessions = [];

  this._configs = [];
}
inherit(EMEManager, EventEmitter);

/**
 * Creates a new instance of the EMEManager
 *
 * @static
 * @param {module:spotify-playback/eme_manager~EMEManagerOptions} options
 *     The options for the instance.
 * @return {Promise.<module:spotify-playback/eme_manager>} The new
 *     EMEManager instance.
 */
EMEManager.create = function(options) {
  return new Promise(function(resolve) {
    var emeImpl = EMEPolyfills.install();
    if (!emeImpl) {
      throw new EMEError(
        Errors.EME_API_NOT_SUPPORTED,
        'Platform does not support navigator.requestMediaKeySystemAccess'
      ).fatal();
    }
    options.emeImpl = emeImpl;
    resolve(new EMEManager(options).init());
  });
};

/**
 * Prepares the configuration object.
 *
 * @param {MediaKeySystemAccess} keySystemAccess The keysystem from
 *     requestMediaKeySystemAccess.
 * @return {module:spotify-playback/types.KeySystemInfo} The key system info.
 * @protected
 */
EMEManager.prototype._prepareConfiguration = function(keySystemAccess) {
  var config = keySystemAccess.getConfiguration();
  debugLogger.info('KeySystem configured as ', config.label);
  if (!config.audioCapabilities || !config.audioCapabilities.length) {
    // MS Edge does not correctly set the audio and video capabilities, but we
    // need to add them to correctly determine whether we can play video.
    this._appendProbableMediaCapabilities(
      keySystemAccess.keySystem,
      config
    );
  }
  var parsed = {
    keySystem: keySystemAccess.keySystem,
    keySystemImpl: this._emeImpl,
    audioFormats: this._parseCapabilities(config.audioCapabilities),
    videoFormats: this._parseCapabilities(config.videoCapabilities)
  };
  this._keySystemSettings = KeySystemSetting[keySystemAccess.keySystem];
  this._configuration.resolve(parsed);
  return parsed;
};

/**
 * Parses the KeySystemAccess capabilities.
 *
 * @param {Array.<Capability>} capabilities The capabilities to parse.
 * @return {Array.<module:spotify-playback/types.FormatInfo>} The formats
 *     available from the capabilities.
 * @protected
 */
EMEManager.prototype._parseCapabilities = function(capabilities) {
  if (!capabilities) {
    return [];
  }
  var results = [];
  for (var i = 0, l = capabilities.length; i < l; i++) {
    var cap = capabilities[i];
    if (!cap || !cap.contentType) {
      continue;
    }
    var matches = cap.contentType.match(CODEC_EXP);
    results.push({
      contentType: cap.contentType,
      mimeType: matches[1],
      codec: matches[2]
    });
  }
  return results;
};

/**
 * Appends the audio and video configurations to a KeySystemConfiguration
 * object.
 *
 * @param {string} ks The keysystem name.
 * @param {Object} origConfig The KeySystemConfiguration.
 * @protected
 */
EMEManager.prototype._appendProbableMediaCapabilities = function(
  ks,
  origConfig
) {
  var configs = this._configs;

  for (var i = 0, l = configs.length; i < l; i++) {
    var config = configs[i];

    var configuration = {
      audioCapabilities: [],
      videoCapabilities: []
    };

    var x;
    var y;
    var cap;
    var contentType;

    var hasSupported = false;
    // Audio caps
    if (config.audioCapabilities && config.audioCapabilities.length) {
      hasSupported = false;
      for (x = 0, y = config.audioCapabilities.length; x < y; x++) {
        cap = config.audioCapabilities[x];
        contentType = cap.contentType;
        if (global.MediaSource.isTypeSupported(contentType)) {
          configuration.audioCapabilities.push(cap);
          hasSupported = true;
        }
      }
    }

    // Video caps
    if (config.videoCapabilities && config.videoCapabilities.length) {
      hasSupported = false;
      for (x = 0, y = config.videoCapabilities.length; x < y; x++) {
        cap = config.videoCapabilities[x];
        contentType = cap.contentType;

        if (
          contentType.indexOf('webm') !== -1 &&
          (ks === KeySystem.PLAYREADY || ks === KeySystem.PLAYREADY_HARDWARE)
        ) {
          // Edge will report that it supports WebM, but testing shows that it
          // cannot, so we skip WebM on all PlayReady platforms for now.
          continue;
        }
        if (global.MediaSource.isTypeSupported(contentType)) {
          configuration.videoCapabilities.push(cap);
          hasSupported = true;
        }
      }
    }

    if (hasSupported) {
      origConfig.audioCapabilities = configuration.audioCapabilities;
      origConfig.videoCapabilities = configuration.videoCapabilities;
      return;
    }
  }
};

/**
 * Try to set the server certificate for a MediaKeys object.
 *
 * Note that failure to set the certificate is not considered an error, which is
 * why we warn than fail.
 *
 * @param {string} url The license server URL.
 * @param {MediaKeys} mediaKeys The MediaKey object whose certificate is being
 *     set.
 * @return {Promise.<EMEManager>} A promise that will be resolved to the current
 *     EMEManager instance.
 * @protected
 */
EMEManager.prototype._trySetServerCertificate = function(url, mediaKeys) {
  return this._transport.request(url + '/v1/application-certificate', {
    authorize: true,
    responseType: 'arraybuffer',
    retry: {
      condition: function(response, StatusFamily) {
        return response.getStatusFamily() === StatusFamily.SERVER_ERROR;
      }
    }
  }).then(function(response) {
    return mediaKeys.setServerCertificate(response.body);
  }).then(function() {
    return this;
  }.bind(this)).catch(function(e) {
    debugLogger.warn('Error from setting server certificate', e);
    return this;
  }.bind(this));
};

EMEManager.prototype._extractPlayReadyChallenge = function(message, playId) {
  var challenge = null;

  var xmlString = String.fromCharCode.apply(
    null,
    new global.Uint16Array(message)
  );

  if (xmlString.indexOf('PlayReadyKeyMessage') === -1) {
    // This check will succeed in platforms with older PlayReady versions where
    // the message is already extracted. In these platforms, we notice that the
    // message is actually UTF-8 instead of UTF-16, which leads to a garbled
    // xmlString when we try to parse it.
    //
    // When we encounter this, we should simply return the old message and use
    // that directly.
    debugLogger.info('Using unextracted PlayReady message.');
    return message;
  }

  var keyMessageXml = new global.DOMParser().parseFromString(
    xmlString,
    'application/xml'
  );

  if (keyMessageXml.getElementsByTagName('Challenge')[0]) {
    try {
      challenge = atob(
        keyMessageXml.getElementsByTagName('Challenge')[0].childNodes[0]
          .nodeValue
      );

      var headerNames = keyMessageXml.getElementsByTagName('name');
      var headerValues = keyMessageXml.getElementsByTagName('value');
      if (headerNames.length !== headerValues.length) {
        throw new EMEError(
          Errors.EME_HEADER_KEY_VALUE_MISMATCH,
          'Mismatched header <name>/<value> pair in key message'
        );
      }
    } catch (e) {
      // An error can be thrown either from the extraction of the data from the
      // XML or when the header <name>/<value> pair don't match
      this.emit(Event.EME_LICENSE_REQUEST_ERROR, {
        playId: playId,
        error: e
      });

      // Make sure challenge is null in case of error
      challenge = null;
    }
  } else {
    this.emit(Event.EME_LICENSE_REQUEST_ERROR, {
      playId: playId,
      error: new EMEError(
        Errors.EME_HEADER_KEY_VALUE_MISMATCH,
        'Mismatched header <name>/<value> pair in key message'
      )
    });
  }

  return challenge;
};

/**
 * Handles a message event from a created KeySession.
 *
 * @param {Object} options The options. Must contain the following properties:
 * @property {string} keySystem The name of the KeySystem.
 * @property {KeySession} keySession The KeySession.
 * @property {string} licenseServer The license server URL for the file.
 * @property {module:spotify-promise-plus.Deferred} playId The deferred promise
 *     created from createSession associated with this message event.
 * @param {MessageEvent} event The message event from the KeySession.
 */
EMEManager.prototype._onMessage = function(options, event) {
  options.timeMap.generate.end = Date.now();
  debugLogger.info('Got EME message event with type', event.messageType);

  var message = event.message;

  if (message && options.keySystem === KeySystem.PLAYREADY) {
    message = this._extractPlayReadyChallenge(message, options.playId);
  }

  if (!message) {
    debugLogger.info('Ignoring message event: no valid request payload');
    return;
  }

  options.timeMap.request.start = Date.now();

  this._transport
    .request(options.licenseServer, {
      method: 'POST',
      payload: message,
      responseType: 'arraybuffer',
      retry: {
        condition: function(response, StatusFamily) {
          if (
            response.status === 400 ||
            response.status === 402 ||
            response.status === 403
          ) {
            // These are known errors that aren't recoverable, no need to retry.
            return false;
          }
          return (
            !response.body ||
            response.getStatusFamily() !== StatusFamily.SUCCESS
          );
        }
      }
    })
    .then(this._handleLicenseResponse.bind(this, options));
};

/**
 * Handles the response of the license request.
 *
 * @param {Object} options The request options.
 * @param {module:spotify-transport/types.HTTPResponse} response The server's
 *     response.
 */
EMEManager.prototype._handleLicenseResponse = function(options, response) {
  var emitError = function(error) {
    error.playId = options.playId;
    error.licenseServer = options.licenseServer;
    this.emit(Event.EME_LICENSE_REQUEST_ERROR, {
      playId: options.playId,
      error: error
    });
  }.bind(this);

  options.timeMap.request.end = Date.now();

  var error;
  if (response.status === 200) {
    if (!response.body) {
      error = new EMEError(
        Errors.EME_LICENSE_REQUEST_EMPTY_RESPONSE,
        'Empty license response body'
      );
      error.status = response.status;
      emitError(error);
      return;
    }

    try {
      options.timeMap.update.start = Date.now();
      options.keySession.update(response.body).catch(function(e) {
        emitError(
          new EMEError(
            Errors.EME_LICENSE_UPDATE_FAILED,
            e.message || 'License update failed.'
          )
        );
      });
      debugLogger.info('KeySession updated.');
    } catch (e) {
      emitError(
        new EMEError(
          Errors.EME_LICENSE_UPDATE_FAILED,
          e.message || 'License update failed.'
        )
      );
    }
    return;
  }

  // Since the response type should be array buffer for successful
  // operations, we need to parse this into JSON when dealing with errors.
  var errMsg;
  try {
    var maybeJSON = String.fromCharCode.apply(
      String,
      new global.Uint8Array(response.body)
    );
    errMsg = JSON.parse(maybeJSON).errorMsg;
  } catch (e) {
    // If the body isn't valid JSON, we ignore it.
  }

  if (response.status === 402) {
    // The current user is capped.
    this.emit(Event.EME_LICENSE_REQUEST_CAPPED, {
      playId: options.playId,
      error: new CappingError(
        Errors.CAPPING_USER_IS_CAPPED,
        'User is capped.'
      )
    });
  } else if (response.status === 400 && errMsg === 'widevine error') {
    error = new EMEError(
      Errors.EME_LICENSE_REQUEST_WIDEVINE_ERROR,
      'Widevine license server failed to parse request.'
    );
    error.status = response.status;
    error.shouldRefreshEndpoint = true;
    error.fatal();
    emitError(error);
  } else {
    error = new EMEError(
      Errors.EME_LICENSE_REQUEST_FAILED_WITH_STATUS,
      'License request failed (' + (errMsg || 'unknown') + ')'
    );
    error.status = response.status;
    error.shouldRefreshEndpoint =
      response.status === 400 || response.status === 403;
    emitError(error);
  }
};

/**
 * Saves a new KeySession and removes the oldest KeySession.
 *
 * @param {Object} keySessionData The KeySession to add.
 * @protected
 */
EMEManager.prototype._saveSession = function(keySessionData) {
  this._keySessions.push(keySessionData);
};

EMEManager.prototype.destroySessions = function() {
  var promises = [];
  var keySessions = this._keySessions;
  for (var i = 0, l = keySessions.length; i < l; i++) {
    try {
      var keySessionData = keySessions[i];
      var keySession = keySessionData.keySession;
      keySession.removeEventListener(
        Event.KEY_SESSION_MESSAGE,
        keySessionData.onMessageListener
      );
      keySession.removeEventListener(
        Event.KEY_SESSION_STATUSES_CHANGE,
        keySessionData.onKeyStatusChangeListener
      );

      var stopPromise = Promise.resolve(keySession.close()).catch(function(e) {
        debugLogger.warn('Failed to close KeySession', e);
      });

      promises.push(stopPromise);

      // Explicitly null.
      keySessionData.keySession = null;
      keySessionData.onMessageListener = null;
      keySessionData.onKeyStatusChangeListener = null;

      debugLogger.info('Closed KeySession');
    } catch (e) {
      debugLogger.warn('Failed to close KeySession', e);
    }
  }
  this._keySessions = [];
  return Promise.all(promises);
};

/**
 * Initializes the EMEManager instance.
 *
 * @return {module:spotify-playback/eme_manager} The instance.
 */
EMEManager.prototype.init = function() {
  var keySystemDeferred = this._keySystemDeferred;
  var navigator = global.navigator;

  var ksAccessMap = {};
  var promises = [];

  var configs = [];
  for (var i = 0, l = KEY_SYSTEM_CONFIGS.length; i < l; i++) {
    var config = KEY_SYSTEM_CONFIGS[i];
    if (this._configFilter.test(config.label)) {
      continue;
    }
    configs.push(config);
  }
  this._configs = configs;


  for (var ksName in KeySystem) {
    // debug_enum prevents us from calling hasOwnProperty directly.
    if (!Object.prototype.hasOwnProperty.call(KeySystem, ksName)) {
      continue;
    }
    promises.push(navigator.requestMediaKeySystemAccess(
      KeySystem[ksName], configs
    ).then(function(keySystemAccess) {
      ksAccessMap[keySystemAccess.keySystem] = keySystemAccess;
    }).catch(function() {
      // Do nothing.
    }));
  }

  return Promise.all(promises)
    .then(this._selectKeySystem.bind(this, ksAccessMap))
    .then(function(keySystemAccess) {
      if (!keySystemAccess) {
        return Promise.reject(
          new EMEError(
            Errors.EME_NO_SUPPORTED_KEYSYSTEM,
            'No supported keysystem was found.'
          )
        );
      }
      return this._testMediaKeys(keySystemAccess);
    }.bind(this))
    .then(function(keySystem) {
      this._prepareConfiguration(keySystem);
      keySystemDeferred.resolve(keySystem);
      return this;
    }.bind(this))
    .catch(function(e) {
      var code = e.code || Errors.EME_NO_SUPPORTED_KEYSYSTEM;
      var message = e.message || 'No supported keysystem';
      keySystemDeferred.reject(new EMEError(code, message).fatal());
      return keySystemDeferred.promise;
    });
};

EMEManager.prototype._selectKeySystem = function(ksAccessMap) {
  var preferredKeySystems = this._preferredKeySystems;
  for (var i = 0, l = preferredKeySystems.length; i < l; i++) {
    var ksName = preferredKeySystems[i];
    if (ksName in ksAccessMap) {
      return ksAccessMap[ksName];
    }
  }
  return null;
};

EMEManager.prototype._testMediaKeys = function(keySystemAccess) {
  return new Promise(function(resolve) {
    resolve(keySystemAccess.createMediaKeys());
  }).then(function(mediaKeys) {
    if (!mediaKeys) {
      return Promise.reject(
        new EMEError(
          Errors.EME_MEDIA_KEYS_NOT_SUPPORTED,
          'Cannot create MediaKeys from KeySystemAccess'
        ).fatal()
      );
    }

    try {
      var keySession = mediaKeys.createSession();
      if (!keySession) {
        throw new Error('');
      }
    } catch (e) {
      return Promise.reject(
        new EMEError(
          Errors.EME_MEDIA_KEY_SESSION_NOT_SUPPORTED,
          e.message || 'Cannot create MediaKeySession from KeySystemAccess'
        ).fatal()
      );
    }
    return keySystemAccess;
  }, function(e) {
    debugLogger.error(e.name);
    return Promise.reject(
      new EMEError(
        Errors.EME_MEDIA_KEYS_NOT_SUPPORTED,
        e.message || 'Unknown error'
      ).fatal()
    );
  });
};

/**
 * Creates a MediaKeys object and attaches it to a HTMLMediaElement.
 *
 * @param {HTMLMediaElement} player The object that will receive the created
 *     MediaKeys object.
 * @return {Promise.<EMEManager>} A promise that will be resolved to the current
 *     EMEManager instance.
 */
EMEManager.prototype.createMediaKeys = function(player) {
  return this._keySystemDeferred.promise.then(function(keySystem) {
    return keySystem.createMediaKeys();
  }).then(function(mediaKeys) {
    return Promise.all([player.setMediaKeys(mediaKeys), mediaKeys]);
  }).spread(function(result, mediaKeys) {
    if (!player.mediaKeys) {
      throw new EMEError(
        Errors.EME_PLAYER_MEDIA_KEYS_SETTING_FAILED,
        'Failed to set MediaKeys on HTMLMediaElement'
      );
    }
    return this._configuration.promise.then(function() {
      var settings = this._keySystemSettings;
      if (this._noServerCertificate || !settings.withCertificate) {
        return this;
      }
      return this._trySetServerCertificate(settings.licenseServer, mediaKeys);
    }.bind(this));
  }.bind(this));
};

/**
 * Removes the media keys from an element.
 *
 * @param {HTMLMediaElement} player The MediaElement whose MediaKeys will be
 *     removed.
 * @return {Promise.<EMEManager>} A promise that will be resolved to the current
 *     EMEManager instance.
 */
EMEManager.prototype.removeMediaKeys = function(player) {
  return Promise.resolve(player.setMediaKeys(null)).then(function() {
    return this;
  }.bind(this));
};

/**
 * Returns the KeySystemInfo.
 *
 * @return {Promise.<module:spotify-playback/types.KeySystemInfo>} The key
 *     system info.
 */
EMEManager.prototype.getKeySystemInfo = function() {
  return this._configuration.promise;
};

/**
 * Returns the "name" of the EME implementation for the platform.
 *
 * Note that unlike most other methods, this method will return the value
 * synchronously.
 *
 * @return {string} The name of the EME implementation. Refer to the polyfills
 *     file for possible values.
 */
EMEManager.prototype.getKeySystemImpl = function() {
  return this._emeImpl;
};

/**
 * Creates a new KeySession with a params object.
 *
 * @param {Object} params The parameters for this KeySession.
 * @return {Promise.<boolean>} True if the KeySession was successfully created.
 */
EMEManager.prototype.createSessionWithParams = function(params) {
  return new Promise(function(resolve, reject) {
    debugLogger.info('Creating KeySession', params.keySystem);
    var keySession = params.mediaKeys.createSession();

    // Internal map of timestamps that we will use to compute the different
    // operations. The map needs to be updated at the start of the operation.
    var timeMap = {
      generate: {start: 0, end: 0},
      request: {start: 0, end: 0},
      update: {start: 0, end: 0}
    };

    var onMessageListener = this._onMessage.bind(this, {
      keySystem: params.keySystem,
      keySession: keySession,
      licenseServer: params.licenseServer ||
        this._keySystemSettings.licenseServer,
      playId: params.playId,
      timeMap: timeMap
    });
    keySession.addEventListener(Event.KEY_SESSION_MESSAGE, onMessageListener);

    var onKeyStatusChangeListener = function() {
      debugLogger.info('KeyStatus change');
      timeMap.update.end = Date.now();

      // Return elapsed for each operation.
      resolve({
        elapsed: {
          generate: Math.max(timeMap.generate.end - timeMap.generate.start, 0),
          request: Math.max(timeMap.request.end - timeMap.request.start, 0),
          update: Math.max(timeMap.update.end - timeMap.update.start, 0)
        }
      });
    };
    keySession.addEventListener(
      Event.KEY_SESSION_STATUSES_CHANGE,
      onKeyStatusChangeListener
    );

    this._saveSession({
      keySession: keySession,
      onMessageListener: onMessageListener,
      onKeyStatusChangeListener: onKeyStatusChangeListener
    });

    debugLogger.info('Generating KeySession request', params.keySystem);
    timeMap.generate.start = Date.now();
    Promise.resolve(
      keySession.generateRequest(params.initDataType, params.initData.buffer)
    ).catch(function(e) {
      if (!e) {
        return;
      }

      var type;
      switch (e.name) {
        case 'NotSupportedError':
          type = Errors.EME_NOT_SUPPORTED_ERROR;
          break;
        case 'InvalidStateError':
          type = Errors.EME_INVALID_STATE_ERROR;
          break;
        default:
          type = Errors.EME_UNKNOWN_ERROR;
      }
      reject(new EMEError(type, e.message || 'Unknown error message.'));
    });
  }.bind(this));
};

module.exports = EMEManager;
