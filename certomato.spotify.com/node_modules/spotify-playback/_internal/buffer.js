'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var Promise = require('spotify-promise-plus');
var Event = require('../types/event');

var debugLogger = require('spotify-debug-tools/logging').forTag(
  'playback.acme_buffer'
);

/**
 * Acceptable time to get the next fragment before reporting it as a stall.
 */
var STALL_THRESHOLD = 9000;

/**
 * The amount of playback time needed to be buffered at any given time, in
 * seconds.
 *
 * @const
 */
var ENSURE_BUFFERED_TIME = 10;

/**
 * Convert seconds to milliseconds.
 *
 * @param {number} seconds
 * @return {number}
 */
function _secToMS(seconds) {
  return Math.ceil(seconds * 1000);
}

/**
 * A noop function that is used for catching and ignoring errors that are
 * already handled by the events.
 *
 * @type {function}
 */
function _ignoreEmittedErrors() {
}

/**
 * The ACMEBuffer is responsible for managing sourcebuffers and media sources
 *     for the ACMEPlayer.
 *
 * @param {module:spotify-playback/lib/tracker} tracker
 * @param {Array.<string>} codecs A list containing the buffers active codecs
 *     for the new ACMEBuffer.
 * @param {Object} options The options for this instance.
 * @constructor
 */
function ACMEBuffer(tracker, codecs, options) {
  EventEmitter.call(this);

  var _options = options || {};

  /**
   * The MediaSource object.
   *
   * @type {MediaSource}
   * @protected
   */
  this._mediaSource = null;

  /**
   * .A list containing the sourcebuffers.
   *
   * @type {Array.<SourceBuffer>}
   * @protected
   */
  this._sourceBuffers = {};

  /**
   * A list containing fragments that are to be appeded.
   *
   * @type {Array.<module:spotify-playback/_internal/track~Fragment>}
   * @protected
   */
  this._appendingFragments = [];

  /**
   * A list containing queued updates.
   *
   * @type {Array.<object>}
   * @protected
   */
  this._updateQueue = [];

  /**
   * A list containing the buffers active codecs.
   *
   * @type {Array.<string>}
   * @protected
   */
  this._codecs = codecs || [];

  /**
   * The current tracks playId.
   *
   * @type {number}
   * @protected
   */
  this._playId = 0;

  /**
   * The time when the buffer was last cleared.
   *
   * @type {number}
   * @protected
   */
  this._lastBufferClearTime = Date.now();

  /**
   * Tracker instance.
   *
   * @type {module:spotify-playback/lib/tracker}
   * @protected
   */
  this._tracker = tracker;

  /**
   * A flag that indicates whether or not to abort source buffers, which is
   * needed on some platforms.
   */
  this._disableBufferAbort = _options.disableBufferAbort;

  // bind event handlers to the instance scope.
  this._onSourceOpen = this._onSourceOpen.bind(this);
  this._onSourceClose = this._onSourceClose.bind(this);
  this.dequeueUpdates = this.dequeueUpdates.bind(this);

  this._init();
}
inherit(ACMEBuffer, EventEmitter);

/**
 * Creates a new ACMEBuffer.
 *
 * @param {module:spotify-playback/lib/tracker} tracker
 *     The tracker to use with the buffer.
 * @param {Array.<string>} codecs A list containing the buffers active codecs
 *     for the new ACMEBuffer.
 * @param {Object} options The options for this instance.
 * @static
 * @return {module:spotify-playback/_internal/buffer}
 */
ACMEBuffer.create = function(tracker, codecs, options) {
  return new ACMEBuffer(tracker, codecs, options);
};

/**
 * Initialize the buffer.
 *
 * @protected
 */
ACMEBuffer.prototype._init = function() {
  var mediaSource = new MediaSource();
  mediaSource.addEventListener(Event.MEDIA_SOURCE_OPEN, this._onSourceOpen);
  mediaSource.addEventListener(Event.MEDIA_SOURCE_CLOSE, this._onSourceClose);
  this._mediaSource = mediaSource;
  this._sourceBuffers = {};
};

/**
 * Handle sourceopen event on the mediasource..
 *
 * @protected
 */
ACMEBuffer.prototype._onSourceOpen = function() {
  debugLogger.info('MediaSource opened.');
  var mediaSource = this._mediaSource;
  if (mediaSource.sourceBuffers.length === 0 &&
      mediaSource.readyState === 'open') {
    debugLogger.info('Creating source buffers for codecs', this._codecs);
    // No active source buffers
    for (var i = 0, len = this._codecs.length; i < len; i++) {
      this._addSourceBuffer(this._codecs[i]);
    }
  }
  // Dequeue any operations that might have been queued while the source
  // buffer was not ready.
  this.dequeueUpdates();
  this.emit(Event.BUFFER_SOURCE_OPEN);
};

ACMEBuffer.prototype._onSourceClose = function() {
  debugLogger.info('MediaSource closed.');
  this._destroySourceBuffers();
  this.emit(Event.BUFFER_SOURCE_CLOSE);
};

/**
 * Remove an "appending" fragment from the list.
 *
 * @param {module:spotify-playback/_internal/track~Fragment|
 *         module:spotify-playback/_internal/videotrack~Fragment} fragment
 *     The fragment to remove.
 * @protected
 */
ACMEBuffer.prototype._removeAppendingFragment = function(fragment) {
  if (!fragment) {
    return;
  }
  // Mark the chunk as appended.
  var appendingFragments = this._appendingFragments;
  var index = appendingFragments.indexOf(fragment);
  if (index !== -1) {
    appendingFragments.splice(index, 1);
  }
};

/**
 * Handles an "updateend" event from the SourceBuffer
 *
 * @protected
 */
ACMEBuffer.prototype.dequeueUpdates = function() {
  if (this._updateQueue.length) {
    this.tryUpdate(this._updateQueue.shift());
  }
};

/**
 * Add a source buffer to the mediasource.
 *
 * @param {string} codec The codec of the SourceBuffer.
 * @public
 */
ACMEBuffer.prototype._addSourceBuffer = function(codec) {
  var sourceBuffer = this._mediaSource.addSourceBuffer(codec);
  sourceBuffer.addEventListener(
    Event.SOURCE_BUFFER_UPDATE_END,
    this.dequeueUpdates
  );
  this._sourceBuffers[codec] = sourceBuffer;
};

ACMEBuffer.prototype._trackBufferingProgress = function(bufferData) {
  this._tracker.trackBytesDownloaded(bufferData.audio.buffer.byteLength);
  if (bufferData.video) {
    this._tracker.trackBytesDownloaded(bufferData.video.buffer.byteLength);
  }
};

/**
 * Append a fragment to a track
 *     Adds a fragment to the list of appending fragments, fetches the bytes for
 *     it and tries to update the buffer with them.
 *
 * @param {module:spotify-playback/_internal/track} acmeTrack
 *     The track that owns the fragment.
 * @param {module:spotify-playback/_internal/track~Fragment} fragment
 *     The fragment.
 * @param {boolean} wasSeeking True if the player was seeking at the point where
 *     the fragment was needed.
 * @return {Promise.<Array.<boolean>>}
 * @public
 */
ACMEBuffer.prototype.appendFragment = function(
  acmeTrack,
  fragment,
  wasSeeking
) {
  if (this._appendingFragments.indexOf(fragment) !== -1) {
    // We're already appending this fragment, so return early.
    return Promise.resolve([false]);
  }
  this._appendingFragments.push(fragment);

  this.emit(Event.BUFFERING_START);

  var timeStart = Date.now();
  var playId = this._playId;
  var trackLogJSON = acmeTrack.toLogJSON();

  return acmeTrack
    .getBufferForFragment(fragment)
    .then(function(bufferData) {
      this._trackBufferingProgress(bufferData);
      if (playId !== this._playId) {
        debugLogger.info('Append fragment dropped: playId has changed.');
        return [false];
      }

      if (!wasSeeking) {
        this._checkStalling(Date.now() - timeStart, fragment, false);
      }

      return this._appendBufferData(
        bufferData,
        fragment,
        playId,
        timeStart
      );
    }.bind(this)).catch(function(e) {
      this._removeAppendingFragment(fragment);
      if (!wasSeeking) {
        this._checkStalling(Date.now() - timeStart, fragment, true);
      }
      this.emit(Event.BUFFER_APPEND_ERROR, {
        error: e,
        canPlayNext: true,
        track: trackLogJSON
      });
      return Promise.reject(e);
    }.bind(this));
};

/**
 * Given a delay, check if the playback has stalled and notify observers
 * if that's the case
 *
 * @param {number} delay The time elapsed since the buffering started.
 * @param {module:spotify-playback/_internal/track~Fragment} fragment
 *     The fragment.
 * @param {bool} didTimeout whether a timeout occurred while buffering
 *     the fragment.
 */
ACMEBuffer.prototype._checkStalling = function(delay, fragment, didTimeout) {
  if (delay > STALL_THRESHOLD) {
    this.emit(Event.BUFFER_STALLED, {
      // TODO: byteStart property on ACMEVideoTracks?
      byteStart: fragment.byteStart,
      timeStart: _secToMS(fragment.timeStart),
      stallAmount: delay - STALL_THRESHOLD,
      didTimeout: didTimeout
    });
  }
};

/**
 * Append the bufferData to a track
 *
 * @param {ArrayBuffer} bufferData The buffered data.
 * @param {module:spotify-playback/_internal/track~Fragment} fragment
 *     The fragment.
 * @param {number} playId
 * @param {number} timestamp An optional timestamp of when the operation
 *     started.
 * @return {Promise.<Array.<boolean>>}
 */
ACMEBuffer.prototype._appendBufferData = function(
  bufferData,
  fragment,
  playId,
  timestamp
) {
  this.emit(Event.BUFFERING_END);

  var _timestamp = timestamp || Date.now();

  var promises = [];

  var audioUpdatePromise = Promise.defer();
  this.tryUpdate({
    playId: playId,
    timestamp: _timestamp,
    type: 'append',
    buffer: bufferData.audio.buffer,
    fragment: fragment,
    codec: bufferData.audio.codec,
    init: fragment.init,
    resolve: audioUpdatePromise.resolve
  });
  promises.push(audioUpdatePromise);
  if (bufferData.audio.bandwidth !== null) {
    this._tracker.trackBufferURL(
      bufferData.audio.bufferURL,
      {bandwidth: bufferData.audio.bandwidth}
    );
  }

  if (bufferData.video) {
    var videoUpdatePromise = Promise.defer();
    this.tryUpdate({
      playId: playId,
      timestamp: _timestamp,
      type: 'append',
      buffer: bufferData.video.buffer,
      fragment: fragment,
      codec: bufferData.video.codec,
      init: fragment.init,
      resolve: videoUpdatePromise.resolve
    });
    promises.push(videoUpdatePromise);
    if (bufferData.video.bandwidth !== null) {
      this._tracker.trackBufferURL(
        bufferData.video.bufferURL,
        {bandwidth: bufferData.video.bandwidth}
      );
    }
  }

  return Promise.all(promises);
};

/**
 * Append buffered bytes to a sourcebuffer.
 *
 * @param {Object} update The update containing the buffer to be appended.
 * @protected
 */
ACMEBuffer.prototype._appendUpdate = function(update) {
  var sourceBuffer = this._sourceBuffers[update.codec];
  var shouldQueueUpdate = !sourceBuffer || sourceBuffer.updating;

  if (shouldQueueUpdate) {
    this._updateQueue.push(update);
    return;
  }

  // We mark this chunk as no longer appending regardless of whether we succeed
  // or not in appending it so we can retry it if it fails.
  this._removeAppendingFragment(update.fragment);

  try {
    sourceBuffer.appendBuffer(update.buffer);
  } catch (e) {
    if (e.name === 'QuotaExceededError') {
      this.emitSync(Event.BUFFER_QUOTA_EXCEEDED);
    }
    debugLogger.warn('Failed to append buffer', e);

    // Since an error here will not trigger an `updateend`, we should trigger
    // this ourself.
    Promise.resolve().then(this.dequeueUpdates).then(function() {
      // Wait until the dequeueing is fired to ensure that this is not included
      // in the immediate dequeueing.
      if (update.init) {
        this._updateQueue.push(update);
        return;
      }
    }.bind(this));

    if (update.init) {
      // Do not resolve yet.
      return;
    }
  }
  if (update.resolve) {
    update.resolve(true);
  }
};

/**
 * Aborts the SourceBuffers of a MediaSource.
 *
 * @param {boolean} removeBuffered If set to true, the operation will also clear
 *     any buffered segments.
 * @public
 */
ACMEBuffer.prototype.abort = function(removeBuffered) {
  if (this._disableBufferAbort) {
    debugLogger.info('Buffer abort skipped; action disabled.');
    return;
  }
  this._lastBufferClearTime = Date.now();
  if (this._mediaSource) {
    var sourceBuffers = this._mediaSource.sourceBuffers;
    for (var i = 0, len = sourceBuffers.length; i < len; i++) {
      if (this._mediaSource.readyState === 'open') {
        var sourceBuffer = sourceBuffers[i];
        try {
          sourceBuffer.abort();
          var buffered = sourceBuffer.buffered;
          if (removeBuffered && buffered.length) {
            var start = buffered.start(0);
            var end = buffered.end(buffered.length - 1);
            sourceBuffer.remove(start, end);
            debugLogger.info('Cleared buffer range', start, end);
          }
        } catch (e) {
          debugLogger.warn('ACMEBuffer.clear failed.', e);
        }
      }
    }
  }
  this._appendingFragments = [];
};

/**
 * Returns the HTMLMediaElement's buffered range for a particular time.
 *
 * @param {number} time The time in milliseconds.
 * @return {{start: number, end: number}} The range.
 * @protected
 */
ACMEBuffer.prototype._getBufferedFor = function(time) {
  var timeRanges =
    this._mediaSource.sourceBuffers &&
    this._mediaSource.sourceBuffers.length > 0 &&
    this._mediaSource.sourceBuffers[0].buffered;

  if (timeRanges) {
    var timeRangeStart;
    var timeRangeEnd;
    for (var i = 0; i < timeRanges.length; i++) {
      timeRangeStart = timeRanges.start(i);
      timeRangeEnd = timeRanges.end(i);
      if (timeRangeStart <= time && time <= timeRangeEnd) {
        return {start: timeRangeStart, end: timeRangeEnd};
      }
    }
  }

  return null;
};

/**
 * Return the mediasource of the ACMEBuffer instance.
 *
 * @public
 * @return {MediaSource}
 */
ACMEBuffer.prototype.getMediaSource = function() {
  return this._mediaSource;
};

/**
 * Tries to perform an update from the source buffer.
 *
 * If the update cannot be performed (such as when there's another update being
 * applied), the update is queued.
 *
 * If the updates' `playId` field is not the same with the ACMEPlayer's current
 * _playId value, the update is marked as stale and is ignored.
 *
 * @param {module:spotify-playback/player~UpdateOperation} update The
 *     update operation to perform.
 * @protected
 */
ACMEBuffer.prototype.tryUpdate = function(update) {
  if (!update) {
    return;
  }

  if (update.playId !== this._playId) {
    debugLogger.info('Try update dropped: playId has changed');
    this._abortUpdate(update);
    return;
  }

  if (update.timestamp < this._lastBufferClearTime) {
    debugLogger.info('Try update dropped: update is older than the last clear');
    this._abortUpdate(update);
    return;
  }

  var mediaSource = this._mediaSource;
  var shouldQueueUpdate =
    mediaSource.readyState !== 'open' &&
    mediaSource.readyState !== 'ended';

  if (shouldQueueUpdate) {
    this._updateQueue.push(update);
  } else {
    this._processUpdate(update);
  }
};

/**
 * Cancel an update and perform cleanup routines.
 *
 * @param {module:spotify-playback/player~UpdateOperation} update The
 *     update operation to cancel.
 * @private
 */
ACMEBuffer.prototype._abortUpdate = function(update) {
  // If it was an append update, remove any operations for it.
  if (update.fragment) {
    this._removeAppendingFragment(update.fragment);
  }

  if (update.resolve) {
    update.resolve(false);
  }

  // Make sure to call any other queued updates.
  Promise.resolve().then(this.dequeueUpdates);
};

/**
 * Perform an update to the buffer.
 *
 * @param {module:spotify-playback/player~UpdateOperation} update The
 *     update operation to be executed.
 * @private
 */
ACMEBuffer.prototype._processUpdate = function(update) {
  if (update.type === 'end') {
    this._endUpdate(update);
  } else if (update.type === 'duration') {
    this._durationUpdate(update);
  } else if (update.type === 'append') {
    this._appendUpdate(update);
  }
};

/**
 * Checks whether any of the source buffers for the current MediaSource is in an
 * updating state.
 *
 * @return {boolean} True is any of the source buffers is appending.
 * @protected
 */
ACMEBuffer.prototype._isUpdating = function() {
  var mediaSource = this._mediaSource;
  var sourceBuffers = mediaSource.sourceBuffers;

  for (var i = 0, l = sourceBuffers.length; i < l; i++) {
    var sourceBuffer = sourceBuffers[i];
    if (sourceBuffer && sourceBuffer.updating) {
      return true;
    }
  }
  return false;
};

/**
 * Perform the update to end the stream.
 *
 * @param {module:spotify-playback/player~UpdateOperation} update The
 *     update operation to be executed.
 * @private
 */
ACMEBuffer.prototype._endUpdate = function(update) {
  // endOfStream can only be called if all of the source buffers are not in an
  // updating state.
  if (this._isUpdating()) {
    this._updateQueue.push(update);
  } else if (this._mediaSource.readyState === 'open') {
    this._mediaSource.endOfStream();
    if (update.resolve) {
      update.resolve(true);
    }
  }
};

/**
 * Sets the duration of the MediaSource.
 *
 * @param {module:spotify-playback/player~UpdateOperation} update The
 *     update operation to be executed.
 * @protected
 */
ACMEBuffer.prototype._durationUpdate = function(update) {
  if (this._isUpdating()) {
    this._updateQueue.push(update);
  } else {
    this._mediaSource.duration = update.duration;
    if (update.resolve) {
      update.resolve(true);
    }
  }
};

/**
 * Destroys the source buffers in the current MediaSource.
 *
 * @protected
 */
ACMEBuffer.prototype._destroySourceBuffers = function() {
  var mediaSource = this._mediaSource;
  if (!mediaSource) {
    return;
  }
  var sourceBuffers = mediaSource.sourceBuffers;
  if (sourceBuffers.length) {
    for (var i = 0, l = sourceBuffers.length; i < l; i++) {
      var sourceBuffer = sourceBuffers[i];
      sourceBuffer.removeEventListener('updateend', this.dequeueUpdates);
      try {
        mediaSource.removeSourceBuffer(sourceBuffer);
        debugLogger.info('Removed source buffer');
      } catch (e) {
        debugLogger.warn('Failed to remove sourcebuffer', e);
      }
    }
  }
  this._sourceBuffers = {};
};

/**
 * Remove references to and from mediasource and sourcebuffers.
 *
 * @public
 */
ACMEBuffer.prototype.destroy = function() {
  var mediaSource = this._mediaSource;
  if (!mediaSource) {
    return;
  }
  debugLogger.info('Source destroyed');
  mediaSource.removeEventListener('sourceopen', this._onSourceOpen);
  mediaSource.removeEventListener('sourceclose', this._onSourceClose);
  this._destroySourceBuffers();
  this._mediaSource = null;
};

/**
 * Marks the stream as ended.
 *
 * @protected
 */
ACMEBuffer.prototype._endOfStream = function() {
  if (this._mediaSource.readyState !== 'ended') {
    this.tryUpdate({
      playId: this._playId,
      timestamp: Date.now(),
      type: 'end'
    });
  }
};

/**
 * Progress handler.
 *
 * @param {module:spotify-playback/_internal/track |
 *         module:spotify-playback/_internal/videotrack} acmeTrack
 *     The playing track.
 * @param {boolean} isSeeking True if the player is seeking when this function
 *     is called.
 * @param {number} time The current progress in seconds.
 * @public
 */
ACMEBuffer.prototype.progress = function(acmeTrack, isSeeking, time) {
  var seekThreshold = 5;
  var mediaSource = this._mediaSource;

  if (
    mediaSource &&
    acmeTrack &&
    (mediaSource.readyState === 'open' || mediaSource.readyState === 'ended')
  ) {
    var fragment;
    var endTime;

    var isVideo = acmeTrack.getMediaType() === 'video';
    var buffered = this._getBufferedFor(time);
    if (!buffered) {
      // Nothing is buffered for this position, insert the segment.
      fragment = acmeTrack.getFragmentForTime(time);
      if (fragment) {
        this.appendFragment(acmeTrack, fragment, isSeeking)
          .catch(_ignoreEmittedErrors);
        // Check if there's enough time to receive the next progress event
        // before the appended fragment ends. If it's less than 5 seconds, then
        // we immediately queue the next segment.
        if (fragment.timeEnd < (time + seekThreshold)) {
          endTime = isVideo ? Math.floor(time) : time;
          var nextFragment = acmeTrack.getFragmentAfterTime(endTime);
          if (nextFragment) {
            this.appendFragment(acmeTrack, nextFragment, isSeeking)
              .catch(_ignoreEmittedErrors);
          } else {
            // There wasn't any fragment, so end the stream.
            this._endOfStream();
          }
        }
      } else {
        // There's no fragment for this position. It's most likely beyond the
        // playable range, so let's end the stream.
        this._endOfStream();
      }
    } else {
      if ((time + ENSURE_BUFFERED_TIME) > mediaSource.duration) {
        if (mediaSource.readyState === 'open') {
          this._endOfStream();
        }
        return;
      }

      var fragmentLength = acmeTrack.getFragmentLength();
      // Can we play the current fragment to the end?
      var requiredSegments = Math.ceil(time / fragmentLength);
      var bufferedSegments = Math.floor(buffered.end / fragmentLength);

      if (requiredSegments > bufferedSegments) {
        // We won't be able to play through the entire fragment, so we need to
        // reinject from the current position.
        fragment = acmeTrack.getFragmentForTime(time);
        if (fragment) {
          this.appendFragment(acmeTrack, fragment, isSeeking)
            .catch(_ignoreEmittedErrors);
        }
      }

      // We have some stuff buffered, check if we have enough to play at least
      // 10 seconds in the future.
      var playableRemaining = Math.floor(buffered.end - time);
      if (playableRemaining > ENSURE_BUFFERED_TIME) {
        // We have enough buffered.
        return;
      }

      var needToFill = Math.min(
        acmeTrack.getFragmentLength(),
        ENSURE_BUFFERED_TIME - playableRemaining
      );
      if (needToFill < 1) {
        // How much is missing? We only need to fill if there's more than a
        // second missing right now, because it'll grow for the next progress()
        // call anyway.
        return;
      }

      // We always floor in order to compensate for times when we have missing
      // floating point time frames in the buffer.
      endTime = Math.floor(buffered.end + needToFill);

      fragment = acmeTrack.getFragmentForTime(endTime);
      if (fragment) {
        this.appendFragment(acmeTrack, fragment, isSeeking)
          .catch(_ignoreEmittedErrors);
      } else {
        // There's no fragment after the current one, so end the stream.
        this._endOfStream();
      }
    }
  }
};

/**
 * Recreate the buffer by detroying current mediasource and sourcebuffers, and
 *     re-initializing the ACMEBuffer.
 *
 * @param {Array.<string>} codecs A list containing the buffers active codecs
 *     for the new ACMEBuffer.
 * @public
 */
ACMEBuffer.prototype.recreate = function(codecs) {
  this.abort();
  this.destroy();

  this._codecs = codecs;
  this._init();
};

/**
 * Updates the duration of the mediasource.
 *
 * @param {number} duration The duration.
 * @public
 */
ACMEBuffer.prototype.setDuration = function(duration) {
  this.tryUpdate({
    playId: this._playId,
    timestamp: Date.now(),
    type: 'duration',
    duration: duration
  });
};

/**
 * Updates the playId of the ACMEBuffer.
 *
 * @param {number} playId The playId.
 * @public
 */
ACMEBuffer.prototype.setPlayId = function(playId) {
  this._playId = playId;
};

module.exports = ACMEBuffer;
