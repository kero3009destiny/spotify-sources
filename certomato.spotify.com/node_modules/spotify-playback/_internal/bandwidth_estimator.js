'use strict';

var MovingAverage = require('./moving_average');

/**
 * Default initial bandwidth.
 *     This is used if the runtime doesn't provide acces to the
 *     navigator.connection API
 *     The value is 500kBps, which is 2g speed.
 *
 * @type {number}
 * @private
 * @const
 */
var UNKNOWN_BANDWIDTH_DEFAULT = 4e5;

/**
 * Minimum size of a sample for it to be used in the calculation of the
 *     average.
 *
 * @type {number}
 * @private
 * @const
 */
var MIN_SAMPLE_THRESHOLD = 16e3; // 16kB;

/**
 * Minimum number of bytes to have sampled before accepting the average from
 *     the exponential moving averages (EMAs).
 *
 * @type {number}
 * @private
 * @const
 */
var MIN_TOTAL_THRESHOLD = 128e3; // 128kB;

/**
 * Creates a new BandwidthEstimator.
 *
 * @param {number} defaultBandwidth Default initial bandwidth to use if
 *     navigator.connection.downlink is unavailable.
 * @constructor
 */
function BandwidthEstimator(defaultBandwidth) {
  /**
   * Default initial bandwidth to use if navigator.connection.downlink is
   *     unavailable.
   *
   * @type {number}
   */
  this._defaultBandwidth = defaultBandwidth || UNKNOWN_BANDWIDTH_DEFAULT;

  /**
   * Total amount of bytes used for sampling the bandwidth.
   *
   * @type {number}
   */
  this._totalBytes = 0;

  /**
   * Moving Exponential Average with short expiry.
   *
   * @type {MovingAverage}
   */
  this._short = new MovingAverage(2);

  /**
   * Moving Exponential Average with long expiry.
   *
   * @type {MovingAverage}
   */
  this._long = new MovingAverage(5);

  /**
   * When set to a truthy value, this will override the recommended bandwidth
   * estimate returned from getBandwidthEstimate.
   *
   * @type {number}
   */
  this._overrideBitrate = 0;

  this._onConnectionChange = this._onConnectionChange.bind(this);

  this._init();
}

/**
 * Initialize the instance.
 *
 * @protected
 */
BandwidthEstimator.prototype._init = function() {
  if (
    global.navigator &&
    global.navigator.connection &&
    global.navigator.connection.downlink
  ) {
    this._defaultBandwidth = global.navigator.connection.downlink * 1e6;
    global.navigator.connection.addEventListener(
      'change',
      this._onConnectionChange
    );
  }
};

/**
 * Handles change events fired from `navigator.connection`.
 *
 * @param {Event} e The event containing the updated NetworkInformation.
 * @protected
 */
BandwidthEstimator.prototype._onConnectionChange = function(e) {
  this._defaultBandwidth = e.target.downlink * 1e6;
};

/**
 * Returns the current bandwidth estimate, calculated from the minum value of
 *     the short and long windowed averages respectively.
 *
 * @return {number}
 */
BandwidthEstimator.prototype.getBandwidthEstimate = function() {
  if (this._overrideBitrate) {
    return this._overrideBitrate;
  }
  if (this._totalBytes < MIN_TOTAL_THRESHOLD) {
    return this._defaultBandwidth;
  }
  var fast = this._short.getEstimate();
  var slow = this._long.getEstimate();
  return Math.min(fast, slow);
};

/**
 * Add a sample to the estimator.
 *
 * @param {number} bytes The size of the download, in bytes.
 * @param {number} time Duration of the download, in seconds.
 */
BandwidthEstimator.prototype.sample = function(bytes, time) {
  if (bytes < MIN_SAMPLE_THRESHOLD) {
    return;
  }
  var bandwidth = bytes * 8000 / time;
  this._totalBytes += bytes;

  this._short.sample(time, bandwidth);
  this._long.sample(time, bandwidth);
};

/**
 * Overrides bitrate recommendation value with a specific value.
 *
 * @param {number} value The override bitrate value, falsy or negative value
 *     resets stops the override.
 */
BandwidthEstimator.prototype.overrideBitrate = function(value) {
  if (value <= 0) {
    this._overrideBitrate = 0;
  } else {
    this._overrideBitrate = value;
  }
};

module.exports = BandwidthEstimator;
