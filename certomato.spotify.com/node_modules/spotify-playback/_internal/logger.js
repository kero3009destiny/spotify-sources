'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var LoggingError = require('../lib/logging_error');
var Event = require('../types/event');
var Errors = require('../types/errors');

var debugLogger = require('spotify-debug-tools/logging')
  .forTag('playback.logger');

var version = require('../version.json');

var MAX_SAFE_SEQUENCE_ID = 9007199254740991;

function ACMELogger(options) {
  this._transport = options.transport;
  this._transportLogger = options.logger;
  this._player = options.player;

  /**
   * The current tracking data, set when it is created.
   *
   * Note: When possible, rely on the tracking data that is passed to the actual
   * event. Use this field only if there's possibility of getting the current
   * tracking data.
   *
   * @type {Object}
   * @protected
   */
  this._currentTrackingData = null;

  /**
   * The sequence id for this log.
   *
   * @type {number}
   * @protected
   */
  this._sequenceId = 0;

  this._sequenceSessionStorage = {};

  this._init();
}
inherit(ACMELogger, EventEmitter);

ACMELogger.create = function(options) {
  return new ACMELogger(options);
};

ACMELogger.prototype._init = function() {
  var player = this._player;
  player.on(Event.PLAYER_LOAD, this._onPlayerLoad.bind(this));
  player.on(Event.PLAYER_ERROR, this._onError.bind(this, false));
  player.on(Event.PLAYER_WARNING, this._onError.bind(this, true));
  player.on(Event.PLAYER_PRELOADING_ERROR, this._onError.bind(this, false));
  player.on(
    Event.PLAYER_TRACKING_DATA_CREATED,
    this._onTrackingDataCreated.bind(this)
  );
  player.on(
    Event.PLAYER_TRACKING_DATA_FINALIZED,
    this._onTrackingDataFinalized.bind(this)
  );
  player.on(
    Event.PLAYER_PLAYBACK_START,
    this._onPlaybackStart.bind(this)
  );
};

ACMELogger.prototype._emitError = function(error, trackingData) {
  this.emit(Event.LOGGER_ERROR, {
    error: error,
    data: trackingData
  });
};

ACMELogger.prototype._onError = function(isWarning, event) {
  var error = event.error;
  var trackingData = this._currentTrackingData;

  if (!trackingData || trackingData.noLog) {
    return;
  }

  var debug = (error && error.debug) || {};
  debug.position = event.position;

  var data = {
    track: event.track || {},
    debug: debug,
    preloading: !!event.preloading,
    session_id: this._sessionId,
    playback_id: trackingData.playbackId || null,
    player_play_id: event.playId || null,
    http_status_code: 'status' in error ? error.status : null,
    license_server: error.licenseServer || null
  };

  this._logError(error.code || Errors.UNKNOWN, error, data, isWarning);
};

ACMELogger.prototype._onPlayerLoad = function(e) {
  var logData = e.logData;
  if (!logData) {
    return;
  }
  if (logData.impressionURLs) {
    var len = logData.impressionURLs.length;
    while (len--) {
      this._logImpression(logData.impressionURLs[len]);
    }
  } else if (logData.impressionURL) {
    this._logImpression(logData.impressionURL);
  }
};

ACMELogger.prototype._onPlaybackStart = function(e) {
  var data = e.data;
  if (data.noLog || data.noStats) {
    return;
  }
  this._logPlaybackStart(data);
};

ACMELogger.prototype._onTrackingDataCreated = function(e) {
  var data = e.data;
  if (data.noLog) {
    this._currentTrackingData = null;
    return;
  }
  this._currentTrackingData = data;
  this._setSessionId();
  if (!data.noTSV) {
    this._setSequenceId();
  }
};

ACMELogger.prototype._setSessionId = function() {
  this._sessionId = this._transport.getInitTime().toString();
};

ACMELogger.prototype._setSequenceId = function() {
  if (this._sessionId) {
    this._sequenceId = this._getSequenceId(this._sessionId);
  }
};

ACMELogger.prototype._onTrackingDataFinalized = function(e) {
  var data = e.data;
  if (data.noLog) {
    return;
  }
  // Playback was paused in the middle of a song, and now we are at a
  // different session from when playback was started. We will report the
  // end of this song as part of a new session, so we reset the ids for
  // this log.
  var staleSession =
    this._sessionId !== this._transport.getInitTime().toString();
  if (staleSession) {
    this._setSessionId();
  }
  if (data.playbackId && !data.noTSV) {
    if (staleSession) {
      this._setSequenceId();
    }
    if (!data.playIntended && !data.played) {
      // The track was loaded without an intent to play (perhaps as part of the
      // context reloading or after the context finishes), but was never played.
      // Since there was no intent to play, we do not log a TSV message, and we
      // rollback the sequence id so we don't get gaps.
      this._rollbackSequenceId(this._sessionId);
      return;
    }
    this._logTrackStreamVerification(data);
  }
  if (!data.noStats) {
    this._logPlaybackStats(data);
  }
};

ACMELogger.prototype._logTrackStreamVerification = function(data) {
  var verificationData = {
    play_track: data.currentTrackUri,
    playback_id: data.playbackId,
    ms_played: data.msPlayed,
    session_id: this._sessionId,
    sequence_id: this._sequenceId,
    next_playback_id: data.nextPlaybackId
  };
  debugLogger.debug('Logged TrackStreamVerification', verificationData);
  this._transportLogger
    .logTrackStreamVerification(verificationData)
    .catch(function(err) {
      var error = new LoggingError(
        Errors.TSV_SENDING_FAILED,
        err.message || 'Unknown reason.'
      );
      this._logError(error.code, err, verificationData);
      this._emitError(error, data);
    }.bind(this));
};

ACMELogger.prototype._logPlaybackStats = function(data) {
  var stats = {
    play_track: data.currentTrackUri,
    file_id: data.fileId,
    playback_id: data.playbackId,
    internal_play_id: data.internalPlayId,
    memory_cached: data.memoryCached,
    persistent_cached: data.persistentCached,
    audio_format: data.audiocodec,
    video_format: data.videocodec,
    manifest_id: data.fileId,
    isProtected: data.isProtected,
    key_system: data.keySystem,
    key_system_impl: data.keySystemImpl,
    urls_json: JSON.stringify(data.urls),
    start_time: data.loadTime,
    end_time: data.stopTime,
    external_start_time: data.externalLoadTime,
    ms_play_latency: data.msPlayLatency,
    ms_init_latency: data.msInitLatency,
    ms_head_latency: data.msHeadLatency,
    ms_manifest_latency: data.msManifestLatency,
    ms_resolve_latency: data.msResolveLatency,
    ms_license_session_latency: data.msLicenseSessionLatency,
    ms_license_generation_latency: data.msLicenseGenerationLatency,
    ms_license_request_latency: data.msLicenseRequestLatency,
    ms_license_update_latency: data.msLicenseUpdateLatency,
    ms_played: data.msPlayed,
    ms_nominal_played: data.msPlayed, // FIXME: Support playback speed
    ms_file_duration: data.msFileDuration,
    ms_actual_duration: data.msActualDuration,
    ms_start_position: data.startPosition,
    ms_end_position: data.position,
    ms_seek_rebuffer: data.msSeekRebuffering,
    ms_seek_rebuffer_longest: data.maxMsSeekRebuffering,
    ms_stall_rebuffer: data.msStalled,
    ms_stall_rebuffer_longest: data.maxMsStalled,
    n_stalls: data.nStalls,
    n_seekback: data.nSeeksBackward,
    n_seekforward: data.nSeeksForward,
    start_bitrate: data.startBitrate,
    time_weighted_bitrate: data.timeWeightedBitrate,
    reason_start: data.reasonStart,
    reason_end: data.reasonEnd,
    initially_paused: !data.playIntended,
    had_error: data.hadError,
    n_warnings: data.nWarnings,
    n_navigator_offline: data.nOffline,
    session_id: this._sessionId,
    sequence_id: this._sequenceId
  };
  debugLogger.info('Logging PlaybackStats');
  this._transportLogger
    .logJSSDKPlaybackStats(stats)
    .catch(function(err) {
      var error = new LoggingError(
        Errors.PLAYBACK_STATS_SENDING_FAILED,
        err.message || 'Unknown reason.'
      );
      this._logError(error.code, err, stats);
      this._emitError(error, data);
    }.bind(this));
};

ACMELogger.prototype._logPlaybackStart = function(data) {
  var payload = {
    play_track: data.currentTrackUri,
    file_id: data.fileId,
    playback_id: data.playbackId,
    session_id: this._sessionId,
    ms_start_position: data.startPosition,
    initially_paused: !data.playIntended
  };
  debugLogger.info('Logging PlaybackStart');
  this._transportLogger
    .logJSSDKPlaybackStart(payload)
    .catch(function(err) {
      var error = new LoggingError(
        Errors.PLAYBACK_START_SENDING_FAILED,
        err.message || 'Unknown reason.'
      );
      this._logError(error.code, err, payload);
      this._emitError(error, data);
    }.bind(this));
};

ACMELogger.prototype._getSequenceId = function(key) {
  var sequenceId = this._sequenceSessionStorage[key];
  if (!sequenceId) {
    sequenceId = 0;
  }
  if ((sequenceId + 1) >= MAX_SAFE_SEQUENCE_ID) {
    sequenceId = 0;
  }
  this._sequenceSessionStorage[key] = sequenceId + 1;
  return sequenceId;
};

ACMELogger.prototype._rollbackSequenceId = function(key) {
  var sequenceId = this._sequenceSessionStorage[key];
  if (sequenceId) {
    this._sequenceSessionStorage[key] = Math.max(sequenceId - 1, 0);
  }
};

ACMELogger.prototype._logImpression = function(url) {
  this._transport.request(url, {forget: true}).catch(function(e) {
    debugLogger.warn('Unable to send impression request', e);
  });
};

ACMELogger.prototype._logError = function(code, error, jsonData, isWarning) {
  var stackTrace = '';
  if (error) {
    stackTrace = error.stack;
    if (!stackTrace) {
      stackTrace = error.toString();
    }
  }
  var data = {
    source: 'playback',
    source_version: version.tagged,
    type: code,
    message: error && error.message,
    stack: stackTrace,
    json_data: jsonData,
    json_data_version: '1.0.0'
  };

  if (isWarning) {
    this._transportLogger.logJSSDKWarning(data).catch(function(e) {
      debugLogger.warn('Failed to log warning', data, e);
    });
  } else {
    this._transportLogger.logJSSDKError(data).catch(function(e) {
      debugLogger.warn('Failed to log error', data, e);
    });
  }
};

module.exports = ACMELogger;
