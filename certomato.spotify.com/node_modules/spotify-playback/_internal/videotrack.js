'use strict';

var Promise = require('spotify-promise-plus');
var Base64 = require('spotify-crypto/base64');
var FragmentError = require('../lib/fragment_error');
var Errors = require('../types/errors');

var FileError = require('../lib/file_error');
var KeySystemSetting = require('./keysystem_setting');

/**
 * This value is used to give the network some space, so that not all of the
 *     available bandwidth we get from the estimates is consumed for streaming
 *     media.
 *     We need some breathing room so that other requests can be made during
 *     video playback without inducing stuttering.
 *
 * @type {number}
 * @private
 * @const
 */
var OVERHEAD = 1e5;

/**
 * An object representation of a video that can be played by the ACMEPlayer.
 *
 * This class also manages the fragments for protected tracks encoded as CENC.
 *
 * @constructor
 * @param {module:spotify-playback/_internal/track~ACMETrackOptions}
 *     options The options for this instance.
 */
function ACMEVideoTrack(options) {
  var opts = options || {};
  /**
   * The current keysystem.
   *
   * @type {string}
   * @protected
   */
  this._keySystem = options.keySystem;

  /**
   * The keySystem settings for the keySystem.
   *
   * @type {module:spotify-playback/_internal/protection.KeySystemSetting}
   * @protected
   */
  this._keySystemSettings = KeySystemSetting[this._keySystem];

  /**
   * The media type of the track.
   *
   * @type {string}
   * @protected
   */
  this._mediaType = 'video';

  /**
   * A flag indicating whether this instance's load method has been called
   * successfully.
   *
   * @type {boolean}
   * @protected
   */
  this._loaded = false;

  /**
   * An instance of transport that can be used to make requests.
   *
   * @type {module:spotify-transport}
   * @protected
   */
  this._transport = options.transport;

  /**
   * String represenstation of the video codec of a track.
   * @type {string}
   * @protected
   */
  this._videoCodec = options.videoCodec || 'vp8';

  /**
   * String represenstation of the video mimetype of a track.
   * @type {string}
   * @protected
   */
  this._videoMimeType = options.videoMimeType || 'video/webm';

  /**
   * String represenstation of the audio codec of a track.
   * @type {string}
   * @protected
   */
  this._audioCodec = options.audioCodec || 'opus';

  /**
   * String represenstation of the audio mimetype of a track.
   * @type {string}
   * @protected
   */
  this._audioMimeType = options.audioMimeType || 'audio/webm';

  /**
   * True if track is an ad.
   *
   * @type {bool}
   * @protected
   */
  this._isAd = options.isAd;

  /**
   * An ID that is resolved in the player service and with the options to this
   *     constructor.
   *     Contrary to the audio track representation of this property, this is
   *     id is actually the id of the video track manifest rather than a
   *     specific media file (since a video track is represented by several
   *     files).
   *
   * @type {string}
   * @protected
   */
  this._fileId = options.fileId;

  /**
   * An array containing the different fragments for the track.
   *
   * @type {Array.<module:spotify-playback/types/media~TrackFragment>}
   * @protected
   */
  this._fragments = [];

  /**
   * The length of the segments, in seconds.
   *
   * @type {number}
   * @protected
   */
  this._segmentLength = 0;

  /**
   * An array containing the different available subtitle languages for the
   *     track.
   *
   * @type {Array.<String>}
   * @protected
   */
  this._subtitleLanguages = [];

  /**
   * The calculated duration of the track.
   *
   * @type {number}
   * @protected
   */
  this._duration = 0;

  /**
   * The "init fragment" of the track. Contains metadata about the track's
   * protection as well as the sidx table.
   *
   * @type {module:spotify-playback/types/media~TrackFragment}
   * @protected
   */
  this._initFragment = null;

  /**
   * Current video profile, populated (by a selection made based on the
   *     runtime) from a video's manifest file.
   *
   * @type {object}
   * @protected
   */
  this._videoProfile = null;

  /**
   * All video profiles for this track, populated (by a selection made based on
   *     the runtime) from a video's manifest file.
   *
   * @type {object}
   * @protected
   */
  this._videoProfiles = [];

  /**
   * Current audio profile, populated (by a selection made based on the
   *     runtime) from a video's manifest file.
   *
   * @type {object}
   * @protected
   */
  this._audioProfile = null;

  /**
   * The protection type for the file.
   *
   * @type {string}
   * @protected
   */
  this._protection = null;

  /**
   * The PSSH Box containing the protection details for the track.
   *
   * @type {ArrayBuffer}
   * @protected
   */
  this._psshBox = null;

  /**
   * A video-track-to-CDN resolver.
   *
   * @type {module:spotify-playback/types.StorageResolver}
   * @protected
   */
  this._resolver = opts.resolver;

  /**
   * Bandwidth estimator instance.
   *
   * @see {module:spotify-playback/_internal/bandwidth_estimator}
   * @protected
   */
  this._abrManager = opts.abrManager;

  /**
   * An array containing the resolved URLs, populated from a videos manifest
   *     file.
   *
   * @type {Array.<String>}
   * @protected
   */
  this._resolvedURLs = [];

  /**
   * FQDN of the currently active CDN, populated from a videos manifest file.
   *
   * @type {String}
   * @protected
   */
  this._baseURL = '';

  /**
   * Copy of `this._resolvedURLs` minus whichever ones are either
   *     currently active or have failed, populated from a videos manifest
   *     file.
   *
   * @type {Array.<String>}
   * @protected
   */
  this._fallbackURLs = [];

  /**
   * String template for constructing the init segment url, populated from a
   *     videos manifest file.
   *
   * @type {String}
   * @protected
   */
  this._initTemplate = '';

  /**
   * String template for constructing urls for fetching segments, populated
   *     from a videos manifest file.
   *
   * @type {String}
   * @protected
   */
  this._segmentTemplate = '';

  /**
   * When set to true, the track's buffers will not be cached.
   *
   * @type {boolean}
   * @protected
   */
  this._disableCache = options.disableCache;

  /**
   * Optional license server url.
   *     If unset, the default one in license_url_resolver will be used.
   *
   * @type {?string}
   * @protected
   */
  this._licenseEndpoint = options.licenseEndpoint || null;
}

/**
 * Creates a new ACMEVideoTrack
 *
 * @param {module:spotify-playback/_internal/track~ACMETrackOptions}
 *     options The options for this instance.
 * @static
 * @return {module:spotify-playback/_internal/videotrack}
 */
ACMEVideoTrack.create = function(options) {
  var opts = options || {};
  return new ACMEVideoTrack(opts);
};

/**
 * Constructs a string representation of an audio MimeType.
 *
 * @param {Object} profile Audio profile to base the MimeType on.
 * @return {string}
 * @protected
 */
ACMEVideoTrack.prototype._constructAudioMimeType = function(profile) {
  return profile.mime_type + ';codecs="' + profile.audio_codec + '"';
};

/**
 * Constructs a string representation of a video MimeType.
 *
 * @param {Object} profile Video profile to base the MimeType on.
 * @return {string}
 * @protected
 */
ACMEVideoTrack.prototype._constructVideoMimeType = function(profile) {
  return profile.mime_type + ';codecs="' + profile.video_codec + '"';
};

/**
 * Currently a Noop for video tracks.
 *
 */
ACMEVideoTrack.prototype.abort = function() {
  /* noop */
};

/**
 * Calculates the different fragments from the descriptor.
 *
 * @param {module:spotify-playback/types/media~VideoManifestDescriptor}
 *     manifest The descriptor for the video.
 * @protected
 */
ACMEVideoTrack.prototype._calculateFragments = function(manifest) {
  this._duration = manifest.end_time_millis / 1000;
  var segmentLength = this._segmentLength;

  this._initFragment = {
    init: true,
    cacheBuffer: !this._disableCache,
    bitrate: 0,
    quality: 0,
    audio: {
      bufferURL: null,
      buffer: null,
      codec: this._constructAudioMimeType(this._audioProfile)
    },
    video: {
      bufferURL: null,
      buffer: null,
      codec: this._constructVideoMimeType(this._videoProfile)
    }
  };

  for (var i = 0; i < this._duration; i += segmentLength) {
    this._fragments.push({
      bitrate: 0,
      cacheBuffer: !i && !this._disableCache,
      timeStart: i,
      timeEnd: i + segmentLength,
      quality: 0,
      fetchingBufferPromise: null,
      audio: {
        bufferURL: null,
        buffer: null,
        codec: this._constructAudioMimeType(this._audioProfile)
      },
      video: {
        bufferURL: null,
        buffer: null,
        codec: this._constructVideoMimeType(this._videoProfile)
      }
    });
  }
};

ACMEVideoTrack.prototype._calculateVariants = function(
  variants,
  encryptionIndex
) {
  var videoCodec = this._videoCodec;
  var videoMimeType = this._videoMimeType;
  var audioCodec = this._audioCodec;
  var audioMimeType = this._audioMimeType;
  var videoProfiles = [];
  var audioProfiles = [];
  for (var i = 0, len = variants.length; i < len; i++) {
    var profile = variants[i];
    if (profile.video_codec === videoCodec &&
        profile.mime_type === videoMimeType &&
        profile.encryption_index === encryptionIndex) {
      videoProfiles.push(profile);
    } else if (profile.audio_codec === audioCodec &&
               profile.mime_type === audioMimeType &&
               profile.encryption_index === encryptionIndex) {
      audioProfiles.push(profile);
    }
  }
  this._videoProfiles = this._sortByProfilesByBitrate(videoProfiles);
  this._audioProfiles = audioProfiles;
};

ACMEVideoTrack.prototype._sortByProfilesByBitrate = function(profile) {
  // make sure the variants are sorted by max_bitrate
  return profile.sort(function(a, b) {
    return a.max_bitrate - b.max_bitrate;
  });
};

/**
 * Constructs URLs for a fragment.
 *
 * @param {Object} fragment The fragment to get urls for.
 * @protected
 * @return {Object}
 */
ACMEVideoTrack.prototype._constructFragmentURL = function(fragment) {
  var urls;
  if (fragment.init) {
    urls = this._resolver.getInitSegmentURLs(
      this._baseURL,
      this._initTemplate,
      this._audioProfile,
      this._videoProfile
    );
  } else {
    urls = this._resolver.getSegmentURLs(
      this._baseURL,
      this._segmentTemplate,
      fragment.timeStart,
      this._audioProfile,
      this._videoProfile
    );
  }
  return urls;
};

/**
 * Fetches the buffer bytes for a fragment.
 *
 * @param {Object} fragment The fragment to get bytes for.
 * @protected
 * @return {Promise}
 */
ACMEVideoTrack.prototype._fetchBufferForFragment = function(fragment) {
  if (!fragment.fetchingBufferPromise) {
    var start = Date.now();
    var resolution = this._videoProfile.video_resolution;
    var requestOptions = {
      method: 'GET',
      responseType: 'arraybuffer',
      timing: true,
      retry: {
        condition: function(response, StatusFamily) {
          if (response.status === 0) {
            return true;
          }
          var statusFamily = response.getStatusFamily();
          if (statusFamily === StatusFamily.CONNECTION_ERROR ||
              statusFamily === StatusFamily.SERVER_ERROR) {
            return true;
          }
          return false;
        }
      }
    };

    var urls = this._constructFragmentURL(fragment);
    fragment.fetchingBufferPromise = Promise.all([
      this._transport.request(urls.audio, requestOptions)
        .then(this._parseFragmentResponse.bind(this, fragment, 'audio')),
      this._transport.request(urls.video, requestOptions)
        .then(this._parseFragmentResponse.bind(this, fragment, 'video'))
    ])
      .spread(function(audioResp, videoResp) {
        fragment.quality = resolution;
        fragment.bitrate = this._videoProfile.video_bitrate;
        if (fragment.cacheBuffer) {
          fragment.audio.buffer = audioResp.buffer;
          fragment.audio.bufferURL = urls.audioLogging;
          fragment.video.buffer = videoResp.buffer;
          fragment.video.bufferURL = urls.videoLogging;
        }
        fragment.fetchingBufferPromise = null;
        this._abrManager.sample(
          audioResp.buffer.byteLength + videoResp.buffer.byteLength,
          Date.now() - start
        );
        this._updateVariants();

        return {
          audio: {
            bufferURL: urls.audioLogging,
            buffer: audioResp.buffer,
            codec: fragment.audio.codec,
            bandwidth: audioResp.bandwidth
          },
          video: {
            bufferURL: urls.videoLogging,
            buffer: videoResp.buffer,
            codec: fragment.video.codec,
            bandwidth: videoResp.bandwidth
          }
        };
      }.bind(this))
      .catch(function(err) {
        fragment.fetchingBufferPromise = null;
        return Promise.reject(err);
      });
  }
  return fragment.fetchingBufferPromise;
};

/**
 * Handles responses to fragment requests and parses them.
 *
 * @param {Object} fragment The fragment that should receive the buffer bytes.
 * @param {string} type MediaType for the buffer, either 'audio' or 'video'.
 * @param {Object} response The HTTP response object from transport.
 * @protected
 * @return {Promise}
 */
ACMEVideoTrack.prototype._parseFragmentResponse = function(
  fragment,
  type,
  response
) {
  var timeRange = fragment.timeStart + '-' + fragment.timeEnd;
  var codec = fragment[type] ? fragment[type].codec : null;
  switch (response.status) {
    case 0: // Most likely offline, reject so we can rety.
      return Promise.reject(
        new FragmentError(
          Errors.FRAGMENT_REQUEST_FAILED_WITH_ZERO,
          'Request failed with status 0.',
          0,
          {
            time_range: timeRange,
            codec: codec,
            quality: fragment.quality
          }
        )
      );
    case 200:
    case 206: // Successful
      if (!response.body) {
        return Promise.reject(
          new FragmentError(
            Errors.FRAGMENT_REQUEST_EMPTY_RESPONSE,
            'Empty response for successful buffer.',
            response.status,
            {
              time_range: timeRange,
              codec: codec,
              quality: fragment.quality
            }
          )
        );
      }
      return Promise.resolve({
        buffer: response.body,
        bandwidth: 8000 * response.body.byteLength / response.timing.completed
      });
    case 403:
    // TODO: handle expired urls once we know how and if CDN:urls are
    // delivered to us.
      break;
    default:
      break;
  }
  return Promise.reject(
    new FragmentError(
      Errors.FRAGMENT_REQUEST_FAILED_WITH_STATUS,
      'Buffer request failed with status ' + response.status,
      response.status,
      {
        time_range: timeRange,
        codec: codec,
        quality: fragment.quality
      }
    )
  );
};

ACMEVideoTrack.prototype.getBitrateForTime = function(time) {
  if (this._fragments === null) {
    return 0;
  }
  var divisor = this._segmentLength;
  var index = (time - time % divisor) / divisor;
  return this._fragments[index].bitrate;
};

/**
 * Returns the length of video fragments.
 *
 * @return {number} The average length of fragments.
 */
ACMEVideoTrack.prototype.getFragmentLength = function() {
  return this._segmentLength;
};

/**
 * Returns the optional property value for the license server url.
 *
 * @return {?string} The endpoint url if it's set.
 */
ACMEVideoTrack.prototype.getLicenseEndpoint = function() {
  return this._licenseEndpoint;
};

/**
 * Returns buffer for a fragment, after having fetched the bytes for it.
 *
 * @param {Object} fragment The fragment that should receive the buffer bytes.
 * @return {Promise}
 */
ACMEVideoTrack.prototype.getBufferForFragment = function(fragment) {
  if (
    fragment.audio.buffer &&
    fragment.video.buffer &&
    fragment.quality >= this._videoProfile.video_resolution
  ) {
    return Promise.resolve({
      audio: {
        bufferURL: fragment.audio.bufferURL,
        buffer: fragment.audio.buffer,
        codec: fragment.audio.codec,
        bandwidth: null
      },
      video: {
        bufferURL: fragment.video.bufferURL,
        buffer: fragment.video.buffer,
        codec: fragment.video.codec,
        bandwidth: null
      }
    });
  }

  return this._fetchBufferForFragment(fragment);
};

/**
 * Clears all cached buffer for this track.
 *
 */
ACMEVideoTrack.prototype.clearCachedBuffers = function() {
  if (this._initFragment) {
    this._initFragment.audio.buffer = null;
    this._initFragment.video.buffer = null;
  }

  this._fragments.forEach(function(fragment) {
    fragment.audio.buffer = null;
    fragment.video.buffer = null;
  });
};

/**
 * Parses a base64 encoded PSSH box and converts it into a Uint8Array.
 *
 * @param {string} psshBox A base64 encoded PSSH Box.
 * @return {Uint8Array} The decoded PSSH Box.
 */
ACMEVideoTrack.prototype._parsePSSHBox = function(psshBox) {
  var decoded = Base64.decode(psshBox);
  var box = new global.Uint8Array(decoded.length);
  for (var i = 0, l = decoded.length; i < l; i++) {
    box[i] = decoded.charCodeAt(i);
  }
  return box;
};

ACMEVideoTrack.prototype._updateVariants = function() {
  var bitrate = this._abrManager.getBandwidthEstimate();
  var videoProfile;
  var profiles = this._videoProfiles;
  var len = profiles.length;
  this._audioProfile = this._audioProfiles[0];
  var audioBitrate = this._audioProfile.audio_bitrate;
  for (var i = 0; i < len; i++) {
    var profile = profiles[i];
    if (
      profile.video_bitrate + audioBitrate < bitrate - OVERHEAD ||
      !videoProfile
    ) {
      videoProfile = profile;
    }
  }
  this._videoProfile = videoProfile || profiles[len - 1];
};

/**
 * Returns the track duration.
 *
 * @return {number} The track duration.
 */
ACMEVideoTrack.prototype.getDuration = function() {
  return this._endTime;
};

/**
 * Returns the next fragment after a particular time.
 *
 * @param {number} time The time in seconds.
 * @return {module:spotify-playback/types/media-TrackFragment} The fragment
 *     for the time specified, or null if the time is out of bounds.
 */
ACMEVideoTrack.prototype.getFragmentAfterTime = function(time) {
  if (this._fragments === null) {
    return null;
  }

  var fragment = null;
  if (time === 0 || time === 0.01) {
    fragment = this._fragments[1];
  } else {
    for (var i = 0, l = this._fragments.length; i < l; i++) {
      if (this._fragments[i].timeStart >= time) {
        fragment = this._fragments[i];
        break;
      }
    }
  }

  return fragment;
};

/**
 * Returns the fragment for a particular time.
 *
 * @param {number} time The time in seconds.
 * @return {module:spotify-playback/types/media-TrackFragment} The fragment
 *     for the time specified, or null if the time is out of bounds.
 */
ACMEVideoTrack.prototype.getFragmentForTime = function(time) {
  if (this._fragments === null) {
    return null;
  }

  var fragment = null;
  if (time === 0 || time === 0.01) {
    fragment = this._fragments[0];
  } else {
    for (var i = 0, l = this._fragments.length; i < l; i++) {
      if (this._fragments[i].timeStart <= time &&
          this._fragments[i].timeEnd >= time) {
        fragment = this._fragments[i];
        break;
      }
    }
  }

  return fragment;
};

/**
 * Returns the "init fragment" for the track.
 *
 * @return {module:spotify-playback/types/media~TrackFragment} The init
 *     fragment.
 */
ACMEVideoTrack.prototype.getInitFragment = function() {
  return this._initFragment;
};

/**
 * Returns the codes for the available subtitle languages for the track.
 *
 * @return {Array.<string>} The language codes.
 */
ACMEVideoTrack.prototype.getSubtitleLanguages = function() {
  return this._subtitleLanguages;
};

/**
 * Returns the URL for a specific subtitle file based on its language.
 *
 * @param {string} code Language code for the specific subtitle file.
 * @return {string} The subtitle files URL.
 */
ACMEVideoTrack.prototype.getSubtitleForLanguage = function(code) {
  return this._subtitleTemplate.replace('{{profile_id}}', code);
};

/**
 * Load an ACMEVideoTrack.
 *
 * @param {?object=} measures Object containing latency measurements used for
 *     logging.
 * @return {ACMEVideoTrack} This instance, for chaining.
 */
ACMEVideoTrack.prototype.load = function(measures) {
  var _measures = measures || {};

  if (this._loaded) {
    _measures.resolveLatency = 0;
    _measures.manifestLatency = 0;
    return Promise.resolve(this);
  }

  var timeStart = Date.now();

  return this._resolver.getManifest(this._fileId).then(
    function(manifest) {
      _measures.resolveLatency = 0;
      _measures.manifestLatency = Date.now() - timeStart;

      var error;
      // TODO: Check when it would be possible to have more than 1 content.
      var content = manifest.contents[0];

      if (!content) {
        error = new FileError(
          Errors.FILE_MALFORMED_SEEKTABLE,
          'Malformed seektable: no contents.'
        );
        // Add the acme track so end-song logging will work.
        error.track = this.toLogJSON();
        return Promise.reject(error);
      }

      this._resolvedURLs = manifest.base_urls.slice();
      this._baseURL = manifest.base_urls.shift();
      this._fallbackURLs = manifest.base_urls;
      this._initTemplate = manifest.initialization_template;
      this._segmentTemplate = manifest.segment_template;
      this._segmentLength = content.segment_length;

      // Check encryption
      var encryptionIndex = undefined;

      if (content.encryption_infos && content.encryption_infos.length) {
        // The video is protected. We need to select the appropriate key
        // system.
        var encryptionInfos = content.encryption_infos;
        var ksName = this._keySystemSettings.commonName;
        var pssh;
        for (var i = 0, l = encryptionInfos.length; i < l; i++) {
          var encryptionInfo = encryptionInfos[i];
          if (!encryptionInfo || encryptionInfo.key_system !== ksName) {
            continue;
          }
          encryptionIndex = i;
          pssh = encryptionInfo[this._keySystemSettings.pssh_field.video];
          break;
        }

        if (pssh) {
          this._protection = 'cenc';
          try {
            this._psshBox = this._parsePSSHBox(pssh);
          } catch (e) {
            error = new FileError(
              Errors.FILE_MALFORMED_PSSH,
              'Invalid PSSH value.'
            );
            error.track = this.toLogJSON();
            return Promise.reject(error);
          }
        } else {
          error = new FileError(
            Errors.FILE_FORMAT_NOT_SUPPORTED,
            'KeySystem does not support the file format.'
          );
          error.track = this.toLogJSON();
          return Promise.reject(error);
        }
      }

      this._startTime = manifest.start_time_millis;
      this._endTime = manifest.end_time_millis;
      this._calculateVariants(content.profiles, encryptionIndex);
      this._updateVariants();
      this._calculateFragments(manifest);
      this._subtitleLanguages = manifest.subtitle_language_codes || [];
      return this;
    }.bind(this)
  );
};

/**
 * Set LogData for the track.
 *
 * @param {Object} logData The logData object to attach to this instance.
 * @return {ACMEVideoTrack} This instance, for chaining.
 */
ACMEVideoTrack.prototype.setLogData = function(logData) {
  this._logData = logData;
  return this;
};

/**
 * Returns the URI for the track.
 *
 * @return {string} The track's URI.
 */
ACMEVideoTrack.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the file id for the file.
 *
 * @return {string} The file id.
 */
ACMEVideoTrack.prototype.getFileId = function() {
  return this._fileId;
};

/**
 * Returns the format for the file.
 *
 * @return {string} The format for the file.
 */
ACMEVideoTrack.prototype.getFormat = function() {
  return this._format;
};

/**
 * Returns the duration based on the segments.
 *
 * @return {number} The duration of the file.
 */
ACMEVideoTrack.prototype.getCalculatedDuration = function() {
  return this._duration;
};

/**
 * Returns the duration of the resolve CDN operation..
 *
 * @return {number} The duration resolve CDN operation.
 */
ACMEVideoTrack.prototype.getResolveLatency = function() {
  return undefined;
};

/**
 * Returns the codec to check playability on the video element with.
 *
 * @return {Array.<string>} The codec strings
 */
ACMEVideoTrack.prototype.getPlayableCodecs = function() {
  // The order is important here. The first codec creates the first source
  // buffer in the Buffer class, which is used to create whether certain times
  // in the content are already buffered. We therefore want to put the codec
  // that is fastest to decode first in the list as it'll give a better
  // indication as to whether a segment is already being processed.
  return [
    this._constructAudioMimeType(this._audioProfile),
    this._constructVideoMimeType(this._videoProfile)
  ];
};

/**
 * Returns the resolved URL (i.e., CDN URL) for the track.
 *
 * @return {string} The track's resolved URI.
 */
ACMEVideoTrack.prototype.getResolvedURL = function() {
  return this._resolvedURL;
};

/**
 * Returns all resolved URLs (i.e., CDN URL) for the track.
 *
 * @return {Array.<string>} The track's resolved URLs.
 */
ACMEVideoTrack.prototype.getResolvedURLs = function() {
  return this._resolvedURLs;
};

/**
 * Returns the LogData for this track.
 *
 * @return {Object} The LogData for the track.
 */
ACMEVideoTrack.prototype.getLogData = function() {
  return this._logData;
};

/**
 * Returns the AudioProfile for this track.
 *
 * @return {Object} The AudioProfile for the track.
 */
ACMEVideoTrack.prototype.getAudioProfile = function() {
  return this._audioProfile;
};

/**
 * Returns the VideoProfile for this track.
 *
 * @return {Object} The VideoProfile for the track.
 */
ACMEVideoTrack.prototype.getVideoProfile = function() {
  return this._videoProfile;
};

/**
 * Returns all available profiles for this video.
 *
 * @return {Array.<Object>} The language codes.
 */
ACMEVideoTrack.prototype.getVideoProfiles = function() {
  return this._videoProfiles;
};

/**
 * Returns the init params for the track, used for EME.
 *
 * @return {module:spotify-playback/_internal/track~InitParams} The init
 *     params for the track.
 */
ACMEVideoTrack.prototype.getInitParams = function() {
  var initData = {
    keySystem: this._keySystem,
    initDataType: this._protection,
    initData: this._psshBox,
    licenseServer: null
  };
  return Promise.resolve(initData);
};

/**
 * Returns whether the track is an ad.
 *
 * @return {boolean} True if the track is an ad.
 */
ACMEVideoTrack.prototype.isAd = function() {
  return !!this._isAd;
};

/**
 * Returns whether the track has any protection.
 *
 * @return {boolean} True if the track has an associated protection, false
 *     otherwise.
 */
ACMEVideoTrack.prototype.isProtected = function() {
  return !!this._protection && !!this._psshBox;
};

/**
 * Returns the keysystem for the ACMETrack.
 *
 * @return {string} The keysystem.
 */
ACMEVideoTrack.prototype.getKeySystem = function() {
  return this._keySystem;
};

/**
 * Returns the MediaType for the ACMEVideoTrack.
 *
 * @return {string} The MediaType.
 */
ACMEVideoTrack.prototype.getMediaType = function() {
  return this._mediaType;
};

/**
 * Returns a json-serializable object representing the logData for this track.
 *
 * @return {Object} The LogData.
 */
ACMEVideoTrack.prototype.toLogJSON = function() {
  return {
    uri: this._uri,
    fileId: this._fileId,
    format: this._format,
    resolved_url: 'unknown-video'
  };
};

module.exports = ACMEVideoTrack;
