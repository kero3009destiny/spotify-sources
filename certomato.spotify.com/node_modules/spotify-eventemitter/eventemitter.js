/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');
var Event = require('./_internal/event');

/**
 * The prefixes added for metalisteners.
 *
 * @const {string}
 * @private
 */
var InternalPrefix = {
  ADD: 'add:',
  REMOVE: 'remove:'
};

/**
 * A function that takes in an event.
 *
 * @typedef {function(Event)}
 * @private
 */
var EventHandler; // eslint-disable-line no-unused-vars

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers; // eslint-disable-line no-unused-vars

/**
 * Returns the index of the particular listener in the listeners array.
 *
 * @param {Array.<function>} listeners The array of listeners to search in.
 * @param {function} listener The listener to search for.
 * @param {EventOptions} options The options for the listener.
 * @return {number} The index of the listener, or -1 if it's not in the array.
 * @protected
 */
function _indexOfListener(listeners, listener, options) {
  var len = listeners.length;
  while (len--) {
    var current = listeners[len];
    if (
      current.listener === listener &&
      !!current.options.once === !!options.once
    ) {
      return len;
    }
  }
  return -1;
}

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.on('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.on('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap = {};
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} optParams An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, optParams) {
  if (!type) {
    throw new TypeError('Cannot create event with empty type.');
  }
  return new Event(type, optParams);
};


/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @param {EventOptions} options Options for this event handler.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.on = function(type, listener, options) {
  if (!type) {
    throw new TypeError('Cannot add event listener with empty type.');
  }
  if (!listener) {
    return this;
  }
  var _options = options || {once: false};
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (_indexOfListener(listeners, listener, _options) !== -1) {
    // Handler already added, return quickly.
    return this;
  }
  var metaListenerType = InternalPrefix.ADD + type;
  if (
    _listenerMap[metaListenerType] &&
    _listenerMap[metaListenerType].length
  ) {
    var event = this.emitSync(metaListenerType, {
      listener: listener,
      options: _options
    });
    if (event.defaultPrevented) {
      return this;
    }
  }
  listeners.push({
    listener: listener,
    options: _options
  });
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.once = function(type, listener) {
  if (!type) {
    throw new TypeError('Cannot add once listener with empty type.');
  }
  // We add this property here for backwards compatibility so that listeners
  // added using this method can be removed without having to specify options
  // in `removeListener`.
  listener.$added_once = true;
  this.on(type, listener, {once: true});
  return listener;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @param {EventOptions} options Options for all event handlers.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners, options) {
  for (var type in eventListeners) {
    if (eventListeners.hasOwnProperty(type)) {
      this.on(type, eventListeners[type], options);
    }
  }
  return this;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @param {EventOptions} options Options for the event a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener, options) {
  if (!type) {
    throw new TypeError('Cannot remove event listener with empty type.');
  }
  if (!listener) {
    return this;
  }
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var _options = options || {once: listener.$added_once || false};
  var index = _indexOfListener(listeners, listener, _options);
  if (index === -1) {
    return this;
  }
  var metaListenerType = InternalPrefix.REMOVE + type;
  if (
    _listenerMap[metaListenerType] &&
    _listenerMap[metaListenerType].length
  ) {
    var event = this.emitSync(metaListenerType, {
      listener: listener,
      options: _options,
      remainingLength: listeners.length - 1
    });
    if (event.defaultPrevented) {
      return this;
    }
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 * If no event type is given, all event listeners will be removed.
 *
 * @param {string=} optType The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(optType) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  if (optType === undefined) {
    this._listenerMap = {};
    return this;
  }
  _listenerMap[optType] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @param {EventOptions} options Options for the event a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners, options) {
  for (var type in eventListeners) {
    if (eventListeners.hasOwnProperty(type)) {
      this.removeListener(type, eventListeners[type], options);
    }
  }
  return this;
};

// ALIASES

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#on}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @param {EventOptions} options Options for the event a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#on}
 */
EventEmitter.prototype.addListener = function(type, listener, options) {
  return this.on(type, listener, options);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#once}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#once}
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  return this.on(type, listener, {once: true});
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `optParams` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} optParams An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, optParams) {
  if (!type) {
    throw new TypeError('Cannot emit empty type event.');
  }
  var event = new Event(type, optParams);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event like the `emit` method, but then calls a provided function
 * after all the event listeners have been called.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} optParams An object containing parameters for the Event
 *     object.
 * @param {EventHandler} done An event handler that will be called after all of
 *     the event handlers have been called.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitAndWait = function(type, optParams, done) {
  if (!type) {
    throw new TypeError('Cannot emit empty type event.');
  }
  var event = new Event(type, optParams);
  _defer(function() {
    this.emitEventSync(event);
    if (typeof done === 'function') {
      done(event);
    }
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event like `emitEvent`, but then calls a provided function after all
 * the event listeners have been called.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @param {EventHandler} done An event handler that will be called after all of
 *     the event handlers have been called.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventAndWait = function(event, done) {
  _defer(function() {
    this.emitEventSync(event);
    if (typeof done === 'function') {
      done(event);
    }
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `optParams` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} optParams An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, optParams) {
  var event = new Event(type, optParams);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    var item = listeners[i];
    if (item.options.once) {
      this.removeListener(type, item.listener, item.options);
    }
    item.listener.call(this, event);
    if (Event.wasImmediatePropagationStopped(event)) {
      break;
    }
  }
  return event;
};

/**
 * Proxies an event from another `EventEmitter` instance.
 *
 * This is used when we want to redirect events from internal objects to the
 * wrapping object. For example, if we have EventEmitter `A` that is referenced
 * inside EventEmitter `B` and we want to "re-emit" the event `A#eventName` as
 * `B#otherEventName`, we can call B.proxyEmit(A, 'eventName', 'otherEventName')
 *
 * @param {EventEmitter} source The EventEmitter source of the event.
 * @param {string} sourceType The type of event from the source to redirect.
 * @param {string} proxyType The type of event to fire for the current instance
 *     when `sourceType` is fired by `source`.
 * @return {function} The emitter function that can be used to remove the proxy
 *     via `removeListener`.
 */
EventEmitter.prototype.proxyEmit = function(source, sourceType, proxyType) {
  if (!source || typeof source.on !== 'function') {
    throw new TypeError('Source must be an EventEmitter');
  }
  if (source === this) {
    throw new ReferenceError('Cannot create a recursive proxy.');
  }
  if (!sourceType || !proxyType) {
    throw new TypeError('Parameters sourceType and proxyType are required.');
  }
  var emitter = this.emit.bind(this, proxyType);
  source.on(sourceType, emitter);
  return emitter;
};

/**
 * A synchronous version of `proxyEmit` (see that method for details).
 *
 * @param {EventEmitter} source The EventEmitter source of the event.
 * @param {string} sourceType The type of event from the source to redirect.
 * @param {string} proxyType The type of event to fire for the current instance
 *     when `sourceType` is fired by `source`.
 * @return {function} The emitter function that can be used to remove the proxy
 *     via `removeListener`.
 */
EventEmitter.prototype.proxyEmitSync = function(source, sourceType, proxyType) {
  if (!source || typeof source.on !== 'function') {
    throw new TypeError('Source must be an EventEmitter');
  }
  if (source === this) {
    throw new ReferenceError('Cannot create a recursive proxy.');
  }
  if (!sourceType || !proxyType) {
    throw new TypeError('Parameters sourceType and proxyType are required.');
  }
  var emitter = this.emitSync.bind(this, proxyType);
  source.on(sourceType, emitter);
  return emitter;
};

/**
 * Adds a "meta-listener" that will be called every time an event listener for
 * the given type is added to the EventEmitter.
 *
 * @param {string} type The type of event to listen for.
 * @param {function} listener A function that will be called when an event
 *     listener for the given type is added to the emitter.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.onAddListener = function(type, listener) {
  this.on(InternalPrefix.ADD + type, listener);
  return this;
};

/**
 * Adds a "meta-listener" that will be called every time an event listener for
 * the given type is removed from the EventEmitter.
 *
 * @param {string} type The type of event we were listening for.
 * @param {function} listener A function that will be called when an event
 *     listener for the given type is removed from the emitter.
 * @return {EventEmitter} The current object.
 */
EventEmitter.prototype.onRemoveListener = function(type, listener) {
  this.on(InternalPrefix.REMOVE + type, listener);
  return this;
};

module.exports = EventEmitter;
