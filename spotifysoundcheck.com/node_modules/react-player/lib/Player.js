'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _props6 = require('./props');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SEEK_ON_PLAY_EXPIRY = 5000;

var Player = function (_Component) {
  _inherits(Player, _Component);

  function Player() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Player);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Player.__proto__ || Object.getPrototypeOf(Player)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), _possibleConstructorReturn(_this, _ret);
  } // Track playing state internally to prevent bugs
  // Use isLoading to prevent onPause when switching URL


  _createClass(Player, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.mounted = true;
      this.player.load(this.props.url);
      this.progress();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.progressTimeout);
      clearTimeout(this.durationCheckTimeout);
      if (this.isReady) {
        this.player.stop();
      }
      if (this.player.disablePIP) {
        this.player.disablePIP();
      }
      this.mounted = false;
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this2 = this;

      // Invoke player methods based on incoming props
      var _props = this.props,
          url = _props.url,
          playing = _props.playing,
          volume = _props.volume,
          muted = _props.muted,
          playbackRate = _props.playbackRate,
          pip = _props.pip,
          loop = _props.loop;

      if (!(0, _utils.isEqual)(url, nextProps.url)) {
        if (this.isLoading) {
          console.warn('ReactPlayer: the attempt to load ' + nextProps.url + ' is being deferred until the player has loaded');
          this.loadOnReady = nextProps.url;
          return;
        }
        this.isLoading = true;
        this.startOnPlay = true;
        this.onDurationCalled = false;
        this.player.load(nextProps.url, this.isReady);
      }
      if (!playing && nextProps.playing && !this.isPlaying) {
        this.player.play();
      }
      if (playing && !nextProps.playing && this.isPlaying) {
        this.player.pause();
      }
      if (!pip && nextProps.pip && this.player.enablePIP) {
        this.player.enablePIP();
      } else if (pip && !nextProps.pip && this.player.disablePIP) {
        this.player.disablePIP();
      }
      if (volume !== nextProps.volume && nextProps.volume !== null) {
        this.player.setVolume(nextProps.volume);
      }
      if (muted !== nextProps.muted) {
        if (nextProps.muted) {
          this.player.mute();
        } else {
          this.player.unmute();
          if (nextProps.volume !== null) {
            // Set volume next tick to fix a bug with DailyMotion
            setTimeout(function () {
              return _this2.player.setVolume(nextProps.volume);
            });
          }
        }
      }
      if (playbackRate !== nextProps.playbackRate && this.player.setPlaybackRate) {
        this.player.setPlaybackRate(nextProps.playbackRate);
      }
      if (loop !== nextProps.loop && this.player.setLoop) {
        this.player.setLoop(nextProps.loop);
      }
    }
  }, {
    key: 'getDuration',
    value: function getDuration() {
      if (!this.isReady) return null;
      return this.player.getDuration();
    }
  }, {
    key: 'getCurrentTime',
    value: function getCurrentTime() {
      if (!this.isReady) return null;
      return this.player.getCurrentTime();
    }
  }, {
    key: 'getSecondsLoaded',
    value: function getSecondsLoaded() {
      if (!this.isReady) return null;
      return this.player.getSecondsLoaded();
    }
  }, {
    key: 'seekTo',
    value: function seekTo(amount, type) {
      var _this3 = this;

      // When seeking before player is ready, store value and seek later
      if (!this.isReady && amount !== 0) {
        this.seekOnPlay = amount;
        setTimeout(function () {
          _this3.seekOnPlay = null;
        }, SEEK_ON_PLAY_EXPIRY);
        return;
      }
      var isFraction = !type ? amount > 0 && amount < 1 : type === 'fraction';
      if (isFraction) {
        // Convert fraction to seconds based on duration
        var duration = this.player.getDuration();
        if (!duration) {
          console.warn('ReactPlayer: could not seek using fraction – duration not yet available');
          return;
        }
        this.player.seekTo(duration * amount);
        return;
      }
      this.player.seekTo(amount);
    }
  }, {
    key: 'render',
    value: function render() {
      var Player = this.props.activePlayer;
      if (!Player) {
        return null;
      }
      return _react2['default'].createElement(Player, _extends({}, this.props, {
        ref: this.ref,
        onReady: this.onReady,
        onPlay: this.onPlay,
        onPause: this.onPause,
        onEnded: this.onEnded,
        onLoaded: this.onLoaded,
        onError: this.onError
      }));
    }
  }]);

  return Player;
}(_react.Component);

Player.displayName = 'Player';
Player.propTypes = _props6.propTypes;
Player.defaultProps = _props6.defaultProps;

var _initialiseProps = function _initialiseProps() {
  var _this4 = this;

  this.mounted = false;
  this.isReady = false;
  this.isPlaying = false;
  this.isLoading = true;
  this.loadOnReady = null;
  this.startOnPlay = true;
  this.seekOnPlay = null;
  this.onDurationCalled = false;

  this.getInternalPlayer = function (key) {
    if (!_this4.player) return null;
    return _this4.player[key];
  };

  this.progress = function () {
    if (_this4.props.url && _this4.player && _this4.isReady) {
      var playedSeconds = _this4.getCurrentTime() || 0;
      var loadedSeconds = _this4.getSecondsLoaded();
      var duration = _this4.getDuration();
      if (duration) {
        var progress = {
          playedSeconds: playedSeconds,
          played: playedSeconds / duration
        };
        if (loadedSeconds !== null) {
          progress.loadedSeconds = loadedSeconds;
          progress.loaded = loadedSeconds / duration;
        }
        // Only call onProgress if values have changed
        if (progress.playedSeconds !== _this4.prevPlayed || progress.loadedSeconds !== _this4.prevLoaded) {
          _this4.props.onProgress(progress);
        }
        _this4.prevPlayed = progress.playedSeconds;
        _this4.prevLoaded = progress.loadedSeconds;
      }
    }
    _this4.progressTimeout = setTimeout(_this4.progress, _this4.props.progressFrequency || _this4.props.progressInterval);
  };

  this.onReady = function () {
    if (!_this4.mounted) return;
    _this4.isReady = true;
    _this4.isLoading = false;
    var _props2 = _this4.props,
        onReady = _props2.onReady,
        playing = _props2.playing,
        volume = _props2.volume,
        muted = _props2.muted;

    onReady();
    if (!muted && volume !== null) {
      _this4.player.setVolume(volume);
    }
    if (_this4.loadOnReady) {
      _this4.player.load(_this4.loadOnReady, true);
      _this4.loadOnReady = null;
    } else if (playing) {
      _this4.player.play();
    }
    _this4.onDurationCheck();
  };

  this.onPlay = function () {
    _this4.isPlaying = true;
    _this4.isLoading = false;
    var _props3 = _this4.props,
        onStart = _props3.onStart,
        onPlay = _props3.onPlay,
        playbackRate = _props3.playbackRate;

    if (_this4.startOnPlay) {
      if (_this4.player.setPlaybackRate) {
        _this4.player.setPlaybackRate(playbackRate);
      }
      onStart();
      _this4.startOnPlay = false;
    }
    onPlay();
    if (_this4.seekOnPlay) {
      _this4.seekTo(_this4.seekOnPlay);
      _this4.seekOnPlay = null;
    }
    _this4.onDurationCheck();
  };

  this.onPause = function (e) {
    _this4.isPlaying = false;
    if (!_this4.isLoading) {
      _this4.props.onPause(e);
    }
  };

  this.onEnded = function () {
    var _props4 = _this4.props,
        activePlayer = _props4.activePlayer,
        loop = _props4.loop,
        onEnded = _props4.onEnded;

    if (activePlayer.loopOnEnded && loop) {
      _this4.seekTo(0);
    }
    if (!loop) {
      _this4.isPlaying = false;
      onEnded();
    }
  };

  this.onError = function () {
    var _props5;

    _this4.isLoading = false;
    (_props5 = _this4.props).onError.apply(_props5, arguments);
  };

  this.onDurationCheck = function () {
    clearTimeout(_this4.durationCheckTimeout);
    var duration = _this4.getDuration();
    if (duration) {
      if (!_this4.onDurationCalled) {
        _this4.props.onDuration(duration);
        _this4.onDurationCalled = true;
      }
    } else {
      _this4.durationCheckTimeout = setTimeout(_this4.onDurationCheck, 100);
    }
  };

  this.onLoaded = function () {
    // Sometimes we know loading has stopped but onReady/onPlay are never called
    // so this provides a way for players to avoid getting stuck
    _this4.isLoading = false;
  };

  this.ref = function (player) {
    if (player) {
      _this4.player = player;
    }
  };
};

exports['default'] = Player;